<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xtensor: xt Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xtensor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacext.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">xt Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>standard mathematical functions for xexpressions  
<a href="namespacext.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xconst__accessible.html">xconst_accessible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementation of common expression constant access methods.  <a href="classxt_1_1xconst__accessible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xaccessible.html">xaccessible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for implementation of common expression access methods.  <a href="classxt_1_1xaccessible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xaccumulator__functor.html">xaccumulator_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xarray__container_3_01_e_c_00_01_l_00_01_s_c_00_01_tag_01_4_01_4.html">xcontainer_inner_types&lt; xarray_container&lt; EC, L, SC, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xarray__container_3_01_e_c_00_01_l_00_01_s_c_00_01_tag_01_4_01_4.html">xiterable_inner_types&lt; xarray_container&lt; EC, L, SC, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xarray__container.html">xarray_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container with tensor semantic.  <a href="classxt_1_1xarray__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xarray__adaptor_3_01_e_c_00_01_l_00_01_s_c_00_01_tag_01_4_01_4.html">xcontainer_inner_types&lt; xarray_adaptor&lt; EC, L, SC, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xarray__adaptor_3_01_e_c_00_01_l_00_01_s_c_00_01_tag_01_4_01_4.html">xiterable_inner_types&lt; xarray_adaptor&lt; EC, L, SC, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xarray__adaptor.html">xarray_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container adaptor with tensor semantic.  <a href="classxt_1_1xarray__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xexpression__assigner__base.html">xexpression_assigner_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xexpression__assigner__base_3_01xtensor__expression__tag_01_4.html">xexpression_assigner_base&lt; xtensor_expression_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xexpression__assigner.html">xexpression_assigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1stepper__assigner.html">stepper_assigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1linear__assigner.html">linear_assigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1linear__assigner_3_01false_01_4.html">linear_assigner&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1strided__loop__assigner.html">strided_loop_assigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xassign__traits.html">xassign_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__narrowing__conversion.html">is_narrowing_conversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__sign__conversion.html">has_sign_conversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__assign__conversion.html">has_assign_conversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for iteration over (N-1)-dimensional slices, where N is the dimension of the underlying expression.  <a href="classxt_1_1xaxis__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for iteration over one-dimensional slices.  <a href="classxt_1_1xaxis__slice__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xbroadcast.html">xbroadcast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasted xexpression to a specified shape.  <a href="classxt_1_1xbroadcast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xbroadcast_3_01_c_t_00_01_x_01_4_01_4.html">xiterable_inner_types&lt; xbroadcast&lt; CT, X &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xbroadcast_3_01_c_t_00_01_x_01_4_01_4.html">xcontainer_inner_types&lt; xbroadcast&lt; CT, X &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1no__ownership.html">no_ownership</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1acquire__ownership.html">acquire_ownership</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xbuffer__adaptor.html">xbuffer_adaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1buffer__inner__types.html">buffer_inner_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1buffer__inner__types_3_01xbuffer__adaptor_3_01_c_p_00_01_o_00_01_a_01_4_01_4.html">buffer_inner_types&lt; xbuffer_adaptor&lt; CP, O, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xiterator__adaptor.html">xiterator_adaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1buffer__inner__types_3_01xiterator__adaptor_3_01_i_00_01_c_i_01_4_01_4.html">buffer_inner_types&lt; xiterator_adaptor&lt; I, CI &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__contiguous__container_3_01xiterator__adaptor_3_01_i_00_01_c_i_01_4_01_4.html">is_contiguous_container&lt; xiterator_adaptor&lt; I, CI &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xiterator__owner__adaptor.html">xiterator_owner_adaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1buffer__inner__types_3_01xiterator__owner__adaptor_3_01_c_00_01_i_g_01_4_01_4.html">buffer_inner_types&lt; xiterator_owner_adaptor&lt; C, IG &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__contiguous__container_3_01xiterator__owner__adaptor_3_01_c_00_01_i_g_01_4_01_4.html">is_contiguous_container&lt; xiterator_owner_adaptor&lt; C, IG &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__container.html">temporary_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__container_3_01xbuffer__adaptor_3_01_c_p_00_01_o_00_01_a_01_4_01_4.html">temporary_container&lt; xbuffer_adaptor&lt; CP, O, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__container_3_01xiterator__adaptor_3_01_i_00_01_c_i_01_4_01_4.html">temporary_container&lt; xiterator_adaptor&lt; I, CI &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__container_3_01xiterator__owner__adaptor_3_01_c_00_01_i_g_01_4_01_4.html">temporary_container&lt; xiterator_owner_adaptor&lt; C, IG &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xchunked__assigner.html">xchunked_assigner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xchunked__semantic.html">xchunked_semantic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xchunked__array_3_01chunk__storage_01_4_01_4.html">xcontainer_inner_types&lt; xchunked_array&lt; chunk_storage &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xchunked__array_3_01chunk__storage_01_4_01_4.html">xiterable_inner_types&lt; xchunked_array&lt; chunk_storage &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xchunked__view.html">xchunked_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xchunk__iterator.html">xchunk_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__iterable__types.html">xcontainer_iterable_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xcontainer.html">xcontainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense multidimensional containers.  <a href="classxt_1_1xcontainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xstrided__container.html">xstrided_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial implementation of xcontainer that embeds the strides and the shape.  <a href="classxt_1_1xstrided__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcsv__config.html">xcsv_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xdynamic__view.html">xdynamic_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xdynamic__view_3_01_c_t_00_01_s_00_01_l_00_01_f_s_t_01_4_01_4.html">xcontainer_inner_types&lt; xdynamic_view&lt; CT, S, L, FST &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xdynamic__view_3_01_c_t_00_01_s_00_01_l_00_01_f_s_t_01_4_01_4.html">xiterable_inner_types&lt; xdynamic_view&lt; CT, S, L, FST &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1broadcast__error.html">broadcast_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1concatenate__error.html">concatenate_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1transpose__error.html">transpose_error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xexpression.html">xexpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for xexpressions.  <a href="classxt_1_1xexpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xshared__expression.html">xshared_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared xexpressions.  <a href="classxt_1_1xshared__expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xsharable__expression.html">xsharable_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1can__assign.html">can_assign</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__evaluation__strategy.html">is_evaluation_strategy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xscalar.html">xscalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xclosure.html">xclosure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xclosure_3_01xshared__expression_3_01_e_01_4_00_01std_1_1enable__if__t_3_01true_01_4_01_4.html">xclosure&lt; xshared_expression&lt; E &gt;, std::enable_if_t&lt; true &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xclosure_3_01_e_00_01disable__xexpression_3_01std_1_1decay__t_3_01_e_01_4_01_4_01_4.html">xclosure&lt; E, disable_xexpression&lt; std::decay_t&lt; E &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1const__xclosure.html">const_xclosure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1const__xclosure_3_01_e_00_01disable__xexpression_3_01std_1_1decay__t_3_01_e_01_4_01_4_01_4.html">const_xclosure&lt; E, disable_xexpression&lt; std::decay_t&lt; E &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1const__xclosure_3_01xshared__expression_3_01_e_01_4_01_6_00_01std_1_1enable__if__t_3_01true_01_4_01_4.html">const_xclosure&lt; xshared_expression&lt; E &gt; &amp;, std::enable_if_t&lt; true &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xtensor__expression__tag.html">xtensor_expression_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xoptional__expression__tag.html">xoptional_expression_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xexpression__tag.html">xexpression_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__xtensor__expression.html">is_xtensor_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__xoptional__expression.html">is_xoptional_expression</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xoptional__comparable.html">xoptional_comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xexpression__holder.html">xexpression_holder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1common__value__type.html">common_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1common__size__type.html">common_size_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1common__size__type_3_4.html">common_size_type&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1common__difference__type.html">common_difference_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1common__difference__type_3_4.html">common_difference_type&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__type__from__tag.html">temporary_type_from_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__type__from__tag_3_01xtensor__expression__tag_00_01_t_01_4.html">temporary_type_from_tag&lt; xtensor_expression_tag, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__type.html">temporary_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1temporary__type_3_01_t_00_01void__t_3_01typename_01std_1_1decay__t_3_01_t_01_4_1_1temporary__type_01_4_01_4.html">temporary_type&lt; T, void_t&lt; typename std::decay_t&lt; T &gt;::temporary_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1common__tensor__type.html">common_tensor_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1big__promote__value__type.html">big_promote_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfixed__container.html">xfixed_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container with tensor semantic and fixed dimension.  <a href="classxt_1_1xfixed__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__init__type.html">get_init_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__init__type_3_01_v_00_01fixed__shape_3_01_x_8_8_8_01_4_01_4.html">get_init_type&lt; V, fixed_shape&lt; X... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xfixed__container_3_01_e_t_00_01_s_00_01_l_00_01_s_h_00_01_tag_01_4_01_4.html">xcontainer_inner_types&lt; xfixed_container&lt; ET, S, L, SH, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xfixed__container_3_01_e_t_00_01_s_00_01_l_00_01_s_h_00_01_tag_01_4_01_4.html">xiterable_inner_types&lt; xfixed_container&lt; ET, S, L, SH, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfixed__adaptor.html">xfixed_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container adaptor with tensor semantic and fixed dimension.  <a href="classxt_1_1xfixed__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xfixed__adaptor_3_01_e_c_00_01_s_00_01_l_00_01_s_h_00_01_tag_01_4_01_4.html">xcontainer_inner_types&lt; xfixed_adaptor&lt; EC, S, L, SH, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xfixed__adaptor_3_01_e_c_00_01_s_00_01_l_00_01_s_h_00_01_tag_01_4_01_4.html">xiterable_inner_types&lt; xfixed_adaptor&lt; EC, S, L, SH, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xfunction__cache.html">xfunction_cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunction__iterator.html">xfunction_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunction__stepper.html">xfunction_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunction.html">xfunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multidimensional function operating on xtensor expressions.  <a href="classxt_1_1xfunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xfunction_3_01_f_00_01_c_t_8_8_8_01_4_01_4.html">xiterable_inner_types&lt; xfunction&lt; F, CT... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xfunction_3_01_f_00_01_c_t_8_8_8_01_4_01_4.html">xcontainer_inner_types&lt; xfunction&lt; F, CT... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__interface_3_01xfunction_3_01_f_00_01_c_t_8_8_8_01_4_00_01_t_01_4.html">has_simd_interface&lt; xfunction&lt; F, CT... &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunctor__iterator.html">xfunctor_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunctor__stepper.html">xfunctor_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunctor__applier__base.html">xfunctor_applier_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__interface_3_01xfunctor__applier__base_3_01_d_01_4_00_01_t_01_4.html">has_simd_interface&lt; xfunctor_applier_base&lt; D &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xfunctor__view__temporary__type.html">xfunctor_view_temporary_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunctor__view.html">xfunctor_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of an xexpression .  <a href="classxt_1_1xfunctor__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xfunctor__view_3_01_f_00_01_c_t_01_4_01_4.html">xcontainer_inner_types&lt; xfunctor_view&lt; F, CT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__interface_3_01xfunctor__view_3_01_f_00_01_c_t_01_4_00_01_t_01_4.html">has_simd_interface&lt; xfunctor_view&lt; F, CT &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfunctor__adaptor.html">xfunctor_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a container with a functor, forwarding methods such as resize / reshape.  <a href="classxt_1_1xfunctor__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xfunctor__adaptor_3_01_f_00_01_c_t_01_4_01_4.html">xcontainer_inner_types&lt; xfunctor_adaptor&lt; F, CT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__interface_3_01xfunctor__adaptor_3_01_f_00_01_c_t_01_4_00_01_t_01_4.html">has_simd_interface&lt; xfunctor_adaptor&lt; F, CT &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xproxy__inner__types.html">xproxy_inner_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xgenerator.html">xgenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multidimensional function operating on indices.  <a href="classxt_1_1xgenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xgenerator_3_01_c_00_01_r_00_01_s_01_4_01_4.html">xiterable_inner_types&lt; xgenerator&lt; C, R, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xgenerator_3_01_c_00_01_r_00_01_s_01_4_01_4.html">xcontainer_inner_types&lt; xgenerator&lt; C, R, S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xindex__view.html">xindex_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of an xexpression from vector of indices.  <a href="classxt_1_1xindex__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xindex__view_3_01_c_t_00_01_i_01_4_01_4.html">xcontainer_inner_types&lt; xindex_view&lt; CT, I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xindex__view_3_01_c_t_00_01_i_01_4_01_4.html">xiterable_inner_types&lt; xindex_view&lt; CT, I &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xfiltration.html">xfiltration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter of a xexpression for fast scalar assign.  <a href="classxt_1_1xfiltration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1static__string.html">static_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types.html">xiterable_inner_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xconst__iterable.html">xconst_iterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for multidimensional iterable constant expressions.  <a href="classxt_1_1xconst__iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xiterable.html">xiterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for multidimensional iterable expressions.  <a href="classxt_1_1xiterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types.html">xcontainer_inner_types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xcontiguous__iterable.html">xcontiguous_iterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for multidimensional iterable expressions with contiguous storage.  <a href="classxt_1_1xcontiguous__iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xscalar__stepper.html">xscalar_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xstepper.html">xstepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1stepper__tools.html">stepper_tools</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xindexed__stepper.html">xindexed_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__indexed__stepper.html">is_indexed_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__indexed__stepper_3_01xindexed__stepper_3_01_t_00_01_b_01_4_01_4.html">is_indexed_stepper&lt; xindexed_stepper&lt; T, B &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1enable__indexed__stepper.html">enable_indexed_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1disable__indexed__stepper.html">disable_indexed_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xiterator.html">xiterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__contiguous__container_3_01xiterator_3_01_st_00_01_s_00_01_l_01_4_01_4.html">is_contiguous_container&lt; xiterator&lt; St, S, L &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xbounded__iterator.html">xbounded_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rot90__impl.html">rot90_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rot90__impl_3_010_01_4.html">rot90_impl&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rot90__impl_3_011_01_4.html">rot90_impl&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rot90__impl_3_012_01_4.html">rot90_impl&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rot90__impl_3_013_01_4.html">rot90_impl&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xmasked__view.html">xmasked_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View on an <a class="el" href="classxt_1_1xoptional__assembly.html" title="Dense multidimensional container holding optional values, optimized for tensor operations.">xoptional_assembly</a> or <a class="el" href="classxt_1_1xoptional__assembly__adaptor.html" title="Dense multidimensional adaptor holding optional values, optimized for tensor operations.">xoptional_assembly_adaptor</a> hiding values depending on a given mask.  <a href="classxt_1_1xmasked__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xmasked__view__stepper.html">xmasked_view_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xmasked__view_3_01_c_t_d_00_01_c_t_m_01_4_01_4.html">xcontainer_inner_types&lt; xmasked_view&lt; CTD, CTM &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xmasked__view_3_01_c_t_d_00_01_c_t_m_01_4_01_4.html">xiterable_inner_types&lt; xmasked_view&lt; CTD, CTM &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1numeric__constants.html">numeric_constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xtensor__container.html">xtensor_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container with tensor semantic and fixed dimension.  <a href="classxt_1_1xtensor__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xreducer.html">xreducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reducing function operating over specified axes.  <a href="classxt_1_1xreducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xoptional__assembly.html">xoptional_assembly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container holding optional values, optimized for tensor operations.  <a href="classxt_1_1xoptional__assembly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xoptional__assembly__adaptor.html">xoptional_assembly_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional adaptor holding optional values, optimized for tensor operations.  <a href="classxt_1_1xoptional__assembly__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xview.html">xview</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multidimensional view with tensor semantic.  <a href="classxt_1_1xview.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xstrided__view.html">xstrided_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View of an xexpression using strides.  <a href="classxt_1_1xstrided__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xmasked__value.html">xmasked_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1noalias__proxy.html">noalias_proxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1norm__type.html">norm_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for the result type of the <code><a class="el" href="group__red__functions.html#ga612264ac7b3ed369ebe6da569e2bf7f5" title="L2 norm of a scalar or array-like argument.">norm_l2()</a></code> function.  <a href="structxt_1_1norm__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1squared__norm__type.html">squared_norm_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for the result type of the <code><a class="el" href="group__red__functions.html#ga243ff01254cf5c1bcfe3ef6b6b67331d" title="Squared L2 norm of an array-like argument over given axes.">norm_sq()</a></code> function.  <a href="structxt_1_1squared__norm__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xexpression__assigner__base_3_01xoptional__expression__tag_01_4.html">xexpression_assigner_base&lt; xoptional_expression_tag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xoptional__assembly_3_01_v_e_00_01_f_e_01_4_01_4.html">xcontainer_inner_types&lt; xoptional_assembly&lt; VE, FE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xoptional__assembly_3_01_v_e_00_01_f_e_01_4_01_4.html">xiterable_inner_types&lt; xoptional_assembly&lt; VE, FE &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xoptional__assembly__adaptor_3_01_v_e_c_00_01_f_e_c_01_4_01_4.html">xcontainer_inner_types&lt; xoptional_assembly_adaptor&lt; VEC, FEC &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xoptional__assembly__adaptor_3_01_v_e_c_00_01_f_e_c_01_4_01_4.html">xiterable_inner_types&lt; xoptional_assembly_adaptor&lt; VEC, FEC &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xoptional__assembly__stepper.html">xoptional_assembly_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xoptional__assembly__base.html">xoptional_assembly_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense multidimensional optional assemblies.  <a href="classxt_1_1xoptional__assembly__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xoptional__assembly__storage__iterator.html">xoptional_assembly_storage_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xoptional__assembly__storage__iterator__traits.html">xoptional_assembly_storage_iterator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1keep__dims__type.html">keep_dims_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xinitial.html">xinitial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1tuple__idx__of__impl.html">tuple_idx_of_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1tuple__idx__of__impl_3_01_i_00_01_t_00_01std_1_1tuple_3_4_01_4.html">tuple_idx_of_impl&lt; I, T, std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1tuple__idx__of__impl_3_01_i_00_01_t_00_01std_1_1tuple_3_01_t_00_01_types_8_8_8_01_4_01_4.html">tuple_idx_of_impl&lt; I, T, std::tuple&lt; T, Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1tuple__idx__of__impl_3_01_i_00_01_t_00_01std_1_1tuple_3_01_u_00_01_types_8_8_8_01_4_01_4.html">tuple_idx_of_impl&lt; I, T, std::tuple&lt; U, Types... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1decay__all.html">decay_all</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1decay__all_3_01_s_3_01_x_8_8_8_01_4_01_4.html">decay_all&lt; S&lt; X... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1tuple__idx__of.html">tuple_idx_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1reducer__options.html">reducer_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__reducer__options__impl.html">is_reducer_options_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__reducer__options__impl_3_01std_1_1tuple_3_01_x_8_8_8_01_4_01_4.html">is_reducer_options_impl&lt; std::tuple&lt; X... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__reducer__options.html">is_reducer_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xreducer__shape__type.html">xreducer_shape_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1fixed__xreducer__shape__type.html">fixed_xreducer_shape_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1const__value.html">const_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xreducer__functors.html">xreducer_functors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xreducer__stepper.html">xreducer_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xreducer_3_01_f_00_01_c_t_00_01_x_00_01_o_01_4_01_4.html">xiterable_inner_types&lt; xreducer&lt; F, CT, X, O &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xreducer_3_01_f_00_01_c_t_00_01_x_00_01_o_01_4_01_4.html">xcontainer_inner_types&lt; xreducer&lt; F, CT, X, O &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1select__dim__mapping__type.html">select_dim_mapping_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1select__dim__mapping__type_3_01fixed__shape_3_01_i_8_8_8_01_4_01_4.html">select_dim_mapping_type&lt; fixed_shape&lt; I... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1fixed__xreducer__shape__type_3_01fixed__shape_3_01_i_8_8_8_01_4_00_01fixed__shape_3_01_j_8_8_8_01_4_01_4.html">fixed_xreducer_shape_type&lt; fixed_shape&lt; I... &gt;, fixed_shape&lt; J... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xreducer__shape__type_3_01std_1_1array_3_01_i1_00_01_n1_01_4_00_01std_1_1array_3_01_c677fa36e83a1c564b51c5abf4a0c7d9.html">xreducer_shape_type&lt; std::array&lt; I1, N1 &gt;, std::array&lt; I2, N2 &gt;, std::true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xreducer__shape__type_3_01std_1_1array_3_01_i1_00_01_n1_01_4_00_01std_1_1array_3_01_f0fe2e231e25d4e5852b877ba4b36e02.html">xreducer_shape_type&lt; std::array&lt; I1, N1 &gt;, std::array&lt; I2, N2 &gt;, std::false_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xreducer__shape__type_3_01fixed__shape_3_01_i_8_8_8_01_4_00_01std_1_1array_3_01_i2_0113732d5b63b22c20cb89d3a7b591d8f.html">xreducer_shape_type&lt; fixed_shape&lt; I... &gt;, std::array&lt; I2, N2 &gt;, std::false_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xreducer__shape__type_3_01fixed__shape_3_01_i_8_8_8_01_4_00_01std_1_1array_3_01_i2_06680ea94625f20ef8cb3bcfb83eeaa0c.html">xreducer_shape_type&lt; fixed_shape&lt; I... &gt;, std::array&lt; I2, N2 &gt;, std::true_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xreducer__shape__type_3_01fixed__shape_3_01_i_8_8_8_01_4_00_01fixed__shape_3_01_j_8_8_8_01_4_00_01_o_01_4.html">xreducer_shape_type&lt; fixed_shape&lt; I... &gt;, fixed_shape&lt; J... &gt;, O &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xrepeat.html">xrepeat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression with repeated values along an axis.  <a href="classxt_1_1xrepeat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xrepeat__stepper.html">xrepeat_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xrepeat_3_01_c_t_00_01_r_01_4_01_4.html">xcontainer_inner_types&lt; xrepeat&lt; CT, R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xrepeat_3_01_c_t_00_01_r_01_4_01_4.html">xiterable_inner_types&lt; xrepeat&lt; CT, R &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xdummy__iterator.html">xdummy_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xscalar_3_01_c_t_01_4_01_4.html">xiterable_inner_types&lt; xscalar&lt; CT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xscalar_3_01_c_t_01_4_01_4.html">xcontainer_inner_types&lt; xscalar&lt; CT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__not__xdummy__iterator.html">is_not_xdummy_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__not__xdummy__iterator_3_01xdummy__iterator_3_01is__const_00_01_c_t_01_4_01_4.html">is_not_xdummy_iterator&lt; xdummy_iterator&lt; is_const, CT &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xsemantic__base.html">xsemantic_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base interface for assignable xexpressions.  <a href="classxt_1_1xsemantic__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xcontainer__semantic.html">xcontainer_semantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="classxt_1_1xsemantic__base.html" title="Base interface for assignable xexpressions.">xsemantic_base</a> interface for dense multidimensional containers.  <a href="classxt_1_1xcontainer__semantic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xview__semantic.html">xview_semantic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="classxt_1_1xsemantic__base.html" title="Base interface for assignable xexpressions.">xsemantic_base</a> interface for multidimensional views.  <a href="classxt_1_1xview__semantic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1fixed__shape.html">fixed_shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed shape implementation for compile time defined arrays.  <a href="classxt_1_1fixed__shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1initializer__dimension.html">initializer_dimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1static__dimension.html">static_dimension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1select__layout.html">select_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a layout based on a layout and a shape type.  <a href="structxt_1_1select__layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1promote__shape.html">promote_shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1promote__strides.html">promote_strides</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1index__from__shape.html">index_from_shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1filter__fixed__shape.html">filter_fixed_shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xslice.html">xslice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xall__tag.html">xall_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xnewaxis__tag.html">xnewaxis_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xellipsis__tag.html">xellipsis_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xrange.html">xrange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xstepped__range.html">xstepped_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xall.html">xall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xnewaxis.html">xnewaxis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xkeep__slice.html">xkeep_slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xdrop__slice.html">xdrop_slice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__contiguous__container.html">is_contiguous_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1uvector.html">uvector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1svector.html">svector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rebind__container_3_01_x_00_01svector_3_01_t_00_01_n_00_01_a_00_01_b_01_4_01_4.html">rebind_container&lt; X, svector&lt; T, N, A, B &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1aligned__array.html">aligned_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This array class is modeled after <code>std::array</code> but adds optional alignment through a template parameter.  <a href="classxt_1_1aligned__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1const__array.html">const_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::array like class with all member function (except reverse iterators) as constexpr.  <a href="structxt_1_1const__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1sequence__view.html">sequence_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1select__iterable__base.html">select_iterable_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xstrided__view_3_01_c_t_00_01_s_00_01_l_00_01_f_s_t_01_4_01_4.html">xcontainer_inner_types&lt; xstrided_view&lt; CT, S, L, FST &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xstrided__view_3_01_c_t_00_01_s_00_01_l_00_01_f_s_t_01_4_01_4.html">xiterable_inner_types&lt; xstrided_view&lt; CT, S, L, FST &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1can__assign_3_01xstrided__view_3_01_c_t_00_01_s_00_01_l_00_01_f_s_t_01_4_00_01_r_h_s_01_4.html">can_assign&lt; xstrided_view&lt; CT, S, L, FST &gt;, RHS &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xstrided__view__base.html">xstrided_view_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1check__strides__overlap.html">check_strides_overlap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1check__strides__overlap_3_01layout__type_1_1row__major_01_4.html">check_strides_overlap&lt; layout_type::row_major &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1check__strides__overlap_3_01layout__type_1_1column__major_01_4.html">check_strides_overlap&lt; layout_type::column_major &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xtensor__container_3_01_e_c_00_01_n_00_01_l_00_01_tag_01_4_01_4.html">xcontainer_inner_types&lt; xtensor_container&lt; EC, N, L, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xtensor__container_3_01_e_c_00_01_n_00_01_l_00_01_tag_01_4_01_4.html">xiterable_inner_types&lt; xtensor_container&lt; EC, N, L, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xtensor__adaptor_3_01_e_c_00_01_n_00_01_l_00_01_tag_01_4_01_4.html">xcontainer_inner_types&lt; xtensor_adaptor&lt; EC, N, L, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xtensor__adaptor_3_01_e_c_00_01_n_00_01_l_00_01_tag_01_4_01_4.html">xiterable_inner_types&lt; xtensor_adaptor&lt; EC, N, L, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xtensor__adaptor.html">xtensor_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container adaptor with tensor semantics and fixed dimension.  <a href="classxt_1_1xtensor__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xtensor__view.html">xtensor_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense multidimensional container adaptor with view semantics and fixed dimension.  <a href="classxt_1_1xtensor__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xtensor__view_3_01_e_c_00_01_n_00_01_l_00_01_tag_01_4_01_4.html">xcontainer_inner_types&lt; xtensor_view&lt; EC, N, L, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xtensor__view_3_01_e_c_00_01_n_00_01_l_00_01_tag_01_4_01_4.html">xiterable_inner_types&lt; xtensor_view&lt; EC, N, L, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__interface_3_01xtensor__view_3_01_e_c_00_01_n_00_01_l_00_01_tag_01_4_01_4.html">has_simd_interface&lt; xtensor_view&lt; EC, N, L, Tag &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1inner__aligned__mode.html">inner_aligned_mode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1driven__align__mode.html">driven_align_mode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__interface.html">has_simd_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__type.html">has_simd_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__simd__apply.html">has_simd_apply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1forbid__simd.html">forbid_simd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1forbid__simd_3_01std_1_1vector_3_01bool_00_01_a_01_4_01_4.html">forbid_simd&lt; std::vector&lt; bool, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1forbid__simd_3_01const_01std_1_1vector_3_01bool_00_01_a_01_4_01_4.html">forbid_simd&lt; const std::vector&lt; bool, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1forbid__simd_3_01xtl_1_1xdynamic__bitset_3_01_b_00_01_a_01_4_01_4.html">forbid_simd&lt; xtl::xdynamic_bitset&lt; B, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1forbid__simd_3_01const_01xtl_1_1xdynamic__bitset_3_01_b_00_01_a_01_4_01_4.html">forbid_simd&lt; const xtl::xdynamic_bitset&lt; B, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1container__simd__return__type.html">container_simd_return_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1remove__class.html">remove_class</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rebind__container.html">rebind_container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1make__void.html">make_void</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1invalid__type.html">invalid_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1make__invalid__type.html">make_invalid_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1meta__identity.html">meta_identity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1remove__class_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_4.html">remove_class&lt; R(C::*)(Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1remove__class_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_4.html">remove_class&lt; R(C::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1nested__initializer__list.html">nested_initializer_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1nested__initializer__list_3_01_t_00_010_01_4.html">nested_initializer_list&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__value__type.html">get_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__value__type_3_01_t_00_01void__t_3_01typename_01_t_1_1value__type_01_4_01_4.html">get_value_type&lt; T, void_t&lt; typename T::value_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1apply__cv.html">apply_cv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__data__interface.html">has_data_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__data__interface_3_01_e_00_01void__t_3_01decltype_07std_1_1declval_3_01_e_01_4_07_08_8data_07_08_08_4_01_4.html">has_data_interface&lt; E, void_t&lt; decltype(std::declval&lt; E &gt;().data())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__strides.html">has_strides</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__strides_3_01_e_00_01void__t_3_01decltype_07std_1_1declval_3_01_e_01_4_07_08_8strides_07_08_08_4_01_4.html">has_strides&lt; E, void_t&lt; decltype(std::declval&lt; E &gt;().strides())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__iterator__interface.html">has_iterator_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__iterator__interface_3_01_e_00_01void__t_3_01decltype_07std_1_1declval_3_01_e_01_4_07_08_8begin_07_08_08_4_01_4.html">has_iterator_interface&lt; E, void_t&lt; decltype(std::declval&lt; E &gt;().begin())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1is__iterator_3_01_e_00_01void__t_3_01decltype_07_5std_1_1declval_3_01const_01_e_01_41da12c429c255d2c81e18d875fbe6e98.html">is_iterator&lt; E, void_t&lt; decltype(*std::declval&lt; const E &gt;(), std::declval&lt; const E &gt;()==std::declval&lt; const E &gt;(), std::declval&lt; const E &gt;() !=std::declval&lt; const E &gt;(),++(*std::declval&lt; E * &gt;()),(*std::declval&lt; E * &gt;())++, std::true_type())&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1conditional__cast__functor.html">conditional_cast_functor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1conditional__cast__functor_3_01false_00_01_t_01_4.html">conditional_cast_functor&lt; false, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1conditional__cast__functor_3_01true_00_01_t_01_4.html">conditional_cast_functor&lt; true, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1tracking__allocator.html">tracking_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__assign__to.html">has_assign_to</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__assign__to_3_01_e1_00_01_e2_00_01void__t_3_01decltype_07std_1_1declval_3_01cons059ed553ffd14856020f06c40d9ce771.html">has_assign_to&lt; E1, E2, void_t&lt; decltype(std::declval&lt; const E2 &amp; &gt;().assign_to(std::declval&lt; E1 &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rebind__container_3_01_x_00_01_c_3_01_t_00_01_a_01_4_01_4.html">rebind_container&lt; X, C&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1rebind__container_3_01_x_00_01_c_3_01_t_00_01_n_01_4_01_4.html">rebind_container&lt; X, C&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__strides__type.html">get_strides_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__strides__type_3_01fixed__shape_3_01_i_8_8_8_01_4_01_4.html">get_strides_type&lt; fixed_shape&lt; I... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1inner__reference.html">inner_reference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__rank.html">get_rank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1get__rank_3_01_e_00_01decltype_07_07void_08_01_e_1_1rank_00_01void_07_08_08_4.html">get_rank&lt; E, decltype((void) E::rank, void())&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__fixed__rank.html">has_fixed_rank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1has__rank.html">has_rank</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xvectorizer.html">xvectorizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxt_1_1xview__stepper.html">xview_stepper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xview__shape__type.html">xview_shape_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xcontainer__inner__types_3_01xview_3_01_c_t_00_01_s_8_8_8_01_4_01_4.html">xcontainer_inner_types&lt; xview&lt; CT, S... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xiterable__inner__types_3_01xview_3_01_c_t_00_01_s_8_8_8_01_4_01_4.html">xiterable_inner_types&lt; xview&lt; CT, S... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xview__shape__type_3_01std_1_1array_3_01_i_00_01_l_01_4_00_01_s_8_8_8_01_4.html">xview_shape_type&lt; std::array&lt; I, L &gt;, S... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1xview__shape__type_3_01fixed__shape_3_01_i_8_8_8_01_4_00_01_s_8_8_8_01_4.html">xview_shape_type&lt; fixed_shape&lt; I... &gt;, S... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxt_1_1view__temporary__type.html">view_temporary_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:accda9bd088d5ea1d6072e7e07dc371ad"><td class="memItemLeft" align="right" valign="top"><a id="accda9bd088d5ea1d6072e7e07dc371ad"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>smart_ownership</b> = <a class="el" href="structxt_1_1no__ownership.html">no_ownership</a></td></tr>
<tr class="separator:accda9bd088d5ea1d6072e7e07dc371ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d7c6a44b079e8b46df0f4e7bdaa4de"><td class="memTemplParams" colspan="2"><a id="ad2d7c6a44b079e8b46df0f4e7bdaa4de"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:ad2d7c6a44b079e8b46df0f4e7bdaa4de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>temporary_container_t</b> = typename <a class="el" href="structxt_1_1temporary__container.html">temporary_container</a>&lt; C &gt;::type</td></tr>
<tr class="separator:ad2d7c6a44b079e8b46df0f4e7bdaa4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5397c0e6dcec70f315e57d9be99352f"><td class="memTemplParams" colspan="2"><a id="aa5397c0e6dcec70f315e57d9be99352f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa5397c0e6dcec70f315e57d9be99352f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocator_type_t</b> = typename detail::allocator_type_impl&lt; T &gt;::type</td></tr>
<tr class="separator:aa5397c0e6dcec70f315e57d9be99352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64855e21379681e10c720856bd78675a"><td class="memTemplParams" colspan="2"><a id="a64855e21379681e10c720856bd78675a"></a>
template&lt;class T , class A  = std::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a64855e21379681e10c720856bd78675a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xcsv_tensor</b> = <a class="el" href="classxt_1_1xtensor__container.html">xtensor_container</a>&lt; std::vector&lt; T, A &gt;, 2, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">layout_type::row_major</a> &gt;</td></tr>
<tr class="separator:a64855e21379681e10c720856bd78675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317ca91e4225f93a54bc1dd087c57a9b"><td class="memTemplParams" colspan="2"><a id="a317ca91e4225f93a54bc1dd087c57a9b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a317ca91e4225f93a54bc1dd087c57a9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xdynamic_slice</b> = xtl::variant&lt; T, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, T, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="classxt_1_1xrange.html">xrange</a>&lt; T &gt;, <a class="el" href="classxt_1_1xstepped__range.html">xstepped_range</a>&lt; T &gt;, <a class="el" href="classxt_1_1xkeep__slice.html">xkeep_slice</a>&lt; T &gt;, <a class="el" href="classxt_1_1xdrop__slice.html">xdrop_slice</a>&lt; T &gt;, <a class="el" href="structxt_1_1xall__tag.html">xall_tag</a>, <a class="el" href="structxt_1_1xellipsis__tag.html">xellipsis_tag</a>, <a class="el" href="structxt_1_1xnewaxis__tag.html">xnewaxis_tag</a> &gt;</td></tr>
<tr class="separator:a317ca91e4225f93a54bc1dd087c57a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ed9801102cc8bb66bd1122b07e254c"><td class="memItemLeft" align="right" valign="top"><a id="aa4ed9801102cc8bb66bd1122b07e254c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>xdynamic_slice_vector</b> = std::vector&lt; xdynamic_slice&lt; std::ptrdiff_t &gt; &gt;</td></tr>
<tr class="separator:aa4ed9801102cc8bb66bd1122b07e254c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5155cd9e51f26e85e50fc8a25134dc5"><td class="memTemplParams" colspan="2"><a id="ae5155cd9e51f26e85e50fc8a25134dc5"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:ae5155cd9e51f26e85e50fc8a25134dc5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xvalue_type</b> = detail::xvalue_type_impl&lt; E &gt;</td></tr>
<tr class="separator:ae5155cd9e51f26e85e50fc8a25134dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd12b9621d8c07a199adb6e0db6926f4"><td class="memTemplParams" colspan="2"><a id="acd12b9621d8c07a199adb6e0db6926f4"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:acd12b9621d8c07a199adb6e0db6926f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xvalue_type_t</b> = typename xvalue_type&lt; E &gt;::type</td></tr>
<tr class="separator:acd12b9621d8c07a199adb6e0db6926f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e8fac98c4379d1410d652801b4292c"><td class="memTemplParams" colspan="2"><a id="ae8e8fac98c4379d1410d652801b4292c"></a>
template&lt;class... C&gt; </td></tr>
<tr class="memitem:ae8e8fac98c4379d1410d652801b4292c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>common_value_type_t</b> = typename <a class="el" href="structxt_1_1common__value__type.html">common_value_type</a>&lt; C... &gt;::type</td></tr>
<tr class="separator:ae8e8fac98c4379d1410d652801b4292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa955c92a7894b77dcf5ff88642eb76a7"><td class="memTemplParams" colspan="2"><a id="aa955c92a7894b77dcf5ff88642eb76a7"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aa955c92a7894b77dcf5ff88642eb76a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>common_size_type_t</b> = typename <a class="el" href="structxt_1_1common__size__type.html">common_size_type</a>&lt; Args... &gt;::type</td></tr>
<tr class="separator:aa955c92a7894b77dcf5ff88642eb76a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b791424ddc6784280055e4887ec702"><td class="memTemplParams" colspan="2"><a id="ab6b791424ddc6784280055e4887ec702"></a>
template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab6b791424ddc6784280055e4887ec702"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>common_difference_type_t</b> = typename <a class="el" href="structxt_1_1common__difference__type.html">common_difference_type</a>&lt; Args... &gt;::type</td></tr>
<tr class="separator:ab6b791424ddc6784280055e4887ec702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5165875248a5233ee943273bdab3675"><td class="memTemplParams" colspan="2"><a id="aa5165875248a5233ee943273bdab3675"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa5165875248a5233ee943273bdab3675"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>temporary_type_t</b> = typename <a class="el" href="structxt_1_1temporary__type.html">temporary_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:aa5165875248a5233ee943273bdab3675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fbea09a0c785a7db0e734673508e59"><td class="memTemplParams" colspan="2"><a id="a77fbea09a0c785a7db0e734673508e59"></a>
template&lt;class... C&gt; </td></tr>
<tr class="memitem:a77fbea09a0c785a7db0e734673508e59"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>common_tensor_type_t</b> = typename <a class="el" href="structxt_1_1common__tensor__type.html">common_tensor_type</a>&lt; C... &gt;::type</td></tr>
<tr class="separator:a77fbea09a0c785a7db0e734673508e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f44c0fc505ac77990bca51ba3dd5f8"><td class="memTemplParams" colspan="2"><a id="ac6f44c0fc505ac77990bca51ba3dd5f8"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:ac6f44c0fc505ac77990bca51ba3dd5f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>big_promote_value_type_t</b> = typename <a class="el" href="structxt_1_1big__promote__value__type.html">big_promote_value_type</a>&lt; E &gt;::type</td></tr>
<tr class="separator:ac6f44c0fc505ac77990bca51ba3dd5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b8fbf9e54aecfebcb8d95f22f38a79"><td class="memTemplParams" colspan="2"><a id="a20b8fbf9e54aecfebcb8d95f22f38a79"></a>
template&lt;class V , class S &gt; </td></tr>
<tr class="memitem:a20b8fbf9e54aecfebcb8d95f22f38a79"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_init_type_t</b> = typename <a class="el" href="structxt_1_1get__init__type.html">get_init_type</a>&lt; V, S &gt;::type</td></tr>
<tr class="separator:a20b8fbf9e54aecfebcb8d95f22f38a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c20400ae08b69e33d31d0dd0a29faf"><td class="memTemplParams" colspan="2"><a id="a88c20400ae08b69e33d31d0dd0a29faf"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a88c20400ae08b69e33d31d0dd0a29faf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_stepper_iterator</b> = typename detail::get_stepper_iterator_impl&lt; C &gt;::type</td></tr>
<tr class="separator:a88c20400ae08b69e33d31d0dd0a29faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4569809fd673f3ecb079f16d4a0b00"><td class="memTemplParams" colspan="2"><a id="a4d4569809fd673f3ecb079f16d4a0b00"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a4d4569809fd673f3ecb079f16d4a0b00"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xindex_type_t</b> = typename detail::index_type_impl&lt; C &gt;::type</td></tr>
<tr class="separator:a4d4569809fd673f3ecb079f16d4a0b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd33bb76b5201ef112615b3eedc9a1f"><td class="memTemplParams" colspan="2"><a id="a7bd33bb76b5201ef112615b3eedc9a1f"></a>
template&lt;class T , class R  = T&gt; </td></tr>
<tr class="memitem:a7bd33bb76b5201ef112615b3eedc9a1f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_indexed_stepper_t</b> = typename <a class="el" href="structxt_1_1enable__indexed__stepper.html">enable_indexed_stepper</a>&lt; T, R &gt;::type</td></tr>
<tr class="separator:a7bd33bb76b5201ef112615b3eedc9a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c50a7cb170e722eebbd9c37aacb459c"><td class="memTemplParams" colspan="2"><a id="a1c50a7cb170e722eebbd9c37aacb459c"></a>
template&lt;class T , class R  = T&gt; </td></tr>
<tr class="memitem:a1c50a7cb170e722eebbd9c37aacb459c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_indexed_stepper_t</b> = typename <a class="el" href="structxt_1_1disable__indexed__stepper.html">disable_indexed_stepper</a>&lt; T, R &gt;::type</td></tr>
<tr class="separator:a1c50a7cb170e722eebbd9c37aacb459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed30dc278eedd175bd6b1b4c86327f47"><td class="memTemplParams" colspan="2"><a id="aed30dc278eedd175bd6b1b4c86327f47"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aed30dc278eedd175bd6b1b4c86327f47"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aed30dc278eedd175bd6b1b4c86327f47">norm_type_t</a> = typename <a class="el" href="structxt_1_1norm__type.html">norm_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:aed30dc278eedd175bd6b1b4c86327f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation of 'typename norm_type&lt;T&gt;::type'. <br /></td></tr>
<tr class="separator:aed30dc278eedd175bd6b1b4c86327f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4d0a4c530e5cca24206775b38a96fb"><td class="memTemplParams" colspan="2"><a id="aad4d0a4c530e5cca24206775b38a96fb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aad4d0a4c530e5cca24206775b38a96fb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aad4d0a4c530e5cca24206775b38a96fb">squared_norm_type_t</a> = typename <a class="el" href="structxt_1_1squared__norm__type.html">squared_norm_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:aad4d0a4c530e5cca24206775b38a96fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abbreviation of 'typename squared_norm_type&lt;T&gt;::type'. <br /></td></tr>
<tr class="separator:aad4d0a4c530e5cca24206775b38a96fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621c7a123936caac48bac1270205261a"><td class="memTemplParams" colspan="2"><a id="a621c7a123936caac48bac1270205261a"></a>
template&lt;class CT , class M , std::size_t I&gt; </td></tr>
<tr class="memitem:a621c7a123936caac48bac1270205261a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xoffset_view</b> = <a class="el" href="classxt_1_1xfunctor__view.html">xfunctor_view</a>&lt; detail::offset_forwarder&lt; M, I &gt;, CT &gt;</td></tr>
<tr class="separator:a621c7a123936caac48bac1270205261a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fd9fea57e84b0fd8101974f13a3124"><td class="memTemplParams" colspan="2"><a id="ab6fd9fea57e84b0fd8101974f13a3124"></a>
template&lt;class CT , class M , std::size_t I&gt; </td></tr>
<tr class="memitem:ab6fd9fea57e84b0fd8101974f13a3124"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xoffset_adaptor</b> = <a class="el" href="classxt_1_1xfunctor__adaptor.html">xfunctor_adaptor</a>&lt; detail::offset_forwarder&lt; M, I &gt;, CT &gt;</td></tr>
<tr class="separator:ab6fd9fea57e84b0fd8101974f13a3124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21ad7a784ed57dac7772194e8157cb1"><td class="memTemplParams" colspan="2"><a id="af21ad7a784ed57dac7772194e8157cb1"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:af21ad7a784ed57dac7772194e8157cb1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_xscalar</b> = detail::is_xscalar_impl&lt; E &gt;</td></tr>
<tr class="separator:af21ad7a784ed57dac7772194e8157cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218c27d7ab04905c3c0fba690d37f790"><td class="memTemplParams" colspan="2"><a id="a218c27d7ab04905c3c0fba690d37f790"></a>
template&lt;class... E&gt; </td></tr>
<tr class="memitem:a218c27d7ab04905c3c0fba690d37f790"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>all_xscalar</b> = detail::all_xscalar&lt; E... &gt;</td></tr>
<tr class="separator:a218c27d7ab04905c3c0fba690d37f790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c7705600a9a4da80f4521c1fd5c6b0"><td class="memTemplParams" colspan="2"><a id="a90c7705600a9a4da80f4521c1fd5c6b0"></a>
template&lt;class D &gt; </td></tr>
<tr class="memitem:a90c7705600a9a4da80f4521c1fd5c6b0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>select_expression_base_t</b> = std::conditional_t&lt; detail::is_sharable&lt; D &gt;::value, <a class="el" href="classxt_1_1xsharable__expression.html">xsharable_expression</a>&lt; D &gt;, <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; D &gt; &gt;</td></tr>
<tr class="separator:a90c7705600a9a4da80f4521c1fd5c6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7657e29fd5268f4c924e8cd0e1c23a70"><td class="memTemplParams" colspan="2"><a id="a7657e29fd5268f4c924e8cd0e1c23a70"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a7657e29fd5268f4c924e8cd0e1c23a70"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_assignable</b> = is_crtp_base_of&lt; <a class="el" href="classxt_1_1xsemantic__base.html">xsemantic_base</a>, E &gt;</td></tr>
<tr class="separator:a7657e29fd5268f4c924e8cd0e1c23a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c189075ee1c724795c6bc703c013765"><td class="memTemplParams" colspan="2"><a id="a4c189075ee1c724795c6bc703c013765"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:a4c189075ee1c724795c6bc703c013765"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_assignable</b> = typename std::enable_if&lt; is_assignable&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a4c189075ee1c724795c6bc703c013765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f66b790b1a63b28e49faeab3f19823"><td class="memTemplParams" colspan="2"><a id="ac9f66b790b1a63b28e49faeab3f19823"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:ac9f66b790b1a63b28e49faeab3f19823"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_assignable</b> = typename std::enable_if&lt;!is_assignable&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:ac9f66b790b1a63b28e49faeab3f19823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8fba8392ea2f57846f7301f0793a1d"><td class="memTemplParams" colspan="2"><a id="a7e8fba8392ea2f57846f7301f0793a1d"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a7e8fba8392ea2f57846f7301f0793a1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_container_semantics</b> = is_crtp_base_of&lt; <a class="el" href="classxt_1_1xcontainer__semantic.html">xcontainer_semantic</a>, E &gt;</td></tr>
<tr class="separator:a7e8fba8392ea2f57846f7301f0793a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1183d17772a29f3f08064dbb09c745"><td class="memTemplParams" colspan="2"><a id="a1b1183d17772a29f3f08064dbb09c745"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:a1b1183d17772a29f3f08064dbb09c745"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_xcontainer_semantics</b> = typename std::enable_if&lt; has_container_semantics&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a1b1183d17772a29f3f08064dbb09c745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce03cb671328fa3788f060c3b5dc469"><td class="memTemplParams" colspan="2"><a id="a9ce03cb671328fa3788f060c3b5dc469"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:a9ce03cb671328fa3788f060c3b5dc469"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_xcontainer_semantics</b> = typename std::enable_if&lt;!has_container_semantics&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a9ce03cb671328fa3788f060c3b5dc469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6d125e5a735f0ec422ba40e7ddb856"><td class="memTemplParams" colspan="2"><a id="a0d6d125e5a735f0ec422ba40e7ddb856"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a0d6d125e5a735f0ec422ba40e7ddb856"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_view_semantics</b> = is_crtp_base_of&lt; <a class="el" href="classxt_1_1xview__semantic.html">xview_semantic</a>, E &gt;</td></tr>
<tr class="separator:a0d6d125e5a735f0ec422ba40e7ddb856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a97613bc6d4cb3c578ad0fdd17c848"><td class="memTemplParams" colspan="2"><a id="a52a97613bc6d4cb3c578ad0fdd17c848"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:a52a97613bc6d4cb3c578ad0fdd17c848"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_xview_semantics</b> = typename std::enable_if&lt; has_view_semantics&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a52a97613bc6d4cb3c578ad0fdd17c848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ca3d78f9bf57ae64c9e154dbcf0558"><td class="memTemplParams" colspan="2"><a id="a44ca3d78f9bf57ae64c9e154dbcf0558"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:a44ca3d78f9bf57ae64c9e154dbcf0558"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_xview_semantics</b> = typename std::enable_if&lt;!has_view_semantics&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a44ca3d78f9bf57ae64c9e154dbcf0558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681f33854d83d978e3cca325c58beb83"><td class="memTemplParams" colspan="2"><a id="a681f33854d83d978e3cca325c58beb83"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a681f33854d83d978e3cca325c58beb83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_shape</b> = <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, 4 &gt;</td></tr>
<tr class="separator:a681f33854d83d978e3cca325c58beb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ec3a90781d81abe650207bfa522b6"><td class="memTemplParams" colspan="2"><a id="af48ec3a90781d81abe650207bfa522b6"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:af48ec3a90781d81abe650207bfa522b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>static_shape</b> = std::array&lt; T, N &gt;</td></tr>
<tr class="separator:af48ec3a90781d81abe650207bfa522b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7201bd54bcaac6d25b87e0bb88eb32"><td class="memItemLeft" align="right" valign="top"><a id="ade7201bd54bcaac6d25b87e0bb88eb32"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>xindex</b> = <a class="el" href="classxt_1_1svector.html">dynamic_shape</a>&lt; std::size_t &gt;</td></tr>
<tr class="separator:ade7201bd54bcaac6d25b87e0bb88eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480cac83168add59659604b161abec5f"><td class="memTemplParams" colspan="2"><a id="a480cac83168add59659604b161abec5f"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:a480cac83168add59659604b161abec5f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>promote_shape_t</b> = typename <a class="el" href="structxt_1_1promote__shape.html">promote_shape</a>&lt; S... &gt;::type</td></tr>
<tr class="separator:a480cac83168add59659604b161abec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1695c52596ab43eedc7f32bf8273bf1"><td class="memTemplParams" colspan="2"><a id="ad1695c52596ab43eedc7f32bf8273bf1"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:ad1695c52596ab43eedc7f32bf8273bf1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>promote_strides_t</b> = typename <a class="el" href="structxt_1_1promote__strides.html">promote_strides</a>&lt; S... &gt;::type</td></tr>
<tr class="separator:ad1695c52596ab43eedc7f32bf8273bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025552f5d088c39b1df309922f50b4b6"><td class="memTemplParams" colspan="2"><a id="a025552f5d088c39b1df309922f50b4b6"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a025552f5d088c39b1df309922f50b4b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>index_from_shape_t</b> = typename <a class="el" href="structxt_1_1index__from__shape.html">index_from_shape</a>&lt; S &gt;::type</td></tr>
<tr class="separator:a025552f5d088c39b1df309922f50b4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f3cb2c9161f34c2e3a823d6d1ee357"><td class="memTemplParams" colspan="2"><a id="a51f3cb2c9161f34c2e3a823d6d1ee357"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a51f3cb2c9161f34c2e3a823d6d1ee357"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>filter_fixed_shape_t</b> = typename <a class="el" href="structxt_1_1filter__fixed__shape.html">filter_fixed_shape</a>&lt; S &gt;::type</td></tr>
<tr class="separator:a51f3cb2c9161f34c2e3a823d6d1ee357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fbb89a9a65e70d8fec90cb2e5d73e2"><td class="memTemplParams" colspan="2"><a id="a27fbb89a9a65e70d8fec90cb2e5d73e2"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a27fbb89a9a65e70d8fec90cb2e5d73e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_xslice</b> = std::is_base_of&lt; <a class="el" href="classxt_1_1xslice.html">xslice</a>&lt; S &gt;, S &gt;</td></tr>
<tr class="separator:a27fbb89a9a65e70d8fec90cb2e5d73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5d47325ac2146057a81bfe7b448699"><td class="memTemplParams" colspan="2"><a id="aea5d47325ac2146057a81bfe7b448699"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:aea5d47325ac2146057a81bfe7b448699"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_xslice</b> = typename std::enable_if&lt;!is_xslice&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:aea5d47325ac2146057a81bfe7b448699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571a9f5e3c5792abb434da309e6f5a1b"><td class="memTemplParams" colspan="2"><a id="a571a9f5e3c5792abb434da309e6f5a1b"></a>
template&lt;class... E&gt; </td></tr>
<tr class="memitem:a571a9f5e3c5792abb434da309e6f5a1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_xslice</b> = xtl::disjunction&lt; is_xslice&lt; E &gt;... &gt;</td></tr>
<tr class="separator:a571a9f5e3c5792abb434da309e6f5a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0977fb599267a2a3ce399789021a7bf0"><td class="memTemplParams" colspan="2"><a id="a0977fb599267a2a3ce399789021a7bf0"></a>
template&lt;class E , class SL &gt; </td></tr>
<tr class="memitem:a0977fb599267a2a3ce399789021a7bf0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_slice_type</b> = typename detail::get_slice_type_impl&lt; E, std::remove_reference_t&lt; SL &gt; &gt;::type</td></tr>
<tr class="separator:a0977fb599267a2a3ce399789021a7bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95da08e7cc3d25307cf29b3a676a0194"><td class="memTemplParams" colspan="2"><a id="a95da08e7cc3d25307cf29b3a676a0194"></a>
template&lt;layout_type L1, layout_type L2, class T &gt; </td></tr>
<tr class="memitem:a95da08e7cc3d25307cf29b3a676a0194"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>select_iterable_base_t</b> = typename <a class="el" href="structxt_1_1select__iterable__base.html">select_iterable_base</a>&lt; L1, L2, T &gt;::type</td></tr>
<tr class="separator:a95da08e7cc3d25307cf29b3a676a0194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc547b0d919d2bb71c5ea5dc9716f65"><td class="memTemplParams" colspan="2"><a id="a5cc547b0d919d2bb71c5ea5dc9716f65"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5cc547b0d919d2bb71c5ea5dc9716f65"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xstrided_slice</b> = xtl::variant&lt; T, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; T, T, T &gt;, <a class="el" href="structxt_1_1xrange__adaptor.html">xrange_adaptor</a>&lt; <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> &gt;, <a class="el" href="classxt_1_1xrange.html">xrange</a>&lt; T &gt;, <a class="el" href="classxt_1_1xstepped__range.html">xstepped_range</a>&lt; T &gt;, <a class="el" href="structxt_1_1xall__tag.html">xall_tag</a>, <a class="el" href="structxt_1_1xellipsis__tag.html">xellipsis_tag</a>, <a class="el" href="structxt_1_1xnewaxis__tag.html">xnewaxis_tag</a> &gt;</td></tr>
<tr class="separator:a5cc547b0d919d2bb71c5ea5dc9716f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e111c2e160e2edb6a2139d16c66d65a"><td class="memItemLeft" align="right" valign="top"><a id="a6e111c2e160e2edb6a2139d16c66d65a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#a6e111c2e160e2edb6a2139d16c66d65a">xstrided_slice_vector</a> = std::vector&lt; xstrided_slice&lt; std::ptrdiff_t &gt; &gt;</td></tr>
<tr class="memdesc:a6e111c2e160e2edb6a2139d16c66d65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of slices used to build a <code><a class="el" href="classxt_1_1xstrided__view.html" title="View of an xexpression using strides.">xstrided_view</a></code> <br /></td></tr>
<tr class="separator:a6e111c2e160e2edb6a2139d16c66d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ed1046ec70cca4784f7eb14ad7c7e0"><td class="memTemplParams" colspan="2">template&lt;class T , layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;, class SA  = std::allocator&lt;typename std::vector&lt;T, A&gt;::size_type&gt;&gt; </td></tr>
<tr class="memitem:a26ed1046ec70cca4784f7eb14ad7c7e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a> = <a class="el" href="classxt_1_1xarray__container.html">xarray_container</a>&lt; <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt;, L, <a class="el" href="classxt_1_1svector.html">xt::svector</a>&lt; typename <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt;::size_type, 4, SA, true &gt; &gt;</td></tr>
<tr class="memdesc:a26ed1046ec70cca4784f7eb14ad7c7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template on <a class="el" href="classxt_1_1xarray__container.html" title="Dense multidimensional container with tensor semantic.">xarray_container</a> with default parameters for data container type and shape / strides container type.  <a href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">More...</a><br /></td></tr>
<tr class="separator:a26ed1046ec70cca4784f7eb14ad7c7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a43cfb1b205ffea56a580218ff20455"><td class="memTemplParams" colspan="2">template&lt;class T , layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;, class BC  = xtl::xdynamic_bitset&lt;std::size_t&gt;, class SA  = std::allocator&lt;typename std::vector&lt;T, A&gt;::size_type&gt;&gt; </td></tr>
<tr class="memitem:a2a43cfb1b205ffea56a580218ff20455"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2a43cfb1b205ffea56a580218ff20455">xarray_optional</a> = <a class="el" href="classxt_1_1xarray__container.html">xarray_container</a>&lt; xtl::xoptional_vector&lt; T, A, BC &gt;, L, <a class="el" href="classxt_1_1svector.html">xt::svector</a>&lt; typename <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt;::size_type, 4, SA, true &gt;, <a class="el" href="structxt_1_1xoptional__expression__tag.html">xoptional_expression_tag</a> &gt;</td></tr>
<tr class="memdesc:a2a43cfb1b205ffea56a580218ff20455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template on <a class="el" href="classxt_1_1xarray__container.html" title="Dense multidimensional container with tensor semantic.">xarray_container</a> for handling missing values.  <a href="namespacext.html#a2a43cfb1b205ffea56a580218ff20455">More...</a><br /></td></tr>
<tr class="separator:a2a43cfb1b205ffea56a580218ff20455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d0a2d76c0f69cf43aa3b4f55a7a26d"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N, layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;&gt; </td></tr>
<tr class="memitem:a29d0a2d76c0f69cf43aa3b4f55a7a26d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xtensor</a> = <a class="el" href="classxt_1_1xtensor__container.html">xtensor_container</a>&lt; <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt;, N, L &gt;</td></tr>
<tr class="memdesc:a29d0a2d76c0f69cf43aa3b4f55a7a26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template on <a class="el" href="classxt_1_1xtensor__container.html" title="Dense multidimensional container with tensor semantic and fixed dimension.">xtensor_container</a> with default parameters for data container type.  <a href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">More...</a><br /></td></tr>
<tr class="separator:a29d0a2d76c0f69cf43aa3b4f55a7a26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b500aab287ebecb4ad1520d2c0972f"><td class="memTemplParams" colspan="2"><a id="a02b500aab287ebecb4ad1520d2c0972f"></a>
template&lt;std::size_t... N&gt; </td></tr>
<tr class="memitem:a02b500aab287ebecb4ad1520d2c0972f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a02b500aab287ebecb4ad1520d2c0972f">xshape</a> = <a class="el" href="classxt_1_1fixed__shape.html">fixed_shape</a>&lt; N... &gt;</td></tr>
<tr class="memdesc:a02b500aab287ebecb4ad1520d2c0972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template for <code><a class="el" href="classxt_1_1fixed__shape.html" title="Fixed shape implementation for compile time defined arrays.">fixed_shape</a></code> allows for a shorter template shape definition in <code>xtensor_fixed</code>. <br /></td></tr>
<tr class="separator:a02b500aab287ebecb4ad1520d2c0972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d9917ae5dc2260d2889b7120b69d59"><td class="memTemplParams" colspan="2">template&lt;class T , class FSH , layout_type L = ::xt::layout_type::row_major, bool Sharable = true&gt; </td></tr>
<tr class="memitem:a85d9917ae5dc2260d2889b7120b69d59"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a85d9917ae5dc2260d2889b7120b69d59">xtensor_fixed</a> = <a class="el" href="classxt_1_1xfixed__container.html">xfixed_container</a>&lt; T, FSH, L, Sharable &gt;</td></tr>
<tr class="memdesc:a85d9917ae5dc2260d2889b7120b69d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template on <a class="el" href="classxt_1_1xfixed__container.html" title="Dense multidimensional container with tensor semantic and fixed dimension.">xfixed_container</a> with default parameters for layout type.  <a href="namespacext.html#a85d9917ae5dc2260d2889b7120b69d59">More...</a><br /></td></tr>
<tr class="separator:a85d9917ae5dc2260d2889b7120b69d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125645152bc5adb33f0fa248e24a9868"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N, layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;, class BC  = xtl::xdynamic_bitset&lt;std::size_t&gt;&gt; </td></tr>
<tr class="memitem:a125645152bc5adb33f0fa248e24a9868"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a125645152bc5adb33f0fa248e24a9868">xtensor_optional</a> = <a class="el" href="classxt_1_1xtensor__container.html">xtensor_container</a>&lt; xtl::xoptional_vector&lt; T, A, BC &gt;, N, L, <a class="el" href="structxt_1_1xoptional__expression__tag.html">xoptional_expression_tag</a> &gt;</td></tr>
<tr class="memdesc:a125645152bc5adb33f0fa248e24a9868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias template on <a class="el" href="classxt_1_1xtensor__container.html" title="Dense multidimensional container with tensor semantic and fixed dimension.">xtensor_container</a> for handling missing values.  <a href="namespacext.html#a125645152bc5adb33f0fa248e24a9868">More...</a><br /></td></tr>
<tr class="separator:a125645152bc5adb33f0fa248e24a9868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03e9779a6c57128fcdd808678958d9b"><td class="memTemplParams" colspan="2"><a id="ac03e9779a6c57128fcdd808678958d9b"></a>
template&lt;class A1 , class A2 &gt; </td></tr>
<tr class="memitem:ac03e9779a6c57128fcdd808678958d9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>driven_align_mode_t</b> = typename detail::driven_align_mode_impl&lt; A1, A2 &gt;::type</td></tr>
<tr class="separator:ac03e9779a6c57128fcdd808678958d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83e4a96aa4eca83fbedd0d70cc12e6e"><td class="memTemplParams" colspan="2"><a id="ad83e4a96aa4eca83fbedd0d70cc12e6e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad83e4a96aa4eca83fbedd0d70cc12e6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bool_load_type</b> = std::conditional_t&lt; std::is_same&lt; T, bool &gt;::value, uint8_t, T &gt;</td></tr>
<tr class="separator:ad83e4a96aa4eca83fbedd0d70cc12e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96f10c8125de80e1104d854908145cb"><td class="memTemplParams" colspan="2"><a id="ae96f10c8125de80e1104d854908145cb"></a>
template&lt;class C , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:ae96f10c8125de80e1104d854908145cb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>container_simd_return_type_t</b> = typename <a class="el" href="structxt_1_1container__simd__return__type.html">container_simd_return_type</a>&lt; C, T1, T2 &gt;::type</td></tr>
<tr class="separator:ae96f10c8125de80e1104d854908145cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80674eba1d419e3eaa009fc677fb9129"><td class="memTemplParams" colspan="2"><a id="a80674eba1d419e3eaa009fc677fb9129"></a>
template&lt;class X , class C &gt; </td></tr>
<tr class="memitem:a80674eba1d419e3eaa009fc677fb9129"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rebind_container_t</b> = typename <a class="el" href="structxt_1_1rebind__container.html">rebind_container</a>&lt; X, C &gt;::type</td></tr>
<tr class="separator:a80674eba1d419e3eaa009fc677fb9129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a29e2163b761a1c05d01f6fc1d79289"><td class="memTemplParams" colspan="2"><a id="a5a29e2163b761a1c05d01f6fc1d79289"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a5a29e2163b761a1c05d01f6fc1d79289"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>void_t</b> = typename <a class="el" href="structxt_1_1make__void.html">make_void</a>&lt; T... &gt;::type</td></tr>
<tr class="separator:a5a29e2163b761a1c05d01f6fc1d79289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc2c098e07151df439d72b22c07eb63"><td class="memTemplParams" colspan="2"><a id="abcc2c098e07151df439d72b22c07eb63"></a>
template&lt;class T , class R &gt; </td></tr>
<tr class="memitem:abcc2c098e07151df439d72b22c07eb63"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_integral_t</b> = std::enable_if_t&lt;!xtl::is_integral&lt; T &gt;::value, R &gt;</td></tr>
<tr class="separator:abcc2c098e07151df439d72b22c07eb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59bb710db801e0bd7ec57578b092bcd"><td class="memTemplParams" colspan="2"><a id="ae59bb710db801e0bd7ec57578b092bcd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae59bb710db801e0bd7ec57578b092bcd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>remove_class_t</b> = typename <a class="el" href="structxt_1_1remove__class.html">remove_class</a>&lt; T &gt;::type</td></tr>
<tr class="separator:ae59bb710db801e0bd7ec57578b092bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb41835c0ce9e16e304980cb6f85df1b"><td class="memTemplParams" colspan="2"><a id="abb41835c0ce9e16e304980cb6f85df1b"></a>
template&lt;class T , std::size_t I&gt; </td></tr>
<tr class="memitem:abb41835c0ce9e16e304980cb6f85df1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nested_initializer_list_t</b> = typename <a class="el" href="structxt_1_1nested__initializer__list.html">nested_initializer_list</a>&lt; T, I &gt;::type</td></tr>
<tr class="separator:abb41835c0ce9e16e304980cb6f85df1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95462800e5fa5e885355ad6f015e1323"><td class="memTemplParams" colspan="2"><a id="a95462800e5fa5e885355ad6f015e1323"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a95462800e5fa5e885355ad6f015e1323"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_value_type_t</b> = typename <a class="el" href="structxt_1_1get__value__type.html">get_value_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a95462800e5fa5e885355ad6f015e1323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16490806eb9b3ece6b11ca26f878b884"><td class="memTemplParams" colspan="2"><a id="a16490806eb9b3ece6b11ca26f878b884"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a16490806eb9b3ece6b11ca26f878b884"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_cv_t</b> = typename <a class="el" href="structxt_1_1apply__cv.html">apply_cv</a>&lt; T, U &gt;::type</td></tr>
<tr class="separator:a16490806eb9b3ece6b11ca26f878b884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab82349007cd0a80e4c64f21d87abc"><td class="memTemplParams" colspan="2"><a id="ae5ab82349007cd0a80e4c64f21d87abc"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae5ab82349007cd0a80e4c64f21d87abc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xtrivially_default_constructible</b> = std::is_trivially_default_constructible&lt; T &gt;</td></tr>
<tr class="separator:ae5ab82349007cd0a80e4c64f21d87abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fab0f9b847509f2c0d14c061bf94408"><td class="memTemplParams" colspan="2"><a id="a3fab0f9b847509f2c0d14c061bf94408"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a3fab0f9b847509f2c0d14c061bf94408"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_strides_t</b> = typename <a class="el" href="structxt_1_1get__strides__type.html">get_strides_type</a>&lt; C &gt;::type</td></tr>
<tr class="separator:a3fab0f9b847509f2c0d14c061bf94408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1006e06af5c61f388b1011c456aae47e"><td class="memTemplParams" colspan="2"><a id="a1006e06af5c61f388b1011c456aae47e"></a>
template&lt;class ST &gt; </td></tr>
<tr class="memitem:a1006e06af5c61f388b1011c456aae47e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inner_reference_t</b> = typename <a class="el" href="structxt_1_1inner__reference.html">inner_reference</a>&lt; ST &gt;::type</td></tr>
<tr class="separator:a1006e06af5c61f388b1011c456aae47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad647a5b515754d8cfad878325d7d2baa"><td class="memTemplParams" colspan="2"><a id="ad647a5b515754d8cfad878325d7d2baa"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:ad647a5b515754d8cfad878325d7d2baa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_fixed_rank_t</b> = typename <a class="el" href="structxt_1_1has__fixed__rank.html">has_fixed_rank</a>&lt; std::decay_t&lt; E &gt; &gt;::type</td></tr>
<tr class="separator:ad647a5b515754d8cfad878325d7d2baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd81714083ffccbf999464dfdf6532f4"><td class="memTemplParams" colspan="2"><a id="acd81714083ffccbf999464dfdf6532f4"></a>
template&lt;class E , size_t N&gt; </td></tr>
<tr class="memitem:acd81714083ffccbf999464dfdf6532f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_rank_t</b> = typename <a class="el" href="structxt_1_1has__rank.html">has_rank</a>&lt; std::decay_t&lt; E &gt;, N &gt;::type</td></tr>
<tr class="separator:acd81714083ffccbf999464dfdf6532f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c02dd557e10a8eace3e4d04f43d0e51"><td class="memTemplParams" colspan="2"><a id="a8c02dd557e10a8eace3e4d04f43d0e51"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a8c02dd557e10a8eace3e4d04f43d0e51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_stepper</b> = typename detail::get_stepper_impl&lt; V &gt;::type</td></tr>
<tr class="separator:a8c02dd557e10a8eace3e4d04f43d0e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9a625c2ea14202b455f0f847dc8ae7"><td class="memTemplParams" colspan="2"><a id="adf9a625c2ea14202b455f0f847dc8ae7"></a>
template&lt;class E , class... SL&gt; </td></tr>
<tr class="memitem:adf9a625c2ea14202b455f0f847dc8ae7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>view_temporary_type_t</b> = typename <a class="el" href="structxt_1_1view__temporary__type.html">view_temporary_type</a>&lt; E, SL... &gt;::type</td></tr>
<tr class="separator:adf9a625c2ea14202b455f0f847dc8ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aaa63c71a8935d44bbec1aa9af4cb61b8"><td class="memItemLeft" align="right" valign="top"><a id="aaa63c71a8935d44bbec1aa9af4cb61b8"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a> { <b>automatic</b>
, <b>linspace</b>
, <b>logspace</b>
, <b>uniform</b>
 }</td></tr>
<tr class="memdesc:aaa63c71a8935d44bbec1aa9af4cb61b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines different algorithms to be used in "histogram_bin_edges". <br /></td></tr>
<tr class="separator:aaa63c71a8935d44bbec1aa9af4cb61b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ee24a1069c6e670d687af9e6aa4ba6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> { <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6ab72f3bd391ba731a35708bfd8cd8a68f">dynamic</a> = 0x00
, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a100b8cad7cf2a56f6df78f171f97a1ec">any</a> = 0xFF
, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">row_major</a> = 0x01
, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a8c23f260f0ec1479d3bfaf3a1305a347">column_major</a> = 0x02
 }</td></tr>
<tr class="separator:a54ee24a1069c6e670d687af9e6aa4ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d095239ac8c959a5d0a5b7086b5ae7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">pad_mode</a> { <br />
&#160;&#160;<b>constant</b>
, <b>symmetric</b>
, <b>reflect</b>
, <b>wrap</b>
, <br />
&#160;&#160;<b>periodic</b>
<br />
 }</td></tr>
<tr class="memdesc:aa9d095239ac8c959a5d0a5b7086b5ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines different algorithms to be used in <code><a class="el" href="namespacext.html#a0006ff814bef7534b9fa5187b1863feb" title="Pad an array.">xt::pad</a></code>:  <a href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">More...</a><br /></td></tr>
<tr class="separator:aa9d095239ac8c959a5d0a5b7086b5ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:add4224b565cdfde4d60b6d811da84b03"><td class="memTemplParams" colspan="2"><a id="add4224b565cdfde4d60b6d811da84b03"></a>
template&lt;class RF &gt; </td></tr>
<tr class="memitem:add4224b565cdfde4d60b6d811da84b03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_xaccumulator_functor</b> (RF &amp;&amp;accumulate_func)</td></tr>
<tr class="separator:add4224b565cdfde4d60b6d811da84b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6e972134268628c3e2869c7c744a4c"><td class="memTemplParams" colspan="2"><a id="a3c6e972134268628c3e2869c7c744a4c"></a>
template&lt;class RF , class IF &gt; </td></tr>
<tr class="memitem:a3c6e972134268628c3e2869c7c744a4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_xaccumulator_functor</b> (RF &amp;&amp;accumulate_func, IF &amp;&amp;init_func)</td></tr>
<tr class="separator:a3c6e972134268628c3e2869c7c744a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bd621231562feb074486e7213ee86f"><td class="memTemplParams" colspan="2">template&lt;class F , class E , class EVS  = evaluation_strategy::immediate_type, xtl::check_concept&lt; is_evaluation_strategy&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a75bd621231562feb074486e7213ee86f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a75bd621231562feb074486e7213ee86f">accumulate</a> (F &amp;&amp;f, E &amp;&amp;e, EVS evaluation_strategy=EVS())</td></tr>
<tr class="memdesc:a75bd621231562feb074486e7213ee86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate and flatten array <b>NOTE</b> This function is not lazy!  <a href="namespacext.html#a75bd621231562feb074486e7213ee86f">More...</a><br /></td></tr>
<tr class="separator:a75bd621231562feb074486e7213ee86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89df2e50fff4b65f615aacfcdbb9ff74"><td class="memTemplParams" colspan="2">template&lt;class F , class E , class EVS  = evaluation_strategy::immediate_type&gt; </td></tr>
<tr class="memitem:a89df2e50fff4b65f615aacfcdbb9ff74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a89df2e50fff4b65f615aacfcdbb9ff74">accumulate</a> (F &amp;&amp;f, E &amp;&amp;e, std::ptrdiff_t axis, EVS evaluation_strategy=EVS())</td></tr>
<tr class="memdesc:a89df2e50fff4b65f615aacfcdbb9ff74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate over axis <b>NOTE</b> This function is not lazy!  <a href="namespacext.html#a89df2e50fff4b65f615aacfcdbb9ff74">More...</a><br /></td></tr>
<tr class="separator:a89df2e50fff4b65f615aacfcdbb9ff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bd332b601ba16e8e8e6725a3447d08"><td class="memTemplParams" colspan="2"><a id="ab8bd332b601ba16e8e8e6725a3447d08"></a>
template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ab8bd332b601ba16e8e8e6725a3447d08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign_data</b> (<a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;e1, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;e2, bool trivial)</td></tr>
<tr class="separator:ab8bd332b601ba16e8e8e6725a3447d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2856b5a4d5ca0ed7f0f26d313cd7b8a"><td class="memTemplParams" colspan="2"><a id="ab2856b5a4d5ca0ed7f0f26d313cd7b8a"></a>
template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ab2856b5a4d5ca0ed7f0f26d313cd7b8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assign_xexpression</b> (<a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;e1, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;e2)</td></tr>
<tr class="separator:ab2856b5a4d5ca0ed7f0f26d313cd7b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7704568857aa9c93fcff9faf35164486"><td class="memTemplParams" colspan="2"><a id="a7704568857aa9c93fcff9faf35164486"></a>
template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a7704568857aa9c93fcff9faf35164486"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computed_assign</b> (<a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;e1, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;e2)</td></tr>
<tr class="separator:a7704568857aa9c93fcff9faf35164486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a64515bb6345eceb6d83f3b6c2806f"><td class="memTemplParams" colspan="2"><a id="a26a64515bb6345eceb6d83f3b6c2806f"></a>
template&lt;class E1 , class E2 , class F &gt; </td></tr>
<tr class="memitem:a26a64515bb6345eceb6d83f3b6c2806f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>scalar_computed_assign</b> (<a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;e1, const E2 &amp;e2, F &amp;&amp;f)</td></tr>
<tr class="separator:a26a64515bb6345eceb6d83f3b6c2806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7afefd15b9559f4fa8c1ec7593f945"><td class="memTemplParams" colspan="2"><a id="adf7afefd15b9559f4fa8c1ec7593f945"></a>
template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:adf7afefd15b9559f4fa8c1ec7593f945"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_compatible_shape</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;e1, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;e2)</td></tr>
<tr class="separator:adf7afefd15b9559f4fa8c1ec7593f945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e22bef70928e2d30c85bc45ecede2ad"><td class="memTemplParams" colspan="2"><a id="a7e22bef70928e2d30c85bc45ecede2ad"></a>
template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a7e22bef70928e2d30c85bc45ecede2ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strided_assign</b> (E1 &amp;e1, const E2 &amp;e2, std::false_type)</td></tr>
<tr class="separator:a7e22bef70928e2d30c85bc45ecede2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1327bfc0c44d54fa94be757781981d"><td class="memTemplParams" colspan="2"><a id="a0a1327bfc0c44d54fa94be757781981d"></a>
template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a0a1327bfc0c44d54fa94be757781981d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strided_assign</b> (E1 &amp;e1, const E2 &amp;e2, std::true_type)</td></tr>
<tr class="separator:a0a1327bfc0c44d54fa94be757781981d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac466e2a446d4c8339426eec5ee22fc6"><td class="memTemplParams" colspan="2"><a id="aac466e2a446d4c8339426eec5ee22fc6"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:aac466e2a446d4c8339426eec5ee22fc6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xaxis_slice_begin</b> (E &amp;&amp;e)</td></tr>
<tr class="separator:aac466e2a446d4c8339426eec5ee22fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af129f947fad479465695a1f5639166f5"><td class="memTemplParams" colspan="2"><a id="af129f947fad479465695a1f5639166f5"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:af129f947fad479465695a1f5639166f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xaxis_slice_begin</b> (E &amp;&amp;e, typename std::decay_t&lt; E &gt;::size_type axis)</td></tr>
<tr class="separator:af129f947fad479465695a1f5639166f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1be3afbc0923f850c66c52ea8368f7e"><td class="memTemplParams" colspan="2"><a id="af1be3afbc0923f850c66c52ea8368f7e"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:af1be3afbc0923f850c66c52ea8368f7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xaxis_slice_end</b> (E &amp;&amp;e)</td></tr>
<tr class="separator:af1be3afbc0923f850c66c52ea8368f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc03dcdaa6a208161996fe8f08a05aca"><td class="memTemplParams" colspan="2"><a id="afc03dcdaa6a208161996fe8f08a05aca"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:afc03dcdaa6a208161996fe8f08a05aca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xaxis_slice_end</b> (E &amp;&amp;e, typename std::decay_t&lt; E &gt;::size_type axis)</td></tr>
<tr class="separator:afc03dcdaa6a208161996fe8f08a05aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0879929fad639a3a4256a702b9beba62"><td class="memTemplParams" colspan="2">template&lt;class E , class S &gt; </td></tr>
<tr class="memitem:a0879929fad639a3a4256a702b9beba62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a0879929fad639a3a4256a702b9beba62">broadcast</a> (E &amp;&amp;e, const S &amp;s)</td></tr>
<tr class="memdesc:a0879929fad639a3a4256a702b9beba62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> broadcasting the given expression to a specified shape.  <a href="namespacext.html#a0879929fad639a3a4256a702b9beba62">More...</a><br /></td></tr>
<tr class="separator:a0879929fad639a3a4256a702b9beba62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374d3f1b3ad4303931b6417739fbe5af"><td class="memTemplParams" colspan="2"><a id="a374d3f1b3ad4303931b6417739fbe5af"></a>
template&lt;class E , class I , std::size_t L&gt; </td></tr>
<tr class="memitem:a374d3f1b3ad4303931b6417739fbe5af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcast</b> (E &amp;&amp;e, const I(&amp;s)[L])</td></tr>
<tr class="separator:a374d3f1b3ad4303931b6417739fbe5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbb1f6120529f2d48c109344da7ef4e"><td class="memTemplParams" colspan="2"><a id="aafbb1f6120529f2d48c109344da7ef4e"></a>
template&lt;class CT , class X &gt; </td></tr>
<tr class="memitem:aafbb1f6120529f2d48c109344da7ef4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_begin</b> (<a class="el" href="classxt_1_1xbroadcast.html">xbroadcast</a>&lt; CT, X &gt; &amp;c) noexcept</td></tr>
<tr class="separator:aafbb1f6120529f2d48c109344da7ef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00fd175dc3eb3405361c3dd21ab52973"><td class="memTemplParams" colspan="2"><a id="a00fd175dc3eb3405361c3dd21ab52973"></a>
template&lt;class CT , class X &gt; </td></tr>
<tr class="memitem:a00fd175dc3eb3405361c3dd21ab52973"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_end</b> (<a class="el" href="classxt_1_1xbroadcast.html">xbroadcast</a>&lt; CT, X &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a00fd175dc3eb3405361c3dd21ab52973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9c9d5d7444fb5652fa193c8b140e93"><td class="memTemplParams" colspan="2"><a id="aba9c9d5d7444fb5652fa193c8b140e93"></a>
template&lt;class CT , class X &gt; </td></tr>
<tr class="memitem:aba9c9d5d7444fb5652fa193c8b140e93"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_begin</b> (const <a class="el" href="classxt_1_1xbroadcast.html">xbroadcast</a>&lt; CT, X &gt; &amp;c) noexcept</td></tr>
<tr class="separator:aba9c9d5d7444fb5652fa193c8b140e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b33ec763d7082b175fd5c8a353c2d9"><td class="memTemplParams" colspan="2"><a id="a51b33ec763d7082b175fd5c8a353c2d9"></a>
template&lt;class CT , class X &gt; </td></tr>
<tr class="memitem:a51b33ec763d7082b175fd5c8a353c2d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_end</b> (const <a class="el" href="classxt_1_1xbroadcast.html">xbroadcast</a>&lt; CT, X &gt; &amp;c) noexcept</td></tr>
<tr class="separator:a51b33ec763d7082b175fd5c8a353c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d9a085db3a2da0e567f3d8e09e5ad2"><td class="memTemplParams" colspan="2"><a id="a15d9a085db3a2da0e567f3d8e09e5ad2"></a>
template&lt;class D &gt; </td></tr>
<tr class="memitem:a15d9a085db3a2da0e567f3d8e09e5ad2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;rhs)</td></tr>
<tr class="separator:a15d9a085db3a2da0e567f3d8e09e5ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86132bdcac0ee1c3f3043e7bc013b55"><td class="memTemplParams" colspan="2"><a id="ae86132bdcac0ee1c3f3043e7bc013b55"></a>
template&lt;class D &gt; </td></tr>
<tr class="memitem:ae86132bdcac0ee1c3f3043e7bc013b55"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;rhs)</td></tr>
<tr class="separator:ae86132bdcac0ee1c3f3043e7bc013b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacd8107d68d542459495471f7bf853c"><td class="memTemplParams" colspan="2"><a id="abacd8107d68d542459495471f7bf853c"></a>
template&lt;class D &gt; </td></tr>
<tr class="memitem:abacd8107d68d542459495471f7bf853c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;rhs)</td></tr>
<tr class="separator:abacd8107d68d542459495471f7bf853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d591f21cf32088b430e3a7c61587ecf"><td class="memTemplParams" colspan="2"><a id="a2d591f21cf32088b430e3a7c61587ecf"></a>
template&lt;class D &gt; </td></tr>
<tr class="memitem:a2d591f21cf32088b430e3a7c61587ecf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;rhs)</td></tr>
<tr class="separator:a2d591f21cf32088b430e3a7c61587ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c38c87d826c7b0aad1e080c8a7ff1e2"><td class="memTemplParams" colspan="2"><a id="a0c38c87d826c7b0aad1e080c8a7ff1e2"></a>
template&lt;class D &gt; </td></tr>
<tr class="memitem:a0c38c87d826c7b0aad1e080c8a7ff1e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;rhs)</td></tr>
<tr class="separator:a0c38c87d826c7b0aad1e080c8a7ff1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622e65e63d48488470b69dc7f88c98a1"><td class="memTemplParams" colspan="2"><a id="a622e65e63d48488470b69dc7f88c98a1"></a>
template&lt;class D &gt; </td></tr>
<tr class="memitem:a622e65e63d48488470b69dc7f88c98a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbuffer__adaptor__base.html">xbuffer_adaptor_base</a>&lt; D &gt; &amp;rhs)</td></tr>
<tr class="separator:a622e65e63d48488470b69dc7f88c98a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69c6322847f7579bc3341459d6c1d7a"><td class="memTemplParams" colspan="2"><a id="ac69c6322847f7579bc3341459d6c1d7a"></a>
template&lt;class CP , class O , class A &gt; </td></tr>
<tr class="memitem:ac69c6322847f7579bc3341459d6c1d7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classxt_1_1xbuffer__adaptor.html">xbuffer_adaptor</a>&lt; CP, O, A &gt; &amp;lhs, <a class="el" href="classxt_1_1xbuffer__adaptor.html">xbuffer_adaptor</a>&lt; CP, O, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:ac69c6322847f7579bc3341459d6c1d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67de53fce7c04739e23cfe6f454ce001"><td class="memTemplParams" colspan="2"><a id="a67de53fce7c04739e23cfe6f454ce001"></a>
template&lt;class I , class CI &gt; </td></tr>
<tr class="memitem:a67de53fce7c04739e23cfe6f454ce001"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classxt_1_1xiterator__adaptor.html">xiterator_adaptor</a>&lt; I, CI &gt; &amp;lhs, <a class="el" href="classxt_1_1xiterator__adaptor.html">xiterator_adaptor</a>&lt; I, CI &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a67de53fce7c04739e23cfe6f454ce001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2978dd031630420d7e8be348b2e158"><td class="memTemplParams" colspan="2"><a id="a1e2978dd031630420d7e8be348b2e158"></a>
template&lt;class C , class IG &gt; </td></tr>
<tr class="memitem:a1e2978dd031630420d7e8be348b2e158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classxt_1_1xiterator__owner__adaptor.html">xiterator_owner_adaptor</a>&lt; C, IG &gt; &amp;lhs, <a class="el" href="classxt_1_1xiterator__owner__adaptor.html">xiterator_owner_adaptor</a>&lt; C, IG &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a1e2978dd031630420d7e8be348b2e158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed126a3a3558f52b22b62d4f30816a2e"><td class="memTemplParams" colspan="2"><a id="aed126a3a3558f52b22b62d4f30816a2e"></a>
template&lt;class C , class IG &gt; </td></tr>
<tr class="memitem:aed126a3a3558f52b22b62d4f30816a2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_xiterator_adaptor</b> (C &amp;&amp;container, IG iterator_getter)</td></tr>
<tr class="separator:aed126a3a3558f52b22b62d4f30816a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ae15885758184e0ee9def889b6bfb"><td class="memTemplParams" colspan="2">template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:a498ae15885758184e0ee9def889b6bfb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a498ae15885758184e0ee9def889b6bfb">ones</a> (S shape) noexcept</td></tr>
<tr class="memdesc:a498ae15885758184e0ee9def889b6bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> containing ones of the specified shape.  <a href="namespacext.html#a498ae15885758184e0ee9def889b6bfb">More...</a><br /></td></tr>
<tr class="separator:a498ae15885758184e0ee9def889b6bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e525d84011f911d9312c2bff737f48b"><td class="memTemplParams" colspan="2"><a id="a8e525d84011f911d9312c2bff737f48b"></a>
template&lt;class T , class I , std::size_t L&gt; </td></tr>
<tr class="memitem:a8e525d84011f911d9312c2bff737f48b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ones</b> (const I(&amp;shape)[L]) noexcept</td></tr>
<tr class="separator:a8e525d84011f911d9312c2bff737f48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700dc20edb5a81d66d5f89d350dca46f"><td class="memTemplParams" colspan="2">template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:a700dc20edb5a81d66d5f89d350dca46f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a700dc20edb5a81d66d5f89d350dca46f">zeros</a> (S shape) noexcept</td></tr>
<tr class="memdesc:a700dc20edb5a81d66d5f89d350dca46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> containing zeros of the specified shape.  <a href="namespacext.html#a700dc20edb5a81d66d5f89d350dca46f">More...</a><br /></td></tr>
<tr class="separator:a700dc20edb5a81d66d5f89d350dca46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5cc4f79499ba7f28155e9c13853a59"><td class="memTemplParams" colspan="2"><a id="ade5cc4f79499ba7f28155e9c13853a59"></a>
template&lt;class T , class I , std::size_t L&gt; </td></tr>
<tr class="memitem:ade5cc4f79499ba7f28155e9c13853a59"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zeros</b> (const I(&amp;shape)[L]) noexcept</td></tr>
<tr class="separator:ade5cc4f79499ba7f28155e9c13853a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7805e4eef27ae63c5509ca1f71eab5b4"><td class="memTemplParams" colspan="2">template&lt;class T , layout_type L = ::xt::layout_type::row_major, class S &gt; </td></tr>
<tr class="memitem:a7805e4eef27ae63c5509ca1f71eab5b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; T, L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a7805e4eef27ae63c5509ca1f71eab5b4">empty</a> (const S &amp;shape)</td></tr>
<tr class="memdesc:a7805e4eef27ae63c5509ca1f71eab5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a xcontainer (xarray, xtensor or xtensor_fixed) with uninitialized values of with value_type T and shape.  <a href="namespacext.html#a7805e4eef27ae63c5509ca1f71eab5b4">More...</a><br /></td></tr>
<tr class="separator:a7805e4eef27ae63c5509ca1f71eab5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18513a3abd6b420d0b49b06bf965d1d"><td class="memTemplParams" colspan="2"><a id="ab18513a3abd6b420d0b49b06bf965d1d"></a>
template&lt;class T , layout_type L = ::xt::layout_type::row_major, class ST , std::size_t N&gt; </td></tr>
<tr class="memitem:ab18513a3abd6b420d0b49b06bf965d1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xtensor</a>&lt; T, N, L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>empty</b> (const std::array&lt; ST, N &gt; &amp;shape)</td></tr>
<tr class="separator:ab18513a3abd6b420d0b49b06bf965d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c3a941336fa3d4c911304682947768"><td class="memTemplParams" colspan="2"><a id="a50c3a941336fa3d4c911304682947768"></a>
template&lt;class T , layout_type L = ::xt::layout_type::row_major, class I , std::size_t N&gt; </td></tr>
<tr class="memitem:a50c3a941336fa3d4c911304682947768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xtensor</a>&lt; T, N, L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>empty</b> (const I(&amp;shape)[N])</td></tr>
<tr class="separator:a50c3a941336fa3d4c911304682947768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44e60d829a0eb905aded9c0d1032be4"><td class="memTemplParams" colspan="2"><a id="ab44e60d829a0eb905aded9c0d1032be4"></a>
template&lt;class T , layout_type L = ::xt::layout_type::row_major, std::size_t... N&gt; </td></tr>
<tr class="memitem:ab44e60d829a0eb905aded9c0d1032be4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacext.html#a85d9917ae5dc2260d2889b7120b69d59">xtensor_fixed</a>&lt; T, <a class="el" href="classxt_1_1fixed__shape.html">fixed_shape</a>&lt; N... &gt;, L &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>empty</b> (const <a class="el" href="classxt_1_1fixed__shape.html">fixed_shape</a>&lt; N... &gt; &amp;)</td></tr>
<tr class="separator:ab44e60d829a0eb905aded9c0d1032be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda9d7634e3a60172e626271a0e50bae"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:abda9d7634e3a60172e626271a0e50bae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#abda9d7634e3a60172e626271a0e50bae">empty_like</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="memdesc:abda9d7634e3a60172e626271a0e50bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a xcontainer (xarray, xtensor or xtensor_fixed) with uninitialized values of the same shape, value type and layout as the input xexpression <em>e</em>.  <a href="namespacext.html#abda9d7634e3a60172e626271a0e50bae">More...</a><br /></td></tr>
<tr class="separator:abda9d7634e3a60172e626271a0e50bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682f65e5eb55b03cbef5fbd25bbdc349"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a682f65e5eb55b03cbef5fbd25bbdc349"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a682f65e5eb55b03cbef5fbd25bbdc349">full_like</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, typename E::value_type fill_value)</td></tr>
<tr class="memdesc:a682f65e5eb55b03cbef5fbd25bbdc349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a xcontainer (xarray, xtensor or xtensor_fixed), filled with <em>fill_value</em> and of the same shape, value type and layout as the input xexpression <em>e</em>.  <a href="namespacext.html#a682f65e5eb55b03cbef5fbd25bbdc349">More...</a><br /></td></tr>
<tr class="separator:a682f65e5eb55b03cbef5fbd25bbdc349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f9dd4af039df60663af606046a3b73"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a68f9dd4af039df60663af606046a3b73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a68f9dd4af039df60663af606046a3b73">zeros_like</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="memdesc:a68f9dd4af039df60663af606046a3b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a xcontainer (xarray, xtensor or xtensor_fixed), filled with zeros and of the same shape, value type and layout as the input xexpression <em>e</em>.  <a href="namespacext.html#a68f9dd4af039df60663af606046a3b73">More...</a><br /></td></tr>
<tr class="separator:a68f9dd4af039df60663af606046a3b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40664e859ef008b427ea6d8a013ebb96"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a40664e859ef008b427ea6d8a013ebb96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a40664e859ef008b427ea6d8a013ebb96">ones_like</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="memdesc:a40664e859ef008b427ea6d8a013ebb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a xcontainer (xarray, xtensor or xtensor_fixed), filled with ones and of the same shape, value type and layout as the input xexpression <em>e</em>.  <a href="namespacext.html#a40664e859ef008b427ea6d8a013ebb96">More...</a><br /></td></tr>
<tr class="separator:a40664e859ef008b427ea6d8a013ebb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3702c94500428b6c0c24a493ea020606"><td class="memTemplParams" colspan="2">template&lt;class T  = bool&gt; </td></tr>
<tr class="memitem:a3702c94500428b6c0c24a493ea020606"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a3702c94500428b6c0c24a493ea020606">eye</a> (const std::vector&lt; std::size_t &gt; &amp;shape, int k=0)</td></tr>
<tr class="memdesc:a3702c94500428b6c0c24a493ea020606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an array with ones on the diagonal.  <a href="namespacext.html#a3702c94500428b6c0c24a493ea020606">More...</a><br /></td></tr>
<tr class="separator:a3702c94500428b6c0c24a493ea020606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1633ad856dcd79570c229d95b09cf19"><td class="memTemplParams" colspan="2">template&lt;class T  = bool&gt; </td></tr>
<tr class="memitem:af1633ad856dcd79570c229d95b09cf19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af1633ad856dcd79570c229d95b09cf19">eye</a> (std::size_t n, int k=0)</td></tr>
<tr class="memdesc:af1633ad856dcd79570c229d95b09cf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a (n x n) array with ones on the diagonal.  <a href="namespacext.html#af1633ad856dcd79570c229d95b09cf19">More...</a><br /></td></tr>
<tr class="separator:af1633ad856dcd79570c229d95b09cf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156656dea2a291a2b0978a2b02d7f0f7"><td class="memTemplParams" colspan="2">template&lt;class T , class S  = T&gt; </td></tr>
<tr class="memitem:a156656dea2a291a2b0978a2b02d7f0f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a156656dea2a291a2b0978a2b02d7f0f7">arange</a> (T start, T stop, S step=1) noexcept</td></tr>
<tr class="memdesc:a156656dea2a291a2b0978a2b02d7f0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates numbers evenly spaced within given half-open interval [start, stop).  <a href="namespacext.html#a156656dea2a291a2b0978a2b02d7f0f7">More...</a><br /></td></tr>
<tr class="separator:a156656dea2a291a2b0978a2b02d7f0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7170425dd9da8585aefbd0eb79af4ec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab7170425dd9da8585aefbd0eb79af4ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ab7170425dd9da8585aefbd0eb79af4ec">arange</a> (T stop) noexcept</td></tr>
<tr class="memdesc:ab7170425dd9da8585aefbd0eb79af4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate numbers evenly spaced within given half-open interval [0, stop) with a step size of 1.  <a href="namespacext.html#ab7170425dd9da8585aefbd0eb79af4ec">More...</a><br /></td></tr>
<tr class="separator:ab7170425dd9da8585aefbd0eb79af4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b4f2192981c30e7ee35fba2b164cb2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a84b4f2192981c30e7ee35fba2b164cb2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a84b4f2192981c30e7ee35fba2b164cb2">linspace</a> (T start, T stop, std::size_t num_samples=50, bool endpoint=true) noexcept</td></tr>
<tr class="memdesc:a84b4f2192981c30e7ee35fba2b164cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates <em>num_samples</em> evenly spaced numbers over given interval.  <a href="namespacext.html#a84b4f2192981c30e7ee35fba2b164cb2">More...</a><br /></td></tr>
<tr class="separator:a84b4f2192981c30e7ee35fba2b164cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae448d7eb5de30ef12ca38ca7d6d15356"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae448d7eb5de30ef12ca38ca7d6d15356"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae448d7eb5de30ef12ca38ca7d6d15356">logspace</a> (T start, T stop, std::size_t num_samples, T base=10, bool endpoint=true) noexcept</td></tr>
<tr class="memdesc:ae448d7eb5de30ef12ca38ca7d6d15356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates <em>num_samples</em> numbers evenly spaced on a log scale over given interval.  <a href="namespacext.html#ae448d7eb5de30ef12ca38ca7d6d15356">More...</a><br /></td></tr>
<tr class="separator:ae448d7eb5de30ef12ca38ca7d6d15356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a17e1fea8041f69a66d80928359150"><td class="memTemplParams" colspan="2">template&lt;class... Types&gt; </td></tr>
<tr class="memitem:ae0a17e1fea8041f69a66d80928359150"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xtuple</a> (Types &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae0a17e1fea8041f69a66d80928359150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates tuples from arguments for <a class="el" href="namespacext.html#a28c746e1a420f706892d9aff3ad0dd30">concatenate</a> and <a class="el" href="namespacext.html#a120ce2e841c6d13c8688cd12128fe942">stack</a>.  <a href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">More...</a><br /></td></tr>
<tr class="separator:ae0a17e1fea8041f69a66d80928359150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c746e1a420f706892d9aff3ad0dd30"><td class="memTemplParams" colspan="2">template&lt;class... CT&gt; </td></tr>
<tr class="memitem:a28c746e1a420f706892d9aff3ad0dd30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a28c746e1a420f706892d9aff3ad0dd30">concatenate</a> (std::tuple&lt; CT... &gt; &amp;&amp;t, std::size_t axis=0)</td></tr>
<tr class="memdesc:a28c746e1a420f706892d9aff3ad0dd30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates xexpressions along <em>axis</em>.  <a href="namespacext.html#a28c746e1a420f706892d9aff3ad0dd30">More...</a><br /></td></tr>
<tr class="separator:a28c746e1a420f706892d9aff3ad0dd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd4bb1932caea00ada9ceb80588da69"><td class="memTemplParams" colspan="2"><a id="a5dd4bb1932caea00ada9ceb80588da69"></a>
template&lt;std::size_t axis, class... CT, typename  = std::enable_if_t&lt;detail::all_fixed_shapes&lt;CT...&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a5dd4bb1932caea00ada9ceb80588da69"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concatenate</b> (std::tuple&lt; CT... &gt; &amp;&amp;t)</td></tr>
<tr class="separator:a5dd4bb1932caea00ada9ceb80588da69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120ce2e841c6d13c8688cd12128fe942"><td class="memTemplParams" colspan="2">template&lt;class... CT&gt; </td></tr>
<tr class="memitem:a120ce2e841c6d13c8688cd12128fe942"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a120ce2e841c6d13c8688cd12128fe942">stack</a> (std::tuple&lt; CT... &gt; &amp;&amp;t, std::size_t axis=0)</td></tr>
<tr class="memdesc:a120ce2e841c6d13c8688cd12128fe942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack xexpressions along <em>axis</em>.  <a href="namespacext.html#a120ce2e841c6d13c8688cd12128fe942">More...</a><br /></td></tr>
<tr class="separator:a120ce2e841c6d13c8688cd12128fe942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc647d8af519da1d2126ec96a97849f"><td class="memTemplParams" colspan="2">template&lt;class... CT&gt; </td></tr>
<tr class="memitem:aacc647d8af519da1d2126ec96a97849f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aacc647d8af519da1d2126ec96a97849f">hstack</a> (std::tuple&lt; CT... &gt; &amp;&amp;t)</td></tr>
<tr class="memdesc:aacc647d8af519da1d2126ec96a97849f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack xexpressions in sequence horizontally (column wise).  <a href="namespacext.html#aacc647d8af519da1d2126ec96a97849f">More...</a><br /></td></tr>
<tr class="separator:aacc647d8af519da1d2126ec96a97849f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a9e875318fc87aba41154dddee7c60"><td class="memTemplParams" colspan="2">template&lt;class... CT&gt; </td></tr>
<tr class="memitem:a87a9e875318fc87aba41154dddee7c60"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a87a9e875318fc87aba41154dddee7c60">vstack</a> (std::tuple&lt; CT... &gt; &amp;&amp;t)</td></tr>
<tr class="memdesc:a87a9e875318fc87aba41154dddee7c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack xexpressions in sequence vertically (row wise).  <a href="namespacext.html#a87a9e875318fc87aba41154dddee7c60">More...</a><br /></td></tr>
<tr class="separator:a87a9e875318fc87aba41154dddee7c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e9f91fb23575e3e35eff04c628e19"><td class="memTemplParams" colspan="2">template&lt;class... E&gt; </td></tr>
<tr class="memitem:a513e9f91fb23575e3e35eff04c628e19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a513e9f91fb23575e3e35eff04c628e19">meshgrid</a> (E &amp;&amp;... e) noexcept</td></tr>
<tr class="memdesc:a513e9f91fb23575e3e35eff04c628e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return coordinate tensors from coordinate vectors.  <a href="namespacext.html#a513e9f91fb23575e3e35eff04c628e19">More...</a><br /></td></tr>
<tr class="separator:a513e9f91fb23575e3e35eff04c628e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ad98d837a74211cc0e5f07b85c2414"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a96ad98d837a74211cc0e5f07b85c2414"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a96ad98d837a74211cc0e5f07b85c2414">diagonal</a> (E &amp;&amp;arr, int offset=0, std::size_t axis_1=0, std::size_t axis_2=1)</td></tr>
<tr class="memdesc:a96ad98d837a74211cc0e5f07b85c2414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements on the diagonal of arr If arr has more than two dimensions, then the axes specified by axis_1 and axis_2 are used to determine the 2-D sub-array whose diagonal is returned.  <a href="namespacext.html#a96ad98d837a74211cc0e5f07b85c2414">More...</a><br /></td></tr>
<tr class="separator:a96ad98d837a74211cc0e5f07b85c2414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad848dae0258c3e5755ff7ee55e7c7b30"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ad848dae0258c3e5755ff7ee55e7c7b30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad848dae0258c3e5755ff7ee55e7c7b30">diag</a> (E &amp;&amp;arr, int k=0)</td></tr>
<tr class="memdesc:ad848dae0258c3e5755ff7ee55e7c7b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">xexpression with values of arr on the diagonal, zeroes otherwise  <a href="namespacext.html#ad848dae0258c3e5755ff7ee55e7c7b30">More...</a><br /></td></tr>
<tr class="separator:ad848dae0258c3e5755ff7ee55e7c7b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab524d3db6722f5d0e09347aedcf63837"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ab524d3db6722f5d0e09347aedcf63837"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ab524d3db6722f5d0e09347aedcf63837">tril</a> (E &amp;&amp;arr, int k=0)</td></tr>
<tr class="memdesc:ab524d3db6722f5d0e09347aedcf63837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract lower triangular matrix from xexpression.  <a href="namespacext.html#ab524d3db6722f5d0e09347aedcf63837">More...</a><br /></td></tr>
<tr class="separator:ab524d3db6722f5d0e09347aedcf63837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca4a423657a4a9c4ec4852dd344164b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a5ca4a423657a4a9c4ec4852dd344164b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a5ca4a423657a4a9c4ec4852dd344164b">triu</a> (E &amp;&amp;arr, int k=0)</td></tr>
<tr class="memdesc:a5ca4a423657a4a9c4ec4852dd344164b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract upper triangular matrix from xexpression.  <a href="namespacext.html#a5ca4a423657a4a9c4ec4852dd344164b">More...</a><br /></td></tr>
<tr class="separator:a5ca4a423657a4a9c4ec4852dd344164b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40004ebe29a2d087bcb79dc0f75d8dde"><td class="memTemplParams" colspan="2"><a id="a40004ebe29a2d087bcb79dc0f75d8dde"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a40004ebe29a2d087bcb79dc0f75d8dde"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_chunked</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:a40004ebe29a2d087bcb79dc0f75d8dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c408e717c7725211a42114adb4557b2"><td class="memTemplParams" colspan="2">template&lt;class T , layout_type L = ::xt::layout_type::row_major, class S &gt; </td></tr>
<tr class="memitem:a8c408e717c7725211a42114adb4557b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a8c408e717c7725211a42114adb4557b2">chunked_array</a> (S &amp;&amp;shape, S &amp;&amp;chunk_shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> chunk_memory_layout=::<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a>)</td></tr>
<tr class="memdesc:a8c408e717c7725211a42114adb4557b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an in-memory chunked array.  <a href="namespacext.html#a8c408e717c7725211a42114adb4557b2">More...</a><br /></td></tr>
<tr class="separator:a8c408e717c7725211a42114adb4557b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdab41e2512cbd6ece842090acb45598"><td class="memTemplParams" colspan="2"><a id="afdab41e2512cbd6ece842090acb45598"></a>
template&lt;class T , layout_type L = ::xt::layout_type::row_major, class S &gt; </td></tr>
<tr class="memitem:afdab41e2512cbd6ece842090acb45598"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chunked_array</b> (std::initializer_list&lt; S &gt; shape, std::initializer_list&lt; S &gt; chunk_shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> chunk_memory_layout=::<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a>)</td></tr>
<tr class="separator:afdab41e2512cbd6ece842090acb45598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f77d42d689828b2d8e8cdd57c28ee9b"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E , class S &gt; </td></tr>
<tr class="memitem:a7f77d42d689828b2d8e8cdd57c28ee9b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; typename E::value_type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a7f77d42d689828b2d8e8cdd57c28ee9b">chunked_array</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, S &amp;&amp;chunk_shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> chunk_memory_layout=::<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a>)</td></tr>
<tr class="memdesc:a7f77d42d689828b2d8e8cdd57c28ee9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an in-memory chunked array.  <a href="namespacext.html#a7f77d42d689828b2d8e8cdd57c28ee9b">More...</a><br /></td></tr>
<tr class="separator:a7f77d42d689828b2d8e8cdd57c28ee9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dae3e469de3f3ec7b0d4fc49f82de5c"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </td></tr>
<tr class="memitem:a2dae3e469de3f3ec7b0d4fc49f82de5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; typename E::value_type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2dae3e469de3f3ec7b0d4fc49f82de5c">chunked_array</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> chunk_memory_layout=::<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a>)</td></tr>
<tr class="memdesc:a2dae3e469de3f3ec7b0d4fc49f82de5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an in-memory chunked array.  <a href="namespacext.html#a2dae3e469de3f3ec7b0d4fc49f82de5c">More...</a><br /></td></tr>
<tr class="separator:a2dae3e469de3f3ec7b0d4fc49f82de5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2abc97dcc4ede3690531a33dd37e426"><td class="memTemplParams" colspan="2"><a id="ad2abc97dcc4ede3690531a33dd37e426"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:ad2abc97dcc4ede3690531a33dd37e426"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_chunked</b> (E &amp;&amp;e, std::vector&lt; std::size_t &gt; &amp;chunk_shape)</td></tr>
<tr class="separator:ad2abc97dcc4ede3690531a33dd37e426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dd460909cc5b81f23947646eebd543"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a40dd460909cc5b81f23947646eebd543"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a40dd460909cc5b81f23947646eebd543">real</a> (E &amp;&amp;e) noexcept</td></tr>
<tr class="memdesc:a40dd460909cc5b81f23947646eebd543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> representing the real part of the given expression.  <a href="namespacext.html#a40dd460909cc5b81f23947646eebd543">More...</a><br /></td></tr>
<tr class="separator:a40dd460909cc5b81f23947646eebd543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155e369dcf03bd465609d279b82f6da8"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a155e369dcf03bd465609d279b82f6da8"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a155e369dcf03bd465609d279b82f6da8">imag</a> (E &amp;&amp;e) noexcept</td></tr>
<tr class="memdesc:a155e369dcf03bd465609d279b82f6da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> representing the imaginary part of the given expression.  <a href="namespacext.html#a155e369dcf03bd465609d279b82f6da8">More...</a><br /></td></tr>
<tr class="separator:a155e369dcf03bd465609d279b82f6da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77874ddd5efaa90065d692ee4a6049a2"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a77874ddd5efaa90065d692ee4a6049a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a77874ddd5efaa90065d692ee4a6049a2">conj</a> (E &amp;&amp;e) noexcept</td></tr>
<tr class="memdesc:a77874ddd5efaa90065d692ee4a6049a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classxt_1_1xfunction.html">xfunction</a> evaluating to the complex conjugate of the given expression.  <a href="namespacext.html#a77874ddd5efaa90065d692ee4a6049a2">More...</a><br /></td></tr>
<tr class="separator:a77874ddd5efaa90065d692ee4a6049a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e6cc463f0aeee688d90dcd320cd672"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a79e6cc463f0aeee688d90dcd320cd672"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a79e6cc463f0aeee688d90dcd320cd672">arg</a> (E &amp;&amp;e) noexcept</td></tr>
<tr class="memdesc:a79e6cc463f0aeee688d90dcd320cd672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the phase angle (in radians) elementwise for the complex numbers in e.  <a href="namespacext.html#a79e6cc463f0aeee688d90dcd320cd672">More...</a><br /></td></tr>
<tr class="separator:a79e6cc463f0aeee688d90dcd320cd672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d3e146e64f9cb63d1b66e7d0d43867"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ad2d3e146e64f9cb63d1b66e7d0d43867"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad2d3e146e64f9cb63d1b66e7d0d43867">angle</a> (E &amp;&amp;e, bool deg=false) noexcept</td></tr>
<tr class="memdesc:ad2d3e146e64f9cb63d1b66e7d0d43867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the phase angle elementwise for the complex numbers in e.  <a href="namespacext.html#ad2d3e146e64f9cb63d1b66e7d0d43867">More...</a><br /></td></tr>
<tr class="separator:ad2d3e146e64f9cb63d1b66e7d0d43867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3afef5ff535998e5dd0d95a979c54bf"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ad3afef5ff535998e5dd0d95a979c54bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad3afef5ff535998e5dd0d95a979c54bf">norm</a> (E &amp;&amp;e) noexcept</td></tr>
<tr class="memdesc:ad3afef5ff535998e5dd0d95a979c54bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the squared magnitude elementwise for the complex numbers in e.  <a href="namespacext.html#ad3afef5ff535998e5dd0d95a979c54bf">More...</a><br /></td></tr>
<tr class="separator:ad3afef5ff535998e5dd0d95a979c54bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7ff9a44466a0de5525ac507db04e6a"><td class="memTemplParams" colspan="2">template&lt;class T , class A  = std::allocator&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a1a7ff9a44466a0de5525ac507db04e6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xtensor__container.html">xcsv_tensor</a>&lt; T, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a1a7ff9a44466a0de5525ac507db04e6a">load_csv</a> (std::istream &amp;stream, const char delimiter, const std::size_t skip_rows, const std::ptrdiff_t max_rows, const std::string comments)</td></tr>
<tr class="memdesc:a1a7ff9a44466a0de5525ac507db04e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load tensor from CSV.  <a href="namespacext.html#a1a7ff9a44466a0de5525ac507db04e6a">More...</a><br /></td></tr>
<tr class="separator:a1a7ff9a44466a0de5525ac507db04e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809a1475d6c06e6209878b293ca0aa4d"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a809a1475d6c06e6209878b293ca0aa4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a809a1475d6c06e6209878b293ca0aa4d">dump_csv</a> (std::ostream &amp;stream, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="memdesc:a809a1475d6c06e6209878b293ca0aa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump tensor to CSV.  <a href="namespacext.html#a809a1475d6c06e6209878b293ca0aa4d">More...</a><br /></td></tr>
<tr class="separator:a809a1475d6c06e6209878b293ca0aa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8530622d873de92ccb155bc5ffb2beae"><td class="memTemplParams" colspan="2"><a id="a8530622d873de92ccb155bc5ffb2beae"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a8530622d873de92ccb155bc5ffb2beae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>load_file</b> (std::istream &amp;stream, <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const <a class="el" href="structxt_1_1xcsv__config.html">xcsv_config</a> &amp;config)</td></tr>
<tr class="separator:a8530622d873de92ccb155bc5ffb2beae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40266d433f6caca1231fe95dc52b75ce"><td class="memTemplParams" colspan="2"><a id="a40266d433f6caca1231fe95dc52b75ce"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a40266d433f6caca1231fe95dc52b75ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dump_file</b> (std::ostream &amp;stream, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const <a class="el" href="structxt_1_1xcsv__config.html">xcsv_config</a> &amp;)</td></tr>
<tr class="separator:a40266d433f6caca1231fe95dc52b75ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976d5967afc396673bcd9c6a891c17ce"><td class="memTemplParams" colspan="2"><a id="a976d5967afc396673bcd9c6a891c17ce"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a976d5967afc396673bcd9c6a891c17ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_view</b> (E &amp;&amp;e, const xdynamic_slice_vector &amp;slices)</td></tr>
<tr class="separator:a976d5967afc396673bcd9c6a891c17ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de8de7e1ff00699749837bae29a9bc2"><td class="memTemplParams" colspan="2"><a id="a4de8de7e1ff00699749837bae29a9bc2"></a>
template&lt;class S1 , class S2 &gt; </td></tr>
<tr class="memitem:a4de8de7e1ff00699749837bae29a9bc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>throw_broadcast_error</b> (const S1 &amp;lhs, const S2 &amp;rhs)</td></tr>
<tr class="separator:a4de8de7e1ff00699749837bae29a9bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5e4cf7e39aa3cf665d2eefc07868da"><td class="memTemplParams" colspan="2"><a id="abd5e4cf7e39aa3cf665d2eefc07868da"></a>
template&lt;class S1 , class S2 &gt; </td></tr>
<tr class="memitem:abd5e4cf7e39aa3cf665d2eefc07868da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>throw_concatenate_error</b> (const S1 &amp;lhs, const S2 &amp;rhs)</td></tr>
<tr class="separator:abd5e4cf7e39aa3cf665d2eefc07868da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce32b8ad6991f9d175291014c4eb2b6"><td class="memTemplParams" colspan="2"><a id="a4ce32b8ad6991f9d175291014c4eb2b6"></a>
template&lt;class S , class... Args&gt; </td></tr>
<tr class="memitem:a4ce32b8ad6991f9d175291014c4eb2b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_index</b> (const S &amp;shape, Args... args)</td></tr>
<tr class="separator:a4ce32b8ad6991f9d175291014c4eb2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cdefe0c0a7557271b71e0693fdf72d"><td class="memTemplParams" colspan="2"><a id="ad0cdefe0c0a7557271b71e0693fdf72d"></a>
template&lt;class S , class It &gt; </td></tr>
<tr class="memitem:ad0cdefe0c0a7557271b71e0693fdf72d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_element_index</b> (const S &amp;shape, It first, It last)</td></tr>
<tr class="separator:ad0cdefe0c0a7557271b71e0693fdf72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e0388effebaeb4c534f05a469b7fd7"><td class="memTemplParams" colspan="2"><a id="af8e0388effebaeb4c534f05a469b7fd7"></a>
template&lt;class S , class... Args&gt; </td></tr>
<tr class="memitem:af8e0388effebaeb4c534f05a469b7fd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_dimension</b> (const S &amp;shape, Args...)</td></tr>
<tr class="separator:af8e0388effebaeb4c534f05a469b7fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea1213d785a4732fe31381c90a162a5"><td class="memTemplParams" colspan="2"><a id="acea1213d785a4732fe31381c90a162a5"></a>
template&lt;class S , class... Args&gt; </td></tr>
<tr class="memitem:acea1213d785a4732fe31381c90a162a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_access</b> (const S &amp;shape, Args... args)</td></tr>
<tr class="separator:acea1213d785a4732fe31381c90a162a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc20d1111aa656d18211b42edc32843d"><td class="memTemplParams" colspan="2"><a id="abc20d1111aa656d18211b42edc32843d"></a>
template&lt;layout_type L, class R , std::size_t... X&gt; </td></tr>
<tr class="memitem:abc20d1111aa656d18211b42edc32843d"><td class="memTemplItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_strides</b> (const <a class="el" href="classxt_1_1fixed__shape.html">fixed_shape</a>&lt; X... &gt; &amp;shape) noexcept</td></tr>
<tr class="separator:abc20d1111aa656d18211b42edc32843d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b193ee1f2348cef934988b1b03304f0"><td class="memTemplParams" colspan="2"><a id="a6b193ee1f2348cef934988b1b03304f0"></a>
template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:a6b193ee1f2348cef934988b1b03304f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_backstrides</b> (const S &amp;shape, const T &amp;strides) noexcept</td></tr>
<tr class="separator:a6b193ee1f2348cef934988b1b03304f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fb5a6e58dafe175544508ea913cff0"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a80fb5a6e58dafe175544508ea913cff0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a80fb5a6e58dafe175544508ea913cff0">digitize</a> (E1 &amp;&amp;data, E2 &amp;&amp;bin_edges, bool right=false)</td></tr>
<tr class="memdesc:a80fb5a6e58dafe175544508ea913cff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the indices of the bins to which each value in input array belongs.  <a href="namespacext.html#a80fb5a6e58dafe175544508ea913cff0">More...</a><br /></td></tr>
<tr class="separator:a80fb5a6e58dafe175544508ea913cff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e9ea74b2e3f62bb682798bd5d7414d"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:a95e9ea74b2e3f62bb682798bd5d7414d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a95e9ea74b2e3f62bb682798bd5d7414d">histogram</a> (E1 &amp;&amp;data, E2 &amp;&amp;bin_edges, E3 &amp;&amp;weights, bool density=false)</td></tr>
<tr class="memdesc:a95e9ea74b2e3f62bb682798bd5d7414d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the histogram of a set of data.  <a href="namespacext.html#a95e9ea74b2e3f62bb682798bd5d7414d">More...</a><br /></td></tr>
<tr class="separator:a95e9ea74b2e3f62bb682798bd5d7414d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5ba67f2a11ee24ccf629105d12e407"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a0a5ba67f2a11ee24ccf629105d12e407"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a0a5ba67f2a11ee24ccf629105d12e407">histogram</a> (E1 &amp;&amp;data, E2 &amp;&amp;bin_edges, bool density=false)</td></tr>
<tr class="memdesc:a0a5ba67f2a11ee24ccf629105d12e407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the histogram of a set of data.  <a href="namespacext.html#a0a5ba67f2a11ee24ccf629105d12e407">More...</a><br /></td></tr>
<tr class="separator:a0a5ba67f2a11ee24ccf629105d12e407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8379adac71c1af9b9bc50f835d9536f"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class E1 &gt; </td></tr>
<tr class="memitem:ad8379adac71c1af9b9bc50f835d9536f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad8379adac71c1af9b9bc50f835d9536f">histogram</a> (E1 &amp;&amp;data, std::size_t bins=10, bool density=false)</td></tr>
<tr class="memdesc:ad8379adac71c1af9b9bc50f835d9536f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the histogram of a set of data.  <a href="namespacext.html#ad8379adac71c1af9b9bc50f835d9536f">More...</a><br /></td></tr>
<tr class="separator:ad8379adac71c1af9b9bc50f835d9536f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60449f18cbf62c0a104cf72e53f7948d"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a60449f18cbf62c0a104cf72e53f7948d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a60449f18cbf62c0a104cf72e53f7948d">histogram</a> (E1 &amp;&amp;data, std::size_t bins, E2 left, E2 right, bool density=false)</td></tr>
<tr class="memdesc:a60449f18cbf62c0a104cf72e53f7948d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the histogram of a set of data.  <a href="namespacext.html#a60449f18cbf62c0a104cf72e53f7948d">More...</a><br /></td></tr>
<tr class="separator:a60449f18cbf62c0a104cf72e53f7948d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8545490885a4a8466344d954bd5326c1"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a8545490885a4a8466344d954bd5326c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a8545490885a4a8466344d954bd5326c1">histogram</a> (E1 &amp;&amp;data, std::size_t bins, E2 &amp;&amp;weights, bool density=false)</td></tr>
<tr class="memdesc:a8545490885a4a8466344d954bd5326c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the histogram of a set of data.  <a href="namespacext.html#a8545490885a4a8466344d954bd5326c1">More...</a><br /></td></tr>
<tr class="separator:a8545490885a4a8466344d954bd5326c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadf08c80728a3d2ace5739f3350f908"><td class="memTemplParams" colspan="2">template&lt;class R  = double, class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:aaadf08c80728a3d2ace5739f3350f908"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aaadf08c80728a3d2ace5739f3350f908">histogram</a> (E1 &amp;&amp;data, std::size_t bins, E2 &amp;&amp;weights, E3 left, E3 right, bool density=false)</td></tr>
<tr class="memdesc:aaadf08c80728a3d2ace5739f3350f908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the histogram of a set of data.  <a href="namespacext.html#aaadf08c80728a3d2ace5739f3350f908">More...</a><br /></td></tr>
<tr class="separator:aaadf08c80728a3d2ace5739f3350f908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ca89b6c48fc35c9a293c2d81f66288"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:a53ca89b6c48fc35c9a293c2d81f66288"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a53ca89b6c48fc35c9a293c2d81f66288">histogram_bin_edges</a> (E1 &amp;&amp;data, E2 &amp;&amp;weights, E3 left, E3 right, std::size_t bins=10, <a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a> mode=histogram_algorithm::automatic)</td></tr>
<tr class="memdesc:a53ca89b6c48fc35c9a293c2d81f66288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bin-edges of a histogram of a set of data using different algorithms.  <a href="namespacext.html#a53ca89b6c48fc35c9a293c2d81f66288">More...</a><br /></td></tr>
<tr class="separator:a53ca89b6c48fc35c9a293c2d81f66288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d16282168b4675fdc93c5563eb5324"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:aa3d16282168b4675fdc93c5563eb5324"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aa3d16282168b4675fdc93c5563eb5324">histogram_bin_edges</a> (E1 &amp;&amp;data, E2 &amp;&amp;weights, std::size_t bins=10, <a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a> mode=histogram_algorithm::automatic)</td></tr>
<tr class="memdesc:aa3d16282168b4675fdc93c5563eb5324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bin-edges of a histogram of a set of data using different algorithms.  <a href="namespacext.html#aa3d16282168b4675fdc93c5563eb5324">More...</a><br /></td></tr>
<tr class="separator:aa3d16282168b4675fdc93c5563eb5324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49105a6754699f6ab1073e9868782ec8"><td class="memTemplParams" colspan="2">template&lt;class E1 &gt; </td></tr>
<tr class="memitem:a49105a6754699f6ab1073e9868782ec8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a49105a6754699f6ab1073e9868782ec8">histogram_bin_edges</a> (E1 &amp;&amp;data, std::size_t bins=10, <a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a> mode=histogram_algorithm::automatic)</td></tr>
<tr class="memdesc:a49105a6754699f6ab1073e9868782ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bin-edges of a histogram of a set of data using different algorithms.  <a href="namespacext.html#a49105a6754699f6ab1073e9868782ec8">More...</a><br /></td></tr>
<tr class="separator:a49105a6754699f6ab1073e9868782ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abbd094554988573b2c3cce9e521aab"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a5abbd094554988573b2c3cce9e521aab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a5abbd094554988573b2c3cce9e521aab">histogram_bin_edges</a> (E1 &amp;&amp;data, E2 left, E2 right, std::size_t bins=10, <a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a> mode=histogram_algorithm::automatic)</td></tr>
<tr class="memdesc:a5abbd094554988573b2c3cce9e521aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bin-edges of a histogram of a set of data using different algorithms.  <a href="namespacext.html#a5abbd094554988573b2c3cce9e521aab">More...</a><br /></td></tr>
<tr class="separator:a5abbd094554988573b2c3cce9e521aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5ac7b9e3af63f34daf465b902d0108"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 , xtl::check_concept&lt; is_xexpression&lt; std::decay_t&lt; E2 &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:aed5ac7b9e3af63f34daf465b902d0108"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aed5ac7b9e3af63f34daf465b902d0108">bincount</a> (E1 &amp;&amp;data, E2 &amp;&amp;weights, std::size_t minlength=0)</td></tr>
<tr class="memdesc:aed5ac7b9e3af63f34daf465b902d0108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of occurrences of each value in array of non-negative ints.  <a href="namespacext.html#aed5ac7b9e3af63f34daf465b902d0108">More...</a><br /></td></tr>
<tr class="separator:aed5ac7b9e3af63f34daf465b902d0108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afdd06a2bbadf943d4f78a56a19f88f"><td class="memTemplParams" colspan="2"><a id="a8afdd06a2bbadf943d4f78a56a19f88f"></a>
template&lt;class E1 &gt; </td></tr>
<tr class="memitem:a8afdd06a2bbadf943d4f78a56a19f88f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bincount</b> (E1 &amp;&amp;data, std::size_t minlength=0)</td></tr>
<tr class="separator:a8afdd06a2bbadf943d4f78a56a19f88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414b2909d3c9e0bf5142d4074491ffe7"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a414b2909d3c9e0bf5142d4074491ffe7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xt::xtensor</a>&lt; size_t, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a414b2909d3c9e0bf5142d4074491ffe7">bin_items</a> (size_t N, E &amp;&amp;weights)</td></tr>
<tr class="memdesc:a414b2909d3c9e0bf5142d4074491ffe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items in each bin, given the fraction of items per bin.  <a href="namespacext.html#a414b2909d3c9e0bf5142d4074491ffe7">More...</a><br /></td></tr>
<tr class="separator:a414b2909d3c9e0bf5142d4074491ffe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87461823c6747aabd154ee7825700ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xt::xtensor</a>&lt; size_t, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#ae87461823c6747aabd154ee7825700ca">bin_items</a> (size_t N, size_t bins)</td></tr>
<tr class="memdesc:ae87461823c6747aabd154ee7825700ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items in each bin, with each bin having approximately the same number of items in it,under the constraint that the total number of items of all bins is exactly "N".  <a href="namespacext.html#ae87461823c6747aabd154ee7825700ca">More...</a><br /></td></tr>
<tr class="separator:ae87461823c6747aabd154ee7825700ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026d50546c0421fe8fbee84d28a0a500"><td class="memTemplParams" colspan="2"><a id="a026d50546c0421fe8fbee84d28a0a500"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a026d50546c0421fe8fbee84d28a0a500"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structxt_1_1static__string.html">static_string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_name</b> ()</td></tr>
<tr class="separator:a026d50546c0421fe8fbee84d28a0a500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf22d0bd9a050dbd4a812941497bbb68"><td class="memTemplParams" colspan="2"><a id="abf22d0bd9a050dbd4a812941497bbb68"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abf22d0bd9a050dbd4a812941497bbb68"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>type_to_string</b> ()</td></tr>
<tr class="separator:abf22d0bd9a050dbd4a812941497bbb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa6a9b69f35e0260c2b6b8bcd28dde3"><td class="memTemplParams" colspan="2"><a id="a1aa6a9b69f35e0260c2b6b8bcd28dde3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1aa6a9b69f35e0260c2b6b8bcd28dde3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>info</b> (const T &amp;t)</td></tr>
<tr class="separator:a1aa6a9b69f35e0260c2b6b8bcd28dde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae058265553f76003000d34bd333c013c"><td class="memTemplParams" colspan="2"><a id="ae058265553f76003000d34bd333c013c"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:ae058265553f76003000d34bd333c013c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:ae058265553f76003000d34bd333c013c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7977f4b6d51fa6ecb1ea26fab072e63"><td class="memItemLeft" align="right" valign="top"><a id="ae7977f4b6d51fa6ecb1ea26fab072e63"></a>
<a class="el" href="structxt_1_1print__options_1_1print__options__impl.html">print_options::print_options_impl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_print_options</b> (std::ostream &amp;out)</td></tr>
<tr class="separator:ae7977f4b6d51fa6ecb1ea26fab072e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2024f646c877e91fcb9ba35a158ae64f"><td class="memTemplParams" colspan="2"><a id="a2024f646c877e91fcb9ba35a158ae64f"></a>
template&lt;class E , class F &gt; </td></tr>
<tr class="memitem:a2024f646c877e91fcb9ba35a158ae64f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pretty_print</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, F &amp;&amp;func, std::ostream &amp;out=std::cout)</td></tr>
<tr class="separator:a2024f646c877e91fcb9ba35a158ae64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae844a4ce5813b0fe125964d2bf43011a"><td class="memTemplParams" colspan="2"><a id="ae844a4ce5813b0fe125964d2bf43011a"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:ae844a4ce5813b0fe125964d2bf43011a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pretty_print</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::ostream &amp;out=std::cout)</td></tr>
<tr class="separator:ae844a4ce5813b0fe125964d2bf43011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ea5323b9e97fe1718e04405b96f0fa"><td class="memTemplParams" colspan="2"><a id="a96ea5323b9e97fe1718e04405b96f0fa"></a>
template&lt;class St , class S , layout_type L&gt; </td></tr>
<tr class="memitem:a96ea5323b9e97fe1718e04405b96f0fa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1xiterator.html">xiterator</a>&lt; St, S, L &gt; &amp;lhs, const <a class="el" href="classxt_1_1xiterator.html">xiterator</a>&lt; St, S, L &gt; &amp;rhs)</td></tr>
<tr class="separator:a96ea5323b9e97fe1718e04405b96f0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace414d38bdcdfdd98313dcc38e47c24a"><td class="memTemplParams" colspan="2"><a id="ace414d38bdcdfdd98313dcc38e47c24a"></a>
template&lt;class St , class S , layout_type L&gt; </td></tr>
<tr class="memitem:ace414d38bdcdfdd98313dcc38e47c24a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1xiterator.html">xiterator</a>&lt; St, S, L &gt; &amp;lhs, const <a class="el" href="classxt_1_1xiterator.html">xiterator</a>&lt; St, S, L &gt; &amp;rhs)</td></tr>
<tr class="separator:ace414d38bdcdfdd98313dcc38e47c24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac193173ebaf211c7a45e3448826f45cf"><td class="memTemplParams" colspan="2"><a id="ac193173ebaf211c7a45e3448826f45cf"></a>
template&lt;class It , class BIt &gt; </td></tr>
<tr class="memitem:ac193173ebaf211c7a45e3448826f45cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1xbounded__iterator.html">xbounded_iterator</a>&lt; It, BIt &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbounded__iterator.html">xbounded_iterator</a>&lt; It, BIt &gt; &amp;rhs)</td></tr>
<tr class="separator:ac193173ebaf211c7a45e3448826f45cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa91e21f16803956bdc7cb7d046a5076"><td class="memTemplParams" colspan="2"><a id="afa91e21f16803956bdc7cb7d046a5076"></a>
template&lt;class It , class BIt &gt; </td></tr>
<tr class="memitem:afa91e21f16803956bdc7cb7d046a5076"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1xbounded__iterator.html">xbounded_iterator</a>&lt; It, BIt &gt; &amp;lhs, const <a class="el" href="classxt_1_1xbounded__iterator.html">xbounded_iterator</a>&lt; It, BIt &gt; &amp;rhs)</td></tr>
<tr class="separator:afa91e21f16803956bdc7cb7d046a5076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da24fb54c17bab920abf945142296c2"><td class="memTemplParams" colspan="2"><a id="a2da24fb54c17bab920abf945142296c2"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a2da24fb54c17bab920abf945142296c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_begin</b> (C &amp;c) noexcept</td></tr>
<tr class="separator:a2da24fb54c17bab920abf945142296c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6948f95036387b24eae6aab895f68cf2"><td class="memTemplParams" colspan="2"><a id="a6948f95036387b24eae6aab895f68cf2"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a6948f95036387b24eae6aab895f68cf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_end</b> (C &amp;c) noexcept</td></tr>
<tr class="separator:a6948f95036387b24eae6aab895f68cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d0ebabd26c909d6c5d704bb64abed8"><td class="memTemplParams" colspan="2"><a id="a71d0ebabd26c909d6c5d704bb64abed8"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a71d0ebabd26c909d6c5d704bb64abed8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_begin</b> (const C &amp;c) noexcept</td></tr>
<tr class="separator:a71d0ebabd26c909d6c5d704bb64abed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6447d8ab9e7c12f96ceeeb5813f6cc"><td class="memTemplParams" colspan="2"><a id="a2e6447d8ab9e7c12f96ceeeb5813f6cc"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a2e6447d8ab9e7c12f96ceeeb5813f6cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_end</b> (const C &amp;c) noexcept</td></tr>
<tr class="separator:a2e6447d8ab9e7c12f96ceeeb5813f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd7842df1c7034546b2a84bff7fd97b"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename U, typename V, typename... Args &gt; class M, class E &gt; </td></tr>
<tr class="memitem:aafd7842df1c7034546b2a84bff7fd97b"><td class="memTemplItemLeft" align="right" valign="top">enable_xexpression&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aafd7842df1c7034546b2a84bff7fd97b">to_json</a> (nlohmann::basic_json&lt; M &gt; &amp;j, const E &amp;e)</td></tr>
<tr class="memdesc:aafd7842df1c7034546b2a84bff7fd97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON serialization of an xtensor expression.  <a href="namespacext.html#aafd7842df1c7034546b2a84bff7fd97b">More...</a><br /></td></tr>
<tr class="separator:aafd7842df1c7034546b2a84bff7fd97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d553d1a9a0e27ad8c9054389c1e2c59"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename U, typename V, typename... Args &gt; class M, class E &gt; </td></tr>
<tr class="memitem:a3d553d1a9a0e27ad8c9054389c1e2c59"><td class="memTemplItemLeft" align="right" valign="top">enable_xcontainer_semantics&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a3d553d1a9a0e27ad8c9054389c1e2c59">from_json</a> (const nlohmann::basic_json&lt; M &gt; &amp;j, E &amp;e)</td></tr>
<tr class="memdesc:a3d553d1a9a0e27ad8c9054389c1e2c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON deserialization of a xtensor expression with a container or a view semantics.  <a href="namespacext.html#a3d553d1a9a0e27ad8c9054389c1e2c59">More...</a><br /></td></tr>
<tr class="separator:a3d553d1a9a0e27ad8c9054389c1e2c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b28c7951a0991e2e8d39422c2b46b2"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a27b28c7951a0991e2e8d39422c2b46b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a27b28c7951a0991e2e8d39422c2b46b2">compute_layout</a> (Args... args) noexcept</td></tr>
<tr class="memdesc:a27b28c7951a0991e2e8d39422c2b46b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the following logical table:  <a href="namespacext.html#a27b28c7951a0991e2e8d39422c2b46b2">More...</a><br /></td></tr>
<tr class="separator:a27b28c7951a0991e2e8d39422c2b46b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1318e5ff9c501bf5d170ba179216da"><td class="memItemLeft" align="right" valign="top"><a id="aba1318e5ff9c501bf5d170ba179216da"></a>
constexpr <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>default_assignable_layout</b> (<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l) noexcept</td></tr>
<tr class="separator:aba1318e5ff9c501bf5d170ba179216da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8145767cf554a5eb69f82eb7126f05d"><td class="memItemLeft" align="right" valign="top"><a id="ad8145767cf554a5eb69f82eb7126f05d"></a>
constexpr <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>layout_remove_any</b> (const <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> layout) noexcept</td></tr>
<tr class="separator:ad8145767cf554a5eb69f82eb7126f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620b1159b15601a1fd9b2ddaa746225e"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a620b1159b15601a1fd9b2ddaa746225e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a620b1159b15601a1fd9b2ddaa746225e">transpose</a> (E &amp;&amp;e) noexcept</td></tr>
<tr class="memdesc:a620b1159b15601a1fd9b2ddaa746225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transpose view by reversing the dimensions of xexpression e.  <a href="namespacext.html#a620b1159b15601a1fd9b2ddaa746225e">More...</a><br /></td></tr>
<tr class="separator:a620b1159b15601a1fd9b2ddaa746225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b37193755be9f7e4c0161a6d9f9b6b"><td class="memTemplParams" colspan="2">template&lt;class E , class S , class Tag  = check_policy::none&gt; </td></tr>
<tr class="memitem:ae8b37193755be9f7e4c0161a6d9f9b6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae8b37193755be9f7e4c0161a6d9f9b6b">transpose</a> (E &amp;&amp;e, S &amp;&amp;permutation, Tag check_policy)</td></tr>
<tr class="memdesc:ae8b37193755be9f7e4c0161a6d9f9b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transpose view by permuting the xexpression e with <code>permutation</code>.  <a href="namespacext.html#ae8b37193755be9f7e4c0161a6d9f9b6b">More...</a><br /></td></tr>
<tr class="separator:ae8b37193755be9f7e4c0161a6d9f9b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d3b08fa67fe8c498e4271fca338e28"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </td></tr>
<tr class="memitem:a52d3b08fa67fe8c498e4271fca338e28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a52d3b08fa67fe8c498e4271fca338e28">ravel</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a52d3b08fa67fe8c498e4271fca338e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a flatten view of the given expression.  <a href="namespacext.html#a52d3b08fa67fe8c498e4271fca338e28">More...</a><br /></td></tr>
<tr class="separator:a52d3b08fa67fe8c498e4271fca338e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a975d3b718bfaf8ecf1db8072a0a0c"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </td></tr>
<tr class="memitem:a10a975d3b718bfaf8ecf1db8072a0a0c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a10a975d3b718bfaf8ecf1db8072a0a0c">flatten</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a10a975d3b718bfaf8ecf1db8072a0a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a flatten view of the given expression.  <a href="namespacext.html#a10a975d3b718bfaf8ecf1db8072a0a0c">More...</a><br /></td></tr>
<tr class="separator:a10a975d3b718bfaf8ecf1db8072a0a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8bacc1aed492dc936c80bc58730463"><td class="memTemplParams" colspan="2">template&lt;layout_type L, class T &gt; </td></tr>
<tr class="memitem:afe8bacc1aed492dc936c80bc58730463"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#afe8bacc1aed492dc936c80bc58730463">flatnonzero</a> (const T &amp;arr)</td></tr>
<tr class="memdesc:afe8bacc1aed492dc936c80bc58730463"><td class="mdescLeft">&#160;</td><td class="mdescRight">return indices that are non-zero in the flattened version of arr, equivalent to nonzero(ravel&lt;layout_type&gt;(arr))[0];  <a href="namespacext.html#afe8bacc1aed492dc936c80bc58730463">More...</a><br /></td></tr>
<tr class="separator:afe8bacc1aed492dc936c80bc58730463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938cc86961805cf29a1f68394922d9f7"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a938cc86961805cf29a1f68394922d9f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a938cc86961805cf29a1f68394922d9f7">trim_zeros</a> (E &amp;&amp;e, const std::string &amp;direction)</td></tr>
<tr class="memdesc:a938cc86961805cf29a1f68394922d9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim zeros at beginning, end or both of 1D sequence.  <a href="namespacext.html#a938cc86961805cf29a1f68394922d9f7">More...</a><br /></td></tr>
<tr class="separator:a938cc86961805cf29a1f68394922d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2734defabe45fcb86ed9545c1b033134"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a2734defabe45fcb86ed9545c1b033134"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2734defabe45fcb86ed9545c1b033134">squeeze</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a2734defabe45fcb86ed9545c1b033134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squeeze view of the given expression.  <a href="namespacext.html#a2734defabe45fcb86ed9545c1b033134">More...</a><br /></td></tr>
<tr class="separator:a2734defabe45fcb86ed9545c1b033134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcffbf0452884112fd3bcf7e7077fd6f"><td class="memTemplParams" colspan="2">template&lt;class E , class S , class Tag  = check_policy::none, std::enable_if_t&lt;!xtl::is_integral&lt; S &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adcffbf0452884112fd3bcf7e7077fd6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#adcffbf0452884112fd3bcf7e7077fd6f">squeeze</a> (E &amp;&amp;e, S &amp;&amp;axis, Tag check_policy)</td></tr>
<tr class="memdesc:adcffbf0452884112fd3bcf7e7077fd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove single-dimensional entries from the shape of an xexpression.  <a href="namespacext.html#adcffbf0452884112fd3bcf7e7077fd6f">More...</a><br /></td></tr>
<tr class="separator:adcffbf0452884112fd3bcf7e7077fd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8cb55041a20cb995a15c599b7a2bc2"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:abe8cb55041a20cb995a15c599b7a2bc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#abe8cb55041a20cb995a15c599b7a2bc2">expand_dims</a> (E &amp;&amp;e, std::size_t axis)</td></tr>
<tr class="memdesc:abe8cb55041a20cb995a15c599b7a2bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the shape of an xexpression.  <a href="namespacext.html#abe8cb55041a20cb995a15c599b7a2bc2">More...</a><br /></td></tr>
<tr class="separator:abe8cb55041a20cb995a15c599b7a2bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c613dc60a31ca07c28b45337ee59b7"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, class E &gt; </td></tr>
<tr class="memitem:a66c613dc60a31ca07c28b45337ee59b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a66c613dc60a31ca07c28b45337ee59b7">atleast_Nd</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a66c613dc60a31ca07c28b45337ee59b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand dimensions of xexpression to at least <code>N</code>  <a href="namespacext.html#a66c613dc60a31ca07c28b45337ee59b7">More...</a><br /></td></tr>
<tr class="separator:a66c613dc60a31ca07c28b45337ee59b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220444924c684f9f2afbc3384a8ff09e"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a220444924c684f9f2afbc3384a8ff09e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a220444924c684f9f2afbc3384a8ff09e">atleast_1d</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a220444924c684f9f2afbc3384a8ff09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand to at least 1D.  <a href="namespacext.html#a220444924c684f9f2afbc3384a8ff09e">More...</a><br /></td></tr>
<tr class="separator:a220444924c684f9f2afbc3384a8ff09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2392e470cec79a918e975987d431c54"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ae2392e470cec79a918e975987d431c54"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae2392e470cec79a918e975987d431c54">atleast_2d</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:ae2392e470cec79a918e975987d431c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand to at least 2D.  <a href="namespacext.html#ae2392e470cec79a918e975987d431c54">More...</a><br /></td></tr>
<tr class="separator:ae2392e470cec79a918e975987d431c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9edf6c754946e30b77d9617852ed15c"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:af9edf6c754946e30b77d9617852ed15c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af9edf6c754946e30b77d9617852ed15c">atleast_3d</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:af9edf6c754946e30b77d9617852ed15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand to at least 3D.  <a href="namespacext.html#af9edf6c754946e30b77d9617852ed15c">More...</a><br /></td></tr>
<tr class="separator:af9edf6c754946e30b77d9617852ed15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5c56f6a09fb0a6ebaa2ec6cf22cf5c"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:aad5c56f6a09fb0a6ebaa2ec6cf22cf5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aad5c56f6a09fb0a6ebaa2ec6cf22cf5c">split</a> (E &amp;e, std::size_t n, std::size_t axis)</td></tr>
<tr class="memdesc:aad5c56f6a09fb0a6ebaa2ec6cf22cf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split xexpression along axis into subexpressions.  <a href="namespacext.html#aad5c56f6a09fb0a6ebaa2ec6cf22cf5c">More...</a><br /></td></tr>
<tr class="separator:aad5c56f6a09fb0a6ebaa2ec6cf22cf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af342a194380b6c7bbc7f2c89f4e88317"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:af342a194380b6c7bbc7f2c89f4e88317"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af342a194380b6c7bbc7f2c89f4e88317">hsplit</a> (E &amp;e, std::size_t n)</td></tr>
<tr class="memdesc:af342a194380b6c7bbc7f2c89f4e88317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split an xexpression into subexpressions horizontally (column-wise)  <a href="namespacext.html#af342a194380b6c7bbc7f2c89f4e88317">More...</a><br /></td></tr>
<tr class="separator:af342a194380b6c7bbc7f2c89f4e88317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25f3a38510304cf1e3489748a43812c"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ad25f3a38510304cf1e3489748a43812c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad25f3a38510304cf1e3489748a43812c">vsplit</a> (E &amp;e, std::size_t n)</td></tr>
<tr class="memdesc:ad25f3a38510304cf1e3489748a43812c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split an xexpression into subexpressions vertically (row-wise)  <a href="namespacext.html#ad25f3a38510304cf1e3489748a43812c">More...</a><br /></td></tr>
<tr class="separator:ad25f3a38510304cf1e3489748a43812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf31ad3a5950024a3825118f9f6a4e7"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a4bf31ad3a5950024a3825118f9f6a4e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a4bf31ad3a5950024a3825118f9f6a4e7">flip</a> (E &amp;&amp;e, std::size_t axis)</td></tr>
<tr class="memdesc:a4bf31ad3a5950024a3825118f9f6a4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of elements in an xexpression along the given axis.  <a href="namespacext.html#a4bf31ad3a5950024a3825118f9f6a4e7">More...</a><br /></td></tr>
<tr class="separator:a4bf31ad3a5950024a3825118f9f6a4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a947902290cc80a26e8d091428497e"><td class="memTemplParams" colspan="2">template&lt;std::ptrdiff_t N = 1, class E &gt; </td></tr>
<tr class="memitem:ab5a947902290cc80a26e8d091428497e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ab5a947902290cc80a26e8d091428497e">rot90</a> (E &amp;&amp;e, const std::array&lt; std::ptrdiff_t, 2 &gt; &amp;axes)</td></tr>
<tr class="memdesc:ab5a947902290cc80a26e8d091428497e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate an array by 90 degrees in the plane specified by axes.  <a href="namespacext.html#ab5a947902290cc80a26e8d091428497e">More...</a><br /></td></tr>
<tr class="separator:ab5a947902290cc80a26e8d091428497e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2211d25aea0f9a27855fb602419a365b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a2211d25aea0f9a27855fb602419a365b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2211d25aea0f9a27855fb602419a365b">roll</a> (E &amp;&amp;e, std::ptrdiff_t shift)</td></tr>
<tr class="memdesc:a2211d25aea0f9a27855fb602419a365b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roll an expression.  <a href="namespacext.html#a2211d25aea0f9a27855fb602419a365b">More...</a><br /></td></tr>
<tr class="separator:a2211d25aea0f9a27855fb602419a365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957635620a4f4c19c4ee0546c69fcb1d"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a957635620a4f4c19c4ee0546c69fcb1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a957635620a4f4c19c4ee0546c69fcb1d">roll</a> (E &amp;&amp;e, std::ptrdiff_t shift, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:a957635620a4f4c19c4ee0546c69fcb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Roll an expression along a given axis.  <a href="namespacext.html#a957635620a4f4c19c4ee0546c69fcb1d">More...</a><br /></td></tr>
<tr class="separator:a957635620a4f4c19c4ee0546c69fcb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b343ba5d1f6150c418475a00e3d3c3"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a86b343ba5d1f6150c418475a00e3d3c3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a86b343ba5d1f6150c418475a00e3d3c3">repeat</a> (E &amp;&amp;e, std::size_t repeats, std::size_t axis)</td></tr>
<tr class="memdesc:a86b343ba5d1f6150c418475a00e3d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats elements of an expression along a given axis.  <a href="namespacext.html#a86b343ba5d1f6150c418475a00e3d3c3">More...</a><br /></td></tr>
<tr class="separator:a86b343ba5d1f6150c418475a00e3d3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061839371ca8e1f29c37e812dee9ad1"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a0061839371ca8e1f29c37e812dee9ad1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a0061839371ca8e1f29c37e812dee9ad1">repeat</a> (E &amp;&amp;e, const std::vector&lt; std::size_t &gt; &amp;repeats, std::size_t axis)</td></tr>
<tr class="memdesc:a0061839371ca8e1f29c37e812dee9ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats elements of an expression along a given axis.  <a href="namespacext.html#a0061839371ca8e1f29c37e812dee9ad1">More...</a><br /></td></tr>
<tr class="separator:a0061839371ca8e1f29c37e812dee9ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aba37875778e4c7a786cbe6ec909ef2"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a7aba37875778e4c7a786cbe6ec909ef2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a7aba37875778e4c7a786cbe6ec909ef2">repeat</a> (E &amp;&amp;e, std::vector&lt; std::size_t &gt; &amp;&amp;repeats, std::size_t axis)</td></tr>
<tr class="memdesc:a7aba37875778e4c7a786cbe6ec909ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeats elements of an expression along a given axis.  <a href="namespacext.html#a7aba37875778e4c7a786cbe6ec909ef2">More...</a><br /></td></tr>
<tr class="separator:a7aba37875778e4c7a786cbe6ec909ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8df8c0823f064b710b90fdc73384f7"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga5a8df8c0823f064b710b90fdc73384f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga5a8df8c0823f064b710b90fdc73384f7">abs</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1abs__fun.html">math::abs_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga5a8df8c0823f064b710b90fdc73384f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value function.  <a href="group__basic__functions.html#ga5a8df8c0823f064b710b90fdc73384f7">More...</a><br /></td></tr>
<tr class="separator:ga5a8df8c0823f064b710b90fdc73384f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6548f786920ac988f0e655576b3a3c82"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga6548f786920ac988f0e655576b3a3c82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga6548f786920ac988f0e655576b3a3c82">fabs</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1fabs__fun.html">math::fabs_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga6548f786920ac988f0e655576b3a3c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute value function.  <a href="group__basic__functions.html#ga6548f786920ac988f0e655576b3a3c82">More...</a><br /></td></tr>
<tr class="separator:ga6548f786920ac988f0e655576b3a3c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51fa6991b9bc8878a763212346d6449b"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga51fa6991b9bc8878a763212346d6449b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga51fa6991b9bc8878a763212346d6449b">fmod</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1fmod__fun.html">math::fmod_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga51fa6991b9bc8878a763212346d6449b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remainder of the floating point division operation.  <a href="group__basic__functions.html#ga51fa6991b9bc8878a763212346d6449b">More...</a><br /></td></tr>
<tr class="separator:ga51fa6991b9bc8878a763212346d6449b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2322bc87a5871e26173db4b2383e1db8"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga2322bc87a5871e26173db4b2383e1db8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga2322bc87a5871e26173db4b2383e1db8">remainder</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1remainder__fun.html">math::remainder_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga2322bc87a5871e26173db4b2383e1db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed remainder of the division operation.  <a href="group__basic__functions.html#ga2322bc87a5871e26173db4b2383e1db8">More...</a><br /></td></tr>
<tr class="separator:ga2322bc87a5871e26173db4b2383e1db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f88cbfba7ddc6b5e8a1c74e422a0409"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:ga0f88cbfba7ddc6b5e8a1c74e422a0409"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga0f88cbfba7ddc6b5e8a1c74e422a0409">fma</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2, E3 &amp;&amp;e3) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1fma__fun.html">math::fma_fun</a>, E1, E2, E3 &gt;</td></tr>
<tr class="memdesc:ga0f88cbfba7ddc6b5e8a1c74e422a0409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fused multiply-add operation.  <a href="group__basic__functions.html#ga0f88cbfba7ddc6b5e8a1c74e422a0409">More...</a><br /></td></tr>
<tr class="separator:ga0f88cbfba7ddc6b5e8a1c74e422a0409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga782cdb54181f69e99679e1045cb53323"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga782cdb54181f69e99679e1045cb53323"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga782cdb54181f69e99679e1045cb53323">fmax</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1fmax__fun.html">math::fmax_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga782cdb54181f69e99679e1045cb53323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum function.  <a href="group__basic__functions.html#ga782cdb54181f69e99679e1045cb53323">More...</a><br /></td></tr>
<tr class="separator:ga782cdb54181f69e99679e1045cb53323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8eb77690d6d7b651f61a961b0b4e472"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gab8eb77690d6d7b651f61a961b0b4e472"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#gab8eb77690d6d7b651f61a961b0b4e472">fmin</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1fmin__fun.html">math::fmin_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:gab8eb77690d6d7b651f61a961b0b4e472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum function.  <a href="group__basic__functions.html#gab8eb77690d6d7b651f61a961b0b4e472">More...</a><br /></td></tr>
<tr class="separator:gab8eb77690d6d7b651f61a961b0b4e472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68f33844e1bb457b87880b7433506d3"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaa68f33844e1bb457b87880b7433506d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#gaa68f33844e1bb457b87880b7433506d3">fdim</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1fdim__fun.html">math::fdim_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:gaa68f33844e1bb457b87880b7433506d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive difference function.  <a href="group__basic__functions.html#gaa68f33844e1bb457b87880b7433506d3">More...</a><br /></td></tr>
<tr class="separator:gaa68f33844e1bb457b87880b7433506d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc991dd9cc5f66575ab91f87b140577"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga1bc991dd9cc5f66575ab91f87b140577"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga1bc991dd9cc5f66575ab91f87b140577">deg2rad</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1deg2rad.html">math::deg2rad</a>, E &gt;</td></tr>
<tr class="memdesc:ga1bc991dd9cc5f66575ab91f87b140577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert angles from degrees to radians.  <a href="group__basic__functions.html#ga1bc991dd9cc5f66575ab91f87b140577">More...</a><br /></td></tr>
<tr class="separator:ga1bc991dd9cc5f66575ab91f87b140577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bdbff83a3137d687d749c710fa466fb"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga9bdbff83a3137d687d749c710fa466fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga9bdbff83a3137d687d749c710fa466fb">radians</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1deg2rad.html">math::deg2rad</a>, E &gt;</td></tr>
<tr class="memdesc:ga9bdbff83a3137d687d749c710fa466fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert angles from degrees to radians.  <a href="group__basic__functions.html#ga9bdbff83a3137d687d749c710fa466fb">More...</a><br /></td></tr>
<tr class="separator:ga9bdbff83a3137d687d749c710fa466fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8884e81107ab3012f7604fa1826bca3"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gab8884e81107ab3012f7604fa1826bca3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#gab8884e81107ab3012f7604fa1826bca3">rad2deg</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1rad2deg.html">math::rad2deg</a>, E &gt;</td></tr>
<tr class="memdesc:gab8884e81107ab3012f7604fa1826bca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert angles from radians to degrees.  <a href="group__basic__functions.html#gab8884e81107ab3012f7604fa1826bca3">More...</a><br /></td></tr>
<tr class="separator:gab8884e81107ab3012f7604fa1826bca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4450fb9262604f2ed230e479092e7fdb"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga4450fb9262604f2ed230e479092e7fdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga4450fb9262604f2ed230e479092e7fdb">degrees</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1rad2deg.html">math::rad2deg</a>, E &gt;</td></tr>
<tr class="memdesc:ga4450fb9262604f2ed230e479092e7fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert angles from radians to degrees.  <a href="group__basic__functions.html#ga4450fb9262604f2ed230e479092e7fdb">More...</a><br /></td></tr>
<tr class="separator:ga4450fb9262604f2ed230e479092e7fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72354e9ca3d4446608c32d77d78fc721"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga72354e9ca3d4446608c32d77d78fc721"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga72354e9ca3d4446608c32d77d78fc721">maximum</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1maximum.html">math::maximum</a>&lt; void &gt;, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga72354e9ca3d4446608c32d77d78fc721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise maximum.  <a href="group__basic__functions.html#ga72354e9ca3d4446608c32d77d78fc721">More...</a><br /></td></tr>
<tr class="separator:ga72354e9ca3d4446608c32d77d78fc721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ba20f491bf0a014df5a219461ac8c98"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga6ba20f491bf0a014df5a219461ac8c98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga6ba20f491bf0a014df5a219461ac8c98">minimum</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1minimum.html">math::minimum</a>&lt; void &gt;, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga6ba20f491bf0a014df5a219461ac8c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise minimum.  <a href="group__basic__functions.html#ga6ba20f491bf0a014df5a219461ac8c98">More...</a><br /></td></tr>
<tr class="separator:ga6ba20f491bf0a014df5a219461ac8c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2087e1dd9e331edc470b4b78343f33af"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga2087e1dd9e331edc470b4b78343f33af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga2087e1dd9e331edc470b4b78343f33af">amax</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga2087e1dd9e331edc470b4b78343f33af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element along given axis.  <a href="group__basic__functions.html#ga2087e1dd9e331edc470b4b78343f33af">More...</a><br /></td></tr>
<tr class="separator:ga2087e1dd9e331edc470b4b78343f33af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc703c5c8a278274a357342f77f76c86"><td class="memTemplParams" colspan="2"><a id="acc703c5c8a278274a357342f77f76c86"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:acc703c5c8a278274a357342f77f76c86"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amax</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:acc703c5c8a278274a357342f77f76c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f0bff206771ed1d8e80bada5495242"><td class="memTemplParams" colspan="2"><a id="a88f0bff206771ed1d8e80bada5495242"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a88f0bff206771ed1d8e80bada5495242"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amax</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a88f0bff206771ed1d8e80bada5495242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54734c9bcd26a7dfcd2b7304d5b5ccbe"><td class="memTemplParams" colspan="2"><a id="a54734c9bcd26a7dfcd2b7304d5b5ccbe"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a54734c9bcd26a7dfcd2b7304d5b5ccbe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amax</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a54734c9bcd26a7dfcd2b7304d5b5ccbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab0c337a9aefb746fb8a8b6cfcb511ed"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gaab0c337a9aefb746fb8a8b6cfcb511ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#gaab0c337a9aefb746fb8a8b6cfcb511ed">amin</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:gaab0c337a9aefb746fb8a8b6cfcb511ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element along given axis.  <a href="group__basic__functions.html#gaab0c337a9aefb746fb8a8b6cfcb511ed">More...</a><br /></td></tr>
<tr class="separator:gaab0c337a9aefb746fb8a8b6cfcb511ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67737b8b97f26a34b224025b4202372e"><td class="memTemplParams" colspan="2"><a id="a67737b8b97f26a34b224025b4202372e"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a67737b8b97f26a34b224025b4202372e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amin</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a67737b8b97f26a34b224025b4202372e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a1bd1dcf0585c8a5087be35ce619c7"><td class="memTemplParams" colspan="2"><a id="ad2a1bd1dcf0585c8a5087be35ce619c7"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad2a1bd1dcf0585c8a5087be35ce619c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amin</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:ad2a1bd1dcf0585c8a5087be35ce619c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd4dad5cbc60171a9785aeb7d6842a6"><td class="memTemplParams" colspan="2"><a id="adcd4dad5cbc60171a9785aeb7d6842a6"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:adcd4dad5cbc60171a9785aeb7d6842a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>amin</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:adcd4dad5cbc60171a9785aeb7d6842a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951c830ac7329af2e6de1194821c09c4"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:ga951c830ac7329af2e6de1194821c09c4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga951c830ac7329af2e6de1194821c09c4">clip</a> (E1 &amp;&amp;e1, E2 &amp;&amp;lo, E3 &amp;&amp;hi) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1clamp__fun.html">math::clamp_fun</a>, E1, E2, E3 &gt;</td></tr>
<tr class="memdesc:ga951c830ac7329af2e6de1194821c09c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clip values between hi and lo.  <a href="group__basic__functions.html#ga951c830ac7329af2e6de1194821c09c4">More...</a><br /></td></tr>
<tr class="separator:ga951c830ac7329af2e6de1194821c09c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad678caa2e599d095ad40e2b32bf4eb37"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gad678caa2e599d095ad40e2b32bf4eb37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#gad678caa2e599d095ad40e2b32bf4eb37">sign</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1sign__fun.html">math::sign_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gad678caa2e599d095ad40e2b32bf4eb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an element-wise indication of the sign of a number.  <a href="group__basic__functions.html#gad678caa2e599d095ad40e2b32bf4eb37">More...</a><br /></td></tr>
<tr class="separator:gad678caa2e599d095ad40e2b32bf4eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c736d69056d124184aada09007e70b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gae0c736d69056d124184aada09007e70b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exp__functions.html#gae0c736d69056d124184aada09007e70b">exp</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1exp__fun.html">math::exp_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gae0c736d69056d124184aada09007e70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural exponential function.  <a href="group__exp__functions.html#gae0c736d69056d124184aada09007e70b">More...</a><br /></td></tr>
<tr class="separator:gae0c736d69056d124184aada09007e70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212886f718828e83aaf07cdabf60aeab"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga212886f718828e83aaf07cdabf60aeab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exp__functions.html#ga212886f718828e83aaf07cdabf60aeab">exp2</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1exp2__fun.html">math::exp2_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga212886f718828e83aaf07cdabf60aeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base 2 exponential function.  <a href="group__exp__functions.html#ga212886f718828e83aaf07cdabf60aeab">More...</a><br /></td></tr>
<tr class="separator:ga212886f718828e83aaf07cdabf60aeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1646ca23b54f4a72d4bbe46f1182921c"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga1646ca23b54f4a72d4bbe46f1182921c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exp__functions.html#ga1646ca23b54f4a72d4bbe46f1182921c">expm1</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1expm1__fun.html">math::expm1_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga1646ca23b54f4a72d4bbe46f1182921c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural exponential minus one function.  <a href="group__exp__functions.html#ga1646ca23b54f4a72d4bbe46f1182921c">More...</a><br /></td></tr>
<tr class="separator:ga1646ca23b54f4a72d4bbe46f1182921c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb73f780e08001206f1f9ed9db161e1"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gaaeb73f780e08001206f1f9ed9db161e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exp__functions.html#gaaeb73f780e08001206f1f9ed9db161e1">log</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1log__fun.html">math::log_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gaaeb73f780e08001206f1f9ed9db161e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural logarithm function.  <a href="group__exp__functions.html#gaaeb73f780e08001206f1f9ed9db161e1">More...</a><br /></td></tr>
<tr class="separator:gaaeb73f780e08001206f1f9ed9db161e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6585ff00a0cf0fdcdf659639e8d1ca0"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gae6585ff00a0cf0fdcdf659639e8d1ca0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exp__functions.html#gae6585ff00a0cf0fdcdf659639e8d1ca0">log10</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1log10__fun.html">math::log10_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gae6585ff00a0cf0fdcdf659639e8d1ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base 10 logarithm function.  <a href="group__exp__functions.html#gae6585ff00a0cf0fdcdf659639e8d1ca0">More...</a><br /></td></tr>
<tr class="separator:gae6585ff00a0cf0fdcdf659639e8d1ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08fcbd5914db4f5b2649f5333375d95"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gae08fcbd5914db4f5b2649f5333375d95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exp__functions.html#gae08fcbd5914db4f5b2649f5333375d95">log2</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1log2__fun.html">math::log2_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gae08fcbd5914db4f5b2649f5333375d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base 2 logarithm function.  <a href="group__exp__functions.html#gae08fcbd5914db4f5b2649f5333375d95">More...</a><br /></td></tr>
<tr class="separator:gae08fcbd5914db4f5b2649f5333375d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b8fa80ab57f38bb87e8c01b943d7f7"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga08b8fa80ab57f38bb87e8c01b943d7f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__exp__functions.html#ga08b8fa80ab57f38bb87e8c01b943d7f7">log1p</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1log1p__fun.html">math::log1p_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga08b8fa80ab57f38bb87e8c01b943d7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural logarithm of one plus function.  <a href="group__exp__functions.html#ga08b8fa80ab57f38bb87e8c01b943d7f7">More...</a><br /></td></tr>
<tr class="separator:ga08b8fa80ab57f38bb87e8c01b943d7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga726d449a0411dabbe7451c38cec235ae"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga726d449a0411dabbe7451c38cec235ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pow__functions.html#ga726d449a0411dabbe7451c38cec235ae">pow</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1pow__fun.html">math::pow_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga726d449a0411dabbe7451c38cec235ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power function.  <a href="group__pow__functions.html#ga726d449a0411dabbe7451c38cec235ae">More...</a><br /></td></tr>
<tr class="separator:ga726d449a0411dabbe7451c38cec235ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a5c38335a33c4a6f8aff517494efb"><td class="memTemplParams" colspan="2">template&lt;class F , class... E&gt; </td></tr>
<tr class="memitem:a259a5c38335a33c4a6f8aff517494efb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a259a5c38335a33c4a6f8aff517494efb">make_lambda_xfunction</a> (F &amp;&amp;lambda, E &amp;&amp;... args)</td></tr>
<tr class="memdesc:a259a5c38335a33c4a6f8aff517494efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a xfunction from a lambda.  <a href="namespacext.html#a259a5c38335a33c4a6f8aff517494efb">More...</a><br /></td></tr>
<tr class="separator:a259a5c38335a33c4a6f8aff517494efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e5fca6d456f46a946b4a9707e1d442f"><td class="memTemplParams" colspan="2">template&lt;class E1 &gt; </td></tr>
<tr class="memitem:ga6e5fca6d456f46a946b4a9707e1d442f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pow__functions.html#ga6e5fca6d456f46a946b4a9707e1d442f">square</a> (E1 &amp;&amp;e1) noexcept</td></tr>
<tr class="memdesc:ga6e5fca6d456f46a946b4a9707e1d442f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square power function, equivalent to e1 * e1.  <a href="group__pow__functions.html#ga6e5fca6d456f46a946b4a9707e1d442f">More...</a><br /></td></tr>
<tr class="separator:ga6e5fca6d456f46a946b4a9707e1d442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d98743e330f7ef3474bd706e186ac44"><td class="memTemplParams" colspan="2">template&lt;class E1 &gt; </td></tr>
<tr class="memitem:ga0d98743e330f7ef3474bd706e186ac44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pow__functions.html#ga0d98743e330f7ef3474bd706e186ac44">cube</a> (E1 &amp;&amp;e1) noexcept</td></tr>
<tr class="memdesc:ga0d98743e330f7ef3474bd706e186ac44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cube power function, equivalent to e1 * e1 * e1.  <a href="group__pow__functions.html#ga0d98743e330f7ef3474bd706e186ac44">More...</a><br /></td></tr>
<tr class="separator:ga0d98743e330f7ef3474bd706e186ac44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf15362f1892675576f2298c01e2b6b"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, class E &gt; </td></tr>
<tr class="memitem:ga9cf15362f1892675576f2298c01e2b6b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pow__functions.html#ga9cf15362f1892675576f2298c01e2b6b">pow</a> (E &amp;&amp;e) noexcept</td></tr>
<tr class="memdesc:ga9cf15362f1892675576f2298c01e2b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer power function.  <a href="group__pow__functions.html#ga9cf15362f1892675576f2298c01e2b6b">More...</a><br /></td></tr>
<tr class="separator:ga9cf15362f1892675576f2298c01e2b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ac4c9ab16cee0b95b444191419c2802"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga2ac4c9ab16cee0b95b444191419c2802"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pow__functions.html#ga2ac4c9ab16cee0b95b444191419c2802">sqrt</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1sqrt__fun.html">math::sqrt_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga2ac4c9ab16cee0b95b444191419c2802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root function.  <a href="group__pow__functions.html#ga2ac4c9ab16cee0b95b444191419c2802">More...</a><br /></td></tr>
<tr class="separator:ga2ac4c9ab16cee0b95b444191419c2802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ff49e786eca533425d6f230c945184"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gad5ff49e786eca533425d6f230c945184"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pow__functions.html#gad5ff49e786eca533425d6f230c945184">cbrt</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1cbrt__fun.html">math::cbrt_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gad5ff49e786eca533425d6f230c945184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cubic root function.  <a href="group__pow__functions.html#gad5ff49e786eca533425d6f230c945184">More...</a><br /></td></tr>
<tr class="separator:gad5ff49e786eca533425d6f230c945184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b55bcc865f0dd82fd679e01c3838526"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga9b55bcc865f0dd82fd679e01c3838526"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pow__functions.html#ga9b55bcc865f0dd82fd679e01c3838526">hypot</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1hypot__fun.html">math::hypot_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga9b55bcc865f0dd82fd679e01c3838526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypotenuse function.  <a href="group__pow__functions.html#ga9b55bcc865f0dd82fd679e01c3838526">More...</a><br /></td></tr>
<tr class="separator:ga9b55bcc865f0dd82fd679e01c3838526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8638d83d6874334a912c892b9d8a9c5"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gad8638d83d6874334a912c892b9d8a9c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__trigo__functions.html#gad8638d83d6874334a912c892b9d8a9c5">sin</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1sin__fun.html">math::sin_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gad8638d83d6874334a912c892b9d8a9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine function.  <a href="group__trigo__functions.html#gad8638d83d6874334a912c892b9d8a9c5">More...</a><br /></td></tr>
<tr class="separator:gad8638d83d6874334a912c892b9d8a9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf9e140b22bb15dc6add351a7dc06d58"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gabf9e140b22bb15dc6add351a7dc06d58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__trigo__functions.html#gabf9e140b22bb15dc6add351a7dc06d58">cos</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1cos__fun.html">math::cos_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gabf9e140b22bb15dc6add351a7dc06d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine function.  <a href="group__trigo__functions.html#gabf9e140b22bb15dc6add351a7dc06d58">More...</a><br /></td></tr>
<tr class="separator:gabf9e140b22bb15dc6add351a7dc06d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6d7aef2bb82c074da4a500ca5eadc7b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gae6d7aef2bb82c074da4a500ca5eadc7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__trigo__functions.html#gae6d7aef2bb82c074da4a500ca5eadc7b">tan</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1tan__fun.html">math::tan_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gae6d7aef2bb82c074da4a500ca5eadc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tangent function.  <a href="group__trigo__functions.html#gae6d7aef2bb82c074da4a500ca5eadc7b">More...</a><br /></td></tr>
<tr class="separator:gae6d7aef2bb82c074da4a500ca5eadc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdab214ece01511604c914f91b81fdb1"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gabdab214ece01511604c914f91b81fdb1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__trigo__functions.html#gabdab214ece01511604c914f91b81fdb1">asin</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1asin__fun.html">math::asin_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gabdab214ece01511604c914f91b81fdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arcsine function.  <a href="group__trigo__functions.html#gabdab214ece01511604c914f91b81fdb1">More...</a><br /></td></tr>
<tr class="separator:gabdab214ece01511604c914f91b81fdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef1a134c51ccdb072964383887b838c7"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gaef1a134c51ccdb072964383887b838c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__trigo__functions.html#gaef1a134c51ccdb072964383887b838c7">acos</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1acos__fun.html">math::acos_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gaef1a134c51ccdb072964383887b838c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arccosine function.  <a href="group__trigo__functions.html#gaef1a134c51ccdb072964383887b838c7">More...</a><br /></td></tr>
<tr class="separator:gaef1a134c51ccdb072964383887b838c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab62818bfe16f2dd284b39bea1a345383"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gab62818bfe16f2dd284b39bea1a345383"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__trigo__functions.html#gab62818bfe16f2dd284b39bea1a345383">atan</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1atan__fun.html">math::atan_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gab62818bfe16f2dd284b39bea1a345383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arctangent function.  <a href="group__trigo__functions.html#gab62818bfe16f2dd284b39bea1a345383">More...</a><br /></td></tr>
<tr class="separator:gab62818bfe16f2dd284b39bea1a345383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba0008974d39d88ec21dff058a642ca0"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaba0008974d39d88ec21dff058a642ca0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__trigo__functions.html#gaba0008974d39d88ec21dff058a642ca0">atan2</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1atan2__fun.html">math::atan2_fun</a>, E1, E2 &gt;</td></tr>
<tr class="memdesc:gaba0008974d39d88ec21dff058a642ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Artangent function, using signs to determine quadrants.  <a href="group__trigo__functions.html#gaba0008974d39d88ec21dff058a642ca0">More...</a><br /></td></tr>
<tr class="separator:gaba0008974d39d88ec21dff058a642ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43507ff72c11c17061fd4ae7716c11d5"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga43507ff72c11c17061fd4ae7716c11d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hyper__functions.html#ga43507ff72c11c17061fd4ae7716c11d5">sinh</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1sinh__fun.html">math::sinh_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga43507ff72c11c17061fd4ae7716c11d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic sine function.  <a href="group__hyper__functions.html#ga43507ff72c11c17061fd4ae7716c11d5">More...</a><br /></td></tr>
<tr class="separator:ga43507ff72c11c17061fd4ae7716c11d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4073cdc98201789ff723069156b4d34b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga4073cdc98201789ff723069156b4d34b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hyper__functions.html#ga4073cdc98201789ff723069156b4d34b">cosh</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1cosh__fun.html">math::cosh_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga4073cdc98201789ff723069156b4d34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic cosine function.  <a href="group__hyper__functions.html#ga4073cdc98201789ff723069156b4d34b">More...</a><br /></td></tr>
<tr class="separator:ga4073cdc98201789ff723069156b4d34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b22c94cc8d9750ca8153d9b5bbb6c86"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga1b22c94cc8d9750ca8153d9b5bbb6c86"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hyper__functions.html#ga1b22c94cc8d9750ca8153d9b5bbb6c86">tanh</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1tanh__fun.html">math::tanh_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga1b22c94cc8d9750ca8153d9b5bbb6c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic tangent function.  <a href="group__hyper__functions.html#ga1b22c94cc8d9750ca8153d9b5bbb6c86">More...</a><br /></td></tr>
<tr class="separator:ga1b22c94cc8d9750ca8153d9b5bbb6c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0893b951ad8fb1b23b97f0dae14651de"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga0893b951ad8fb1b23b97f0dae14651de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hyper__functions.html#ga0893b951ad8fb1b23b97f0dae14651de">asinh</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1asinh__fun.html">math::asinh_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga0893b951ad8fb1b23b97f0dae14651de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic sine function.  <a href="group__hyper__functions.html#ga0893b951ad8fb1b23b97f0dae14651de">More...</a><br /></td></tr>
<tr class="separator:ga0893b951ad8fb1b23b97f0dae14651de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982a251110da20b8dae705367b3ddd7e"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga982a251110da20b8dae705367b3ddd7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hyper__functions.html#ga982a251110da20b8dae705367b3ddd7e">acosh</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1acosh__fun.html">math::acosh_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga982a251110da20b8dae705367b3ddd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic cosine function.  <a href="group__hyper__functions.html#ga982a251110da20b8dae705367b3ddd7e">More...</a><br /></td></tr>
<tr class="separator:ga982a251110da20b8dae705367b3ddd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf99552b5a0d06bfd92f42f272e7af623"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gaf99552b5a0d06bfd92f42f272e7af623"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__hyper__functions.html#gaf99552b5a0d06bfd92f42f272e7af623">atanh</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1atanh__fun.html">math::atanh_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gaf99552b5a0d06bfd92f42f272e7af623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse hyperbolic tangent function.  <a href="group__hyper__functions.html#gaf99552b5a0d06bfd92f42f272e7af623">More...</a><br /></td></tr>
<tr class="separator:gaf99552b5a0d06bfd92f42f272e7af623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996f61e9186110b7daa859da0a8d2755"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga996f61e9186110b7daa859da0a8d2755"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__err__functions.html#ga996f61e9186110b7daa859da0a8d2755">erf</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1erf__fun.html">math::erf_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga996f61e9186110b7daa859da0a8d2755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error function.  <a href="group__err__functions.html#ga996f61e9186110b7daa859da0a8d2755">More...</a><br /></td></tr>
<tr class="separator:ga996f61e9186110b7daa859da0a8d2755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af9a81a9ca2bab66e744167c9683920"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga6af9a81a9ca2bab66e744167c9683920"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__err__functions.html#ga6af9a81a9ca2bab66e744167c9683920">erfc</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1erfc__fun.html">math::erfc_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga6af9a81a9ca2bab66e744167c9683920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complementary error function.  <a href="group__err__functions.html#ga6af9a81a9ca2bab66e744167c9683920">More...</a><br /></td></tr>
<tr class="separator:ga6af9a81a9ca2bab66e744167c9683920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9c5e1fc33af3db795c8b3655321f02"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gabe9c5e1fc33af3db795c8b3655321f02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__err__functions.html#gabe9c5e1fc33af3db795c8b3655321f02">tgamma</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1tgamma__fun.html">math::tgamma_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gabe9c5e1fc33af3db795c8b3655321f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gamma function.  <a href="group__err__functions.html#gabe9c5e1fc33af3db795c8b3655321f02">More...</a><br /></td></tr>
<tr class="separator:gabe9c5e1fc33af3db795c8b3655321f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5216029cd6e56b81f5145041540d043e"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga5216029cd6e56b81f5145041540d043e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__err__functions.html#ga5216029cd6e56b81f5145041540d043e">lgamma</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1lgamma__fun.html">math::lgamma_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga5216029cd6e56b81f5145041540d043e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural logarithm of the gamma function.  <a href="group__err__functions.html#ga5216029cd6e56b81f5145041540d043e">More...</a><br /></td></tr>
<tr class="separator:ga5216029cd6e56b81f5145041540d043e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d485029e29f092e60af3afabd0d154"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga06d485029e29f092e60af3afabd0d154"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nearint__functions.html#ga06d485029e29f092e60af3afabd0d154">ceil</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1ceil__fun.html">math::ceil_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga06d485029e29f092e60af3afabd0d154"><td class="mdescLeft">&#160;</td><td class="mdescRight">ceil function.  <a href="group__nearint__functions.html#ga06d485029e29f092e60af3afabd0d154">More...</a><br /></td></tr>
<tr class="separator:ga06d485029e29f092e60af3afabd0d154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga651ff45bf2ffda746e6602773925ca5c"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga651ff45bf2ffda746e6602773925ca5c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nearint__functions.html#ga651ff45bf2ffda746e6602773925ca5c">floor</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1floor__fun.html">math::floor_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga651ff45bf2ffda746e6602773925ca5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">floor function.  <a href="group__nearint__functions.html#ga651ff45bf2ffda746e6602773925ca5c">More...</a><br /></td></tr>
<tr class="separator:ga651ff45bf2ffda746e6602773925ca5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf2a5edfa5f687938657e37064ddc74"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga1bf2a5edfa5f687938657e37064ddc74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nearint__functions.html#ga1bf2a5edfa5f687938657e37064ddc74">trunc</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1trunc__fun.html">math::trunc_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga1bf2a5edfa5f687938657e37064ddc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">trunc function.  <a href="group__nearint__functions.html#ga1bf2a5edfa5f687938657e37064ddc74">More...</a><br /></td></tr>
<tr class="separator:ga1bf2a5edfa5f687938657e37064ddc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6a7ec9f215261ace43466d4ae6f0b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gaa8b6a7ec9f215261ace43466d4ae6f0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nearint__functions.html#gaa8b6a7ec9f215261ace43466d4ae6f0b">round</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1round__fun.html">math::round_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gaa8b6a7ec9f215261ace43466d4ae6f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">round function.  <a href="group__nearint__functions.html#gaa8b6a7ec9f215261ace43466d4ae6f0b">More...</a><br /></td></tr>
<tr class="separator:gaa8b6a7ec9f215261ace43466d4ae6f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga297d1cfd2029ec779f3b2caf20cae56f"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga297d1cfd2029ec779f3b2caf20cae56f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nearint__functions.html#ga297d1cfd2029ec779f3b2caf20cae56f">nearbyint</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1nearbyint__fun.html">math::nearbyint_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga297d1cfd2029ec779f3b2caf20cae56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">nearbyint function.  <a href="group__nearint__functions.html#ga297d1cfd2029ec779f3b2caf20cae56f">More...</a><br /></td></tr>
<tr class="separator:ga297d1cfd2029ec779f3b2caf20cae56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad503e7c9ee485a6b623770c8f43bde0"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gaad503e7c9ee485a6b623770c8f43bde0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nearint__functions.html#gaad503e7c9ee485a6b623770c8f43bde0">rint</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1rint__fun.html">math::rint_fun</a>, E &gt;</td></tr>
<tr class="memdesc:gaad503e7c9ee485a6b623770c8f43bde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">rint function.  <a href="group__nearint__functions.html#gaad503e7c9ee485a6b623770c8f43bde0">More...</a><br /></td></tr>
<tr class="separator:gaad503e7c9ee485a6b623770c8f43bde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177a09c77ac16a253588403fe7cbeaec"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga177a09c77ac16a253588403fe7cbeaec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__classif__functions.html#ga177a09c77ac16a253588403fe7cbeaec">isfinite</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1isfinite__fun.html">math::isfinite_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga177a09c77ac16a253588403fe7cbeaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">finite value check  <a href="group__classif__functions.html#ga177a09c77ac16a253588403fe7cbeaec">More...</a><br /></td></tr>
<tr class="separator:ga177a09c77ac16a253588403fe7cbeaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94db88dbac47fd2e3cce71c568332554"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga94db88dbac47fd2e3cce71c568332554"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__classif__functions.html#ga94db88dbac47fd2e3cce71c568332554">isinf</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1isinf__fun.html">math::isinf_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga94db88dbac47fd2e3cce71c568332554"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinity check  <a href="group__classif__functions.html#ga94db88dbac47fd2e3cce71c568332554">More...</a><br /></td></tr>
<tr class="separator:ga94db88dbac47fd2e3cce71c568332554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ec7bcedb794bccf3535bac9c3142ab"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga41ec7bcedb794bccf3535bac9c3142ab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__classif__functions.html#ga41ec7bcedb794bccf3535bac9c3142ab">isnan</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; <a class="el" href="structxt_1_1math_1_1isnan__fun.html">math::isnan_fun</a>, E &gt;</td></tr>
<tr class="memdesc:ga41ec7bcedb794bccf3535bac9c3142ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">NaN check.  <a href="group__classif__functions.html#ga41ec7bcedb794bccf3535bac9c3142ab">More...</a><br /></td></tr>
<tr class="separator:ga41ec7bcedb794bccf3535bac9c3142ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94330518c2d0f78691dc8bb4b27eb72a"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga94330518c2d0f78691dc8bb4b27eb72a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__classif__functions.html#ga94330518c2d0f78691dc8bb4b27eb72a">isclose</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2, double rtol=1e-05, double atol=1e-08, bool equal_nan=false) noexcept</td></tr>
<tr class="memdesc:ga94330518c2d0f78691dc8bb4b27eb72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise closeness detection.  <a href="group__classif__functions.html#ga94330518c2d0f78691dc8bb4b27eb72a">More...</a><br /></td></tr>
<tr class="separator:ga94330518c2d0f78691dc8bb4b27eb72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07beaa8c1b5c159ac3f6c0c09ab1e05c"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga07beaa8c1b5c159ac3f6c0c09ab1e05c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__classif__functions.html#ga07beaa8c1b5c159ac3f6c0c09ab1e05c">allclose</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2, double rtol=1e-05, double atol=1e-08) noexcept</td></tr>
<tr class="memdesc:ga07beaa8c1b5c159ac3f6c0c09ab1e05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all elements in <em>e1</em> are close to the corresponding elements in <em>e2</em>.  <a href="group__classif__functions.html#ga07beaa8c1b5c159ac3f6c0c09ab1e05c">More...</a><br /></td></tr>
<tr class="separator:ga07beaa8c1b5c159ac3f6c0c09ab1e05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga018d66d27aae0df9558107d684380436"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga018d66d27aae0df9558107d684380436"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga018d66d27aae0df9558107d684380436">sum</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga018d66d27aae0df9558107d684380436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of elements over given axes.  <a href="group__red__functions.html#ga018d66d27aae0df9558107d684380436">More...</a><br /></td></tr>
<tr class="separator:ga018d66d27aae0df9558107d684380436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fd259a55a58acb856ff8b7af66c2dc"><td class="memTemplParams" colspan="2"><a id="a11fd259a55a58acb856ff8b7af66c2dc"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a11fd259a55a58acb856ff8b7af66c2dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a11fd259a55a58acb856ff8b7af66c2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8e46637ee70415a1775e1388830857"><td class="memTemplParams" colspan="2"><a id="a5e8e46637ee70415a1775e1388830857"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5e8e46637ee70415a1775e1388830857"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a5e8e46637ee70415a1775e1388830857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95659cb8a8d1e4092ad0b96d84ac9b7a"><td class="memTemplParams" colspan="2"><a id="a95659cb8a8d1e4092ad0b96d84ac9b7a"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a95659cb8a8d1e4092ad0b96d84ac9b7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sum</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a95659cb8a8d1e4092ad0b96d84ac9b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d729a5dc08b66740997ad3e7fdb0c1"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga90d729a5dc08b66740997ad3e7fdb0c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga90d729a5dc08b66740997ad3e7fdb0c1">prod</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga90d729a5dc08b66740997ad3e7fdb0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of elements over given axes.  <a href="group__red__functions.html#ga90d729a5dc08b66740997ad3e7fdb0c1">More...</a><br /></td></tr>
<tr class="separator:ga90d729a5dc08b66740997ad3e7fdb0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651113d9294ca69f5845c07198f35c34"><td class="memTemplParams" colspan="2"><a id="a651113d9294ca69f5845c07198f35c34"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a651113d9294ca69f5845c07198f35c34"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prod</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a651113d9294ca69f5845c07198f35c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41539075d0c89a78ad6dba019594a1b"><td class="memTemplParams" colspan="2"><a id="aa41539075d0c89a78ad6dba019594a1b"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa41539075d0c89a78ad6dba019594a1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prod</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:aa41539075d0c89a78ad6dba019594a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d1c253bcc216c6379b06bee2f468bd"><td class="memTemplParams" colspan="2"><a id="a16d1c253bcc216c6379b06bee2f468bd"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a16d1c253bcc216c6379b06bee2f468bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prod</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a16d1c253bcc216c6379b06bee2f468bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0919b7cd9e5d8907363a2a146c1ec09"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gad0919b7cd9e5d8907363a2a146c1ec09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gad0919b7cd9e5d8907363a2a146c1ec09">mean</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:gad0919b7cd9e5d8907363a2a146c1ec09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean of elements over given axes.  <a href="group__red__functions.html#gad0919b7cd9e5d8907363a2a146c1ec09">More...</a><br /></td></tr>
<tr class="separator:gad0919b7cd9e5d8907363a2a146c1ec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad233792ea249a8224039dc852fcf2ade"><td class="memTemplParams" colspan="2"><a id="ad233792ea249a8224039dc852fcf2ade"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad233792ea249a8224039dc852fcf2ade"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:ad233792ea249a8224039dc852fcf2ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738f45da29e75806764a7aeb12e4da9d"><td class="memTemplParams" colspan="2"><a id="a738f45da29e75806764a7aeb12e4da9d"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a738f45da29e75806764a7aeb12e4da9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a738f45da29e75806764a7aeb12e4da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71fc60e960526979d68aece67232f82"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class W , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gac71fc60e960526979d68aece67232f82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gac71fc60e960526979d68aece67232f82">average</a> (E &amp;&amp;e, W &amp;&amp;weights, X &amp;&amp;axes, EVS ev=EVS())</td></tr>
<tr class="memdesc:gac71fc60e960526979d68aece67232f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average of elements over given axes using weights.  <a href="group__red__functions.html#gac71fc60e960526979d68aece67232f82">More...</a><br /></td></tr>
<tr class="separator:gac71fc60e960526979d68aece67232f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bacea2a5ed0909dcfe1b43c82068ad"><td class="memTemplParams" colspan="2"><a id="af2bacea2a5ed0909dcfe1b43c82068ad"></a>
template&lt;class T  = void, class E , class W , class X , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:af2bacea2a5ed0909dcfe1b43c82068ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>average</b> (E &amp;&amp;e, W &amp;&amp;weights, const X(&amp;axes)[N], EVS ev=EVS())</td></tr>
<tr class="separator:af2bacea2a5ed0909dcfe1b43c82068ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6871d93db4a9e82d2e383f69b48198e"><td class="memTemplParams" colspan="2"><a id="af6871d93db4a9e82d2e383f69b48198e"></a>
template&lt;class T  = void, class E , class W , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:af6871d93db4a9e82d2e383f69b48198e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>average</b> (E &amp;&amp;e, W &amp;&amp;weights, EVS ev=EVS())</td></tr>
<tr class="separator:af6871d93db4a9e82d2e383f69b48198e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44933bf1ec5ab20434348b25b23f537"><td class="memTemplParams" colspan="2"><a id="ac44933bf1ec5ab20434348b25b23f537"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac44933bf1ec5ab20434348b25b23f537"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>average</b> (E &amp;&amp;e, EVS ev=EVS())</td></tr>
<tr class="separator:ac44933bf1ec5ab20434348b25b23f537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3a46a64e8289bcc5731726e6a62708"><td class="memTemplParams" colspan="2"><a id="a2b3a46a64e8289bcc5731726e6a62708"></a>
template&lt;class T  = void, class E , class D , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt;, xtl::is_integral&lt; D &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2b3a46a64e8289bcc5731726e6a62708"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variance</b> (E &amp;&amp;e, D const &amp;ddof, EVS es=EVS())</td></tr>
<tr class="separator:a2b3a46a64e8289bcc5731726e6a62708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7764b85cde9f77a20033e843c1e5dc"><td class="memTemplParams" colspan="2"><a id="a1d7764b85cde9f77a20033e843c1e5dc"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1d7764b85cde9f77a20033e843c1e5dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variance</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a1d7764b85cde9f77a20033e843c1e5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78032a038d7d91f00b944b0052d035fb"><td class="memTemplParams" colspan="2"><a id="a78032a038d7d91f00b944b0052d035fb"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a78032a038d7d91f00b944b0052d035fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stddev</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a78032a038d7d91f00b944b0052d035fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7001a4fe6acde5968aa526166659a5fa"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class D , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; D &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga7001a4fe6acde5968aa526166659a5fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga7001a4fe6acde5968aa526166659a5fa">variance</a> (E &amp;&amp;e, X &amp;&amp;axes, const D &amp;ddof, EVS es=EVS())</td></tr>
<tr class="memdesc:ga7001a4fe6acde5968aa526166659a5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance along the specified axes.  <a href="group__red__functions.html#ga7001a4fe6acde5968aa526166659a5fa">More...</a><br /></td></tr>
<tr class="separator:ga7001a4fe6acde5968aa526166659a5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990a8a9f15daa11c132392335361e915"><td class="memTemplParams" colspan="2"><a id="a990a8a9f15daa11c132392335361e915"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; std::decay_t&lt; X &gt;&gt;&gt;, is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a990a8a9f15daa11c132392335361e915"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variance</b> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="separator:a990a8a9f15daa11c132392335361e915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8291754c7c050cbfac3f6eeeaa1f77"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga0c8291754c7c050cbfac3f6eeeaa1f77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga0c8291754c7c050cbfac3f6eeeaa1f77">stddev</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga0c8291754c7c050cbfac3f6eeeaa1f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation along the specified axis.  <a href="group__red__functions.html#ga0c8291754c7c050cbfac3f6eeeaa1f77">More...</a><br /></td></tr>
<tr class="separator:ga0c8291754c7c050cbfac3f6eeeaa1f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1c3e9ae5fff37de033b35a4fa4008a"><td class="memTemplParams" colspan="2"><a id="ada1c3e9ae5fff37de033b35a4fa4008a"></a>
template&lt;class T  = void, class E , class A , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:ada1c3e9ae5fff37de033b35a4fa4008a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stddev</b> (E &amp;&amp;e, const A(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:ada1c3e9ae5fff37de033b35a4fa4008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c68ed8dbe348cf12bac2a538e341a2"><td class="memTemplParams" colspan="2"><a id="a25c68ed8dbe348cf12bac2a538e341a2"></a>
template&lt;class T  = void, class E , class A , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a25c68ed8dbe348cf12bac2a538e341a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variance</b> (E &amp;&amp;e, const A(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a25c68ed8dbe348cf12bac2a538e341a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d4377f127f2fe42269b6c959d42138"><td class="memTemplParams" colspan="2"><a id="aa0d4377f127f2fe42269b6c959d42138"></a>
template&lt;class T  = void, class E , class A , std::size_t N, class D , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:aa0d4377f127f2fe42269b6c959d42138"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>variance</b> (E &amp;&amp;e, const A(&amp;axes)[N], D const &amp;ddof, EVS es=EVS())</td></tr>
<tr class="separator:aa0d4377f127f2fe42269b6c959d42138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab752be31d54ec7e45daef9a5d3868030"><td class="memTemplParams" colspan="2">template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gab752be31d54ec7e45daef9a5d3868030"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gab752be31d54ec7e45daef9a5d3868030">minmax</a> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="memdesc:gab752be31d54ec7e45daef9a5d3868030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum and maximum among the elements of an array or expression.  <a href="group__red__functions.html#gab752be31d54ec7e45daef9a5d3868030">More...</a><br /></td></tr>
<tr class="separator:gab752be31d54ec7e45daef9a5d3868030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1630a06b4975a5a759f2215e738123"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:gaae1630a06b4975a5a759f2215e738123"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__acc__functions.html#gaae1630a06b4975a5a759f2215e738123">cumsum</a> (E &amp;&amp;e, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:gaae1630a06b4975a5a759f2215e738123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative sum.  <a href="group__acc__functions.html#gaae1630a06b4975a5a759f2215e738123">More...</a><br /></td></tr>
<tr class="separator:gaae1630a06b4975a5a759f2215e738123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7460ca3b547e930f8e1fbc71f6b1f547"><td class="memTemplParams" colspan="2"><a id="a7460ca3b547e930f8e1fbc71f6b1f547"></a>
template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:a7460ca3b547e930f8e1fbc71f6b1f547"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cumsum</b> (E &amp;&amp;e)</td></tr>
<tr class="separator:a7460ca3b547e930f8e1fbc71f6b1f547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f752dbaca06608f974c3514509fa7b"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:ga17f752dbaca06608f974c3514509fa7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__acc__functions.html#ga17f752dbaca06608f974c3514509fa7b">cumprod</a> (E &amp;&amp;e, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:ga17f752dbaca06608f974c3514509fa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative product.  <a href="group__acc__functions.html#ga17f752dbaca06608f974c3514509fa7b">More...</a><br /></td></tr>
<tr class="separator:ga17f752dbaca06608f974c3514509fa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7786346be65437ebbd0028baf10af041"><td class="memTemplParams" colspan="2"><a id="a7786346be65437ebbd0028baf10af041"></a>
template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:a7786346be65437ebbd0028baf10af041"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cumprod</b> (E &amp;&amp;e)</td></tr>
<tr class="separator:a7786346be65437ebbd0028baf10af041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae82e0b56454b586ec1ffbf57d6d2122f"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gae82e0b56454b586ec1ffbf57d6d2122f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#gae82e0b56454b586ec1ffbf57d6d2122f">nan_to_num</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:gae82e0b56454b586ec1ffbf57d6d2122f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert nan or +/- inf to numbers.  <a href="group__nan__functions.html#gae82e0b56454b586ec1ffbf57d6d2122f">More...</a><br /></td></tr>
<tr class="separator:gae82e0b56454b586ec1ffbf57d6d2122f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaade983a5b6b9406608d54f3ba37a264"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gaaade983a5b6b9406608d54f3ba37a264"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#gaaade983a5b6b9406608d54f3ba37a264">nanmin</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:gaaade983a5b6b9406608d54f3ba37a264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element over given axes, excluding nans.  <a href="group__nan__functions.html#gaaade983a5b6b9406608d54f3ba37a264">More...</a><br /></td></tr>
<tr class="separator:gaaade983a5b6b9406608d54f3ba37a264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df05799eb6a4baddbe750b6ea5a9155"><td class="memTemplParams" colspan="2"><a id="a1df05799eb6a4baddbe750b6ea5a9155"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1df05799eb6a4baddbe750b6ea5a9155"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmin</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a1df05799eb6a4baddbe750b6ea5a9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bb92c4e6c8432f51294532bd34699b"><td class="memTemplParams" colspan="2"><a id="a50bb92c4e6c8432f51294532bd34699b"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a50bb92c4e6c8432f51294532bd34699b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmin</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a50bb92c4e6c8432f51294532bd34699b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba58d486f231f54aef55ec25e55aa9e5"><td class="memTemplParams" colspan="2"><a id="aba58d486f231f54aef55ec25e55aa9e5"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:aba58d486f231f54aef55ec25e55aa9e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmin</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:aba58d486f231f54aef55ec25e55aa9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e300ce1d00beec93e45d7aa0e308ceb"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga0e300ce1d00beec93e45d7aa0e308ceb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#ga0e300ce1d00beec93e45d7aa0e308ceb">nanmax</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga0e300ce1d00beec93e45d7aa0e308ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element along given axes, excluding nans.  <a href="group__nan__functions.html#ga0e300ce1d00beec93e45d7aa0e308ceb">More...</a><br /></td></tr>
<tr class="separator:ga0e300ce1d00beec93e45d7aa0e308ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849fa676cfaf5b9556f9f00c911c9f84"><td class="memTemplParams" colspan="2"><a id="a849fa676cfaf5b9556f9f00c911c9f84"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a849fa676cfaf5b9556f9f00c911c9f84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmax</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a849fa676cfaf5b9556f9f00c911c9f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74efa40492b00adc08a9097f6e64f268"><td class="memTemplParams" colspan="2"><a id="a74efa40492b00adc08a9097f6e64f268"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a74efa40492b00adc08a9097f6e64f268"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmax</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a74efa40492b00adc08a9097f6e64f268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e6ba39abf7568577735f05f67771ea"><td class="memTemplParams" colspan="2"><a id="ac9e6ba39abf7568577735f05f67771ea"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:ac9e6ba39abf7568577735f05f67771ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmax</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:ac9e6ba39abf7568577735f05f67771ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbfe228ebc452fabfdbf4067274a471a"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gadbfe228ebc452fabfdbf4067274a471a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#gadbfe228ebc452fabfdbf4067274a471a">nansum</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:gadbfe228ebc452fabfdbf4067274a471a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of elements over given axes, replacing nan with 0.  <a href="group__nan__functions.html#gadbfe228ebc452fabfdbf4067274a471a">More...</a><br /></td></tr>
<tr class="separator:gadbfe228ebc452fabfdbf4067274a471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc06ca94501cc397039d27232ed046e"><td class="memTemplParams" colspan="2"><a id="a4cc06ca94501cc397039d27232ed046e"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cc06ca94501cc397039d27232ed046e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nansum</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a4cc06ca94501cc397039d27232ed046e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8694b79311eb29bff02ec04750d6e6"><td class="memTemplParams" colspan="2"><a id="a8a8694b79311eb29bff02ec04750d6e6"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8a8694b79311eb29bff02ec04750d6e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nansum</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a8a8694b79311eb29bff02ec04750d6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a24cf8f72f927d8affbae5d189cd6e"><td class="memTemplParams" colspan="2"><a id="a67a24cf8f72f927d8affbae5d189cd6e"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a67a24cf8f72f927d8affbae5d189cd6e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nansum</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a67a24cf8f72f927d8affbae5d189cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63669d7342cc68dae7b15f3c49ca1c2"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gad63669d7342cc68dae7b15f3c49ca1c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#gad63669d7342cc68dae7b15f3c49ca1c2">nanprod</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:gad63669d7342cc68dae7b15f3c49ca1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of elements over given axes, replacing nan with 1.  <a href="group__nan__functions.html#gad63669d7342cc68dae7b15f3c49ca1c2">More...</a><br /></td></tr>
<tr class="separator:gad63669d7342cc68dae7b15f3c49ca1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad554a4c96aa2ad02c6946893b86644"><td class="memTemplParams" colspan="2"><a id="a5ad554a4c96aa2ad02c6946893b86644"></a>
template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5ad554a4c96aa2ad02c6946893b86644"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanprod</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a5ad554a4c96aa2ad02c6946893b86644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c4fcc42c8f8e6f0ab79b39f69630b8"><td class="memTemplParams" colspan="2"><a id="a27c4fcc42c8f8e6f0ab79b39f69630b8"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a27c4fcc42c8f8e6f0ab79b39f69630b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanprod</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a27c4fcc42c8f8e6f0ab79b39f69630b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0a12de643a154842b59d4f840a9b79"><td class="memTemplParams" colspan="2"><a id="a6b0a12de643a154842b59d4f840a9b79"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a6b0a12de643a154842b59d4f840a9b79"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanprod</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a6b0a12de643a154842b59d4f840a9b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532276d5a9a4a2e84558d4acc3f2b48e"><td class="memTemplParams" colspan="2"><a id="a532276d5a9a4a2e84558d4acc3f2b48e"></a>
template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a532276d5a9a4a2e84558d4acc3f2b48e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_nonzero</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a532276d5a9a4a2e84558d4acc3f2b48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26510d741b04325726c69fc0406176b"><td class="memTemplParams" colspan="2"><a id="aa26510d741b04325726c69fc0406176b"></a>
template&lt;class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa26510d741b04325726c69fc0406176b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_nonzero</b> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="separator:aa26510d741b04325726c69fc0406176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e0440fb7c503b87f4746a4456406c2"><td class="memTemplParams" colspan="2"><a id="a71e0440fb7c503b87f4746a4456406c2"></a>
template&lt;class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::is_integral&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a71e0440fb7c503b87f4746a4456406c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_nonzero</b> (E &amp;&amp;e, X axis, EVS es=EVS())</td></tr>
<tr class="separator:a71e0440fb7c503b87f4746a4456406c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09546ba6259bee2965b09a2d4a923c7a"><td class="memTemplParams" colspan="2"><a id="a09546ba6259bee2965b09a2d4a923c7a"></a>
template&lt;class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a09546ba6259bee2965b09a2d4a923c7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_nonzero</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a09546ba6259bee2965b09a2d4a923c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab150b7c211836964503f3864e5d9c4fc"><td class="memTemplParams" colspan="2"><a id="ab150b7c211836964503f3864e5d9c4fc"></a>
template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab150b7c211836964503f3864e5d9c4fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_nonnan</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:ab150b7c211836964503f3864e5d9c4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9a565ea5f9fdd54d7ea064b45e436c"><td class="memTemplParams" colspan="2"><a id="a1d9a565ea5f9fdd54d7ea064b45e436c"></a>
template&lt;class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, xtl::negation&lt; xtl::is_integral&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1d9a565ea5f9fdd54d7ea064b45e436c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_nonnan</b> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="separator:a1d9a565ea5f9fdd54d7ea064b45e436c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dfdbb218f16af1add4d1d647eb3523"><td class="memTemplParams" colspan="2"><a id="a56dfdbb218f16af1add4d1d647eb3523"></a>
template&lt;class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a56dfdbb218f16af1add4d1d647eb3523"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_nonnan</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a56dfdbb218f16af1add4d1d647eb3523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48eab6816103340e288db50e05f00e60"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:ga48eab6816103340e288db50e05f00e60"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#ga48eab6816103340e288db50e05f00e60">nancumsum</a> (E &amp;&amp;e, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:ga48eab6816103340e288db50e05f00e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative sum, replacing nan with 0.  <a href="group__nan__functions.html#ga48eab6816103340e288db50e05f00e60">More...</a><br /></td></tr>
<tr class="separator:ga48eab6816103340e288db50e05f00e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1327e7c8d5b2d1e605a980d6bac3db8"><td class="memTemplParams" colspan="2"><a id="ac1327e7c8d5b2d1e605a980d6bac3db8"></a>
template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:ac1327e7c8d5b2d1e605a980d6bac3db8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nancumsum</b> (E &amp;&amp;e)</td></tr>
<tr class="separator:ac1327e7c8d5b2d1e605a980d6bac3db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb43a2f434821dfec8464e84ad05de7"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:ga4fb43a2f434821dfec8464e84ad05de7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#ga4fb43a2f434821dfec8464e84ad05de7">nancumprod</a> (E &amp;&amp;e, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:ga4fb43a2f434821dfec8464e84ad05de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cumulative product, replacing nan with 1.  <a href="group__nan__functions.html#ga4fb43a2f434821dfec8464e84ad05de7">More...</a><br /></td></tr>
<tr class="separator:ga4fb43a2f434821dfec8464e84ad05de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e00934f5e4f7e90d71817274dd7164"><td class="memTemplParams" colspan="2"><a id="aa7e00934f5e4f7e90d71817274dd7164"></a>
template&lt;class T  = void, class E &gt; </td></tr>
<tr class="memitem:aa7e00934f5e4f7e90d71817274dd7164"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nancumprod</b> (E &amp;&amp;e)</td></tr>
<tr class="separator:aa7e00934f5e4f7e90d71817274dd7164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff43d5bf500e85b384c2c08d2ababe9"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga5ff43d5bf500e85b384c2c08d2ababe9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#ga5ff43d5bf500e85b384c2c08d2ababe9">nanmean</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga5ff43d5bf500e85b384c2c08d2ababe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean of elements over given axes, excluding nans.  <a href="group__nan__functions.html#ga5ff43d5bf500e85b384c2c08d2ababe9">More...</a><br /></td></tr>
<tr class="separator:ga5ff43d5bf500e85b384c2c08d2ababe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e19dd6f83643dbc67527625ddf7c765"><td class="memTemplParams" colspan="2"><a id="a1e19dd6f83643dbc67527625ddf7c765"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1e19dd6f83643dbc67527625ddf7c765"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmean</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a1e19dd6f83643dbc67527625ddf7c765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff05321b28a4f9b35170748d770a2f8"><td class="memTemplParams" colspan="2"><a id="aeff05321b28a4f9b35170748d770a2f8"></a>
template&lt;class T  = void, class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:aeff05321b28a4f9b35170748d770a2f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanmean</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:aeff05321b28a4f9b35170748d770a2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6932652eec5678caeaeee02fa5baab"><td class="memTemplParams" colspan="2"><a id="a0f6932652eec5678caeaeee02fa5baab"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0f6932652eec5678caeaeee02fa5baab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanvar</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a0f6932652eec5678caeaeee02fa5baab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f611c9650c30dfbf091d09e735564e4"><td class="memTemplParams" colspan="2"><a id="a8f611c9650c30dfbf091d09e735564e4"></a>
template&lt;class T  = void, class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8f611c9650c30dfbf091d09e735564e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanstd</b> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="separator:a8f611c9650c30dfbf091d09e735564e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c3fdce46c4143d595e11db1646f7d89"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga3c3fdce46c4143d595e11db1646f7d89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#ga3c3fdce46c4143d595e11db1646f7d89">nanvar</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga3c3fdce46c4143d595e11db1646f7d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance along the specified axes, excluding nans.  <a href="group__nan__functions.html#ga3c3fdce46c4143d595e11db1646f7d89">More...</a><br /></td></tr>
<tr class="separator:ga3c3fdce46c4143d595e11db1646f7d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21421ea090897548b9199c1fdb3049be"><td class="memTemplParams" colspan="2">template&lt;class T  = void, class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga21421ea090897548b9199c1fdb3049be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__nan__functions.html#ga21421ea090897548b9199c1fdb3049be">nanstd</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga21421ea090897548b9199c1fdb3049be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the standard deviation along the specified axis, excluding nans.  <a href="group__nan__functions.html#ga21421ea090897548b9199c1fdb3049be">More...</a><br /></td></tr>
<tr class="separator:ga21421ea090897548b9199c1fdb3049be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909cec773b5afb899968b195cedbe391"><td class="memTemplParams" colspan="2"><a id="a909cec773b5afb899968b195cedbe391"></a>
template&lt;class T  = void, class E , class A , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a909cec773b5afb899968b195cedbe391"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanstd</b> (E &amp;&amp;e, const A(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a909cec773b5afb899968b195cedbe391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca87d189b7067d16d2e1b5e0462e0018"><td class="memTemplParams" colspan="2"><a id="aca87d189b7067d16d2e1b5e0462e0018"></a>
template&lt;class T  = void, class E , class A , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:aca87d189b7067d16d2e1b5e0462e0018"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nanvar</b> (E &amp;&amp;e, const A(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:aca87d189b7067d16d2e1b5e0462e0018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab421eb4d3565597848ec53dad1b0d6c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab421eb4d3565597848ec53dad1b0d6c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gab421eb4d3565597848ec53dad1b0d6c6">diff</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; T &gt; &amp;a, std::size_t n=1, std::ptrdiff_t axis=-1)</td></tr>
<tr class="memdesc:gab421eb4d3565597848ec53dad1b0d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the n-th discrete difference along the given axis.  <a href="group__red__functions.html#gab421eb4d3565597848ec53dad1b0d6c6">More...</a><br /></td></tr>
<tr class="separator:gab421eb4d3565597848ec53dad1b0d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e0a7ad0979b3ceeaf99d75fd30af9d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga99e0a7ad0979b3ceeaf99d75fd30af9d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga99e0a7ad0979b3ceeaf99d75fd30af9d">trapz</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; T &gt; &amp;y, double dx=1.0, std::ptrdiff_t axis=-1)</td></tr>
<tr class="memdesc:ga99e0a7ad0979b3ceeaf99d75fd30af9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate along the given axis using the composite trapezoidal rule.  <a href="group__red__functions.html#ga99e0a7ad0979b3ceeaf99d75fd30af9d">More...</a><br /></td></tr>
<tr class="separator:ga99e0a7ad0979b3ceeaf99d75fd30af9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga681c9cbfe336a5a7892633f189098c3d"><td class="memTemplParams" colspan="2">template&lt;class T , class E &gt; </td></tr>
<tr class="memitem:ga681c9cbfe336a5a7892633f189098c3d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga681c9cbfe336a5a7892633f189098c3d">trapz</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; T &gt; &amp;y, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;x, std::ptrdiff_t axis=-1)</td></tr>
<tr class="memdesc:ga681c9cbfe336a5a7892633f189098c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate along the given axis using the composite trapezoidal rule.  <a href="group__red__functions.html#ga681c9cbfe336a5a7892633f189098c3d">More...</a><br /></td></tr>
<tr class="separator:ga681c9cbfe336a5a7892633f189098c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e1576710edcbb14d2ccf4df7d62ec3"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 , class E3 , typename T &gt; </td></tr>
<tr class="memitem:ga47e1576710edcbb14d2ccf4df7d62ec3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#ga47e1576710edcbb14d2ccf4df7d62ec3">interp</a> (const E1 &amp;x, const E2 &amp;xp, const E3 &amp;fp, T left, T right)</td></tr>
<tr class="memdesc:ga47e1576710edcbb14d2ccf4df7d62ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points (xp, fp), evaluated at x.  <a href="group__basic__functions.html#ga47e1576710edcbb14d2ccf4df7d62ec3">More...</a><br /></td></tr>
<tr class="separator:ga47e1576710edcbb14d2ccf4df7d62ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa909fc5959dbb290c47c9698d5076ed3"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:gaa909fc5959dbb290c47c9698d5076ed3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__basic__functions.html#gaa909fc5959dbb290c47c9698d5076ed3">interp</a> (const E1 &amp;x, const E2 &amp;xp, const E3 &amp;fp)</td></tr>
<tr class="memdesc:gaa909fc5959dbb290c47c9698d5076ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points (xp, fp), evaluated at x.  <a href="group__basic__functions.html#gaa909fc5959dbb290c47c9698d5076ed3">More...</a><br /></td></tr>
<tr class="separator:gaa909fc5959dbb290c47c9698d5076ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af462add746658517456f484f2e80f609"><td class="memTemplParams" colspan="2">template&lt;class E1 &gt; </td></tr>
<tr class="memitem:af462add746658517456f484f2e80f609"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af462add746658517456f484f2e80f609">cov</a> (const E1 &amp;x, const E1 &amp;y=E1())</td></tr>
<tr class="memdesc:af462add746658517456f484f2e80f609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the covariance matrix.  <a href="namespacext.html#af462add746658517456f484f2e80f609">More...</a><br /></td></tr>
<tr class="separator:af462add746658517456f484f2e80f609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab338dbfc70042116fc8a6946728544"><td class="memTemplParams" colspan="2"><a id="a9ab338dbfc70042116fc8a6946728544"></a>
template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:a9ab338dbfc70042116fc8a6946728544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_0d_table</b> (std::stringstream &amp;out, P &amp;, const T &amp;expr)</td></tr>
<tr class="separator:a9ab338dbfc70042116fc8a6946728544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf5aca4a0ede793c92b4de1570c2b4a"><td class="memTemplParams" colspan="2"><a id="a9cf5aca4a0ede793c92b4de1570c2b4a"></a>
template&lt;class P &gt; </td></tr>
<tr class="memitem:a9cf5aca4a0ede793c92b4de1570c2b4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_1d_row</b> (std::stringstream &amp;out, P &amp;printer, const std::size_t &amp;row_idx)</td></tr>
<tr class="separator:a9cf5aca4a0ede793c92b4de1570c2b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1280642c2f8875fe3a909af657702d9c"><td class="memTemplParams" colspan="2"><a id="a1280642c2f8875fe3a909af657702d9c"></a>
template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:a1280642c2f8875fe3a909af657702d9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_1d_table</b> (std::stringstream &amp;out, P &amp;printer, const T &amp;expr, const std::size_t &amp;edgeitems)</td></tr>
<tr class="separator:a1280642c2f8875fe3a909af657702d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9309afbde112dd6913b2de4445518a02"><td class="memTemplParams" colspan="2"><a id="a9309afbde112dd6913b2de4445518a02"></a>
template&lt;class P &gt; </td></tr>
<tr class="memitem:a9309afbde112dd6913b2de4445518a02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_2d_element</b> (std::stringstream &amp;out, P &amp;printer, const std::string &amp;idx_str, const std::size_t &amp;row_idx, const std::size_t &amp;column_idx)</td></tr>
<tr class="separator:a9309afbde112dd6913b2de4445518a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0987b940e8e5250b5d8ac91e973149"><td class="memTemplParams" colspan="2"><a id="a9b0987b940e8e5250b5d8ac91e973149"></a>
template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:a9b0987b940e8e5250b5d8ac91e973149"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_2d_row</b> (std::stringstream &amp;out, P &amp;printer, const T &amp;expr, const std::size_t &amp;edgeitems, const std::string &amp;idx_str, const std::size_t &amp;row_idx)</td></tr>
<tr class="separator:a9b0987b940e8e5250b5d8ac91e973149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7593d0049737ef2b5408aae585be90"><td class="memTemplParams" colspan="2"><a id="abe7593d0049737ef2b5408aae585be90"></a>
template&lt;class P , class T , class I &gt; </td></tr>
<tr class="memitem:abe7593d0049737ef2b5408aae585be90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_2d_table</b> (std::stringstream &amp;out, P &amp;printer, const T &amp;expr, const std::size_t &amp;edgeitems, const std::vector&lt; I &gt; &amp;idx)</td></tr>
<tr class="separator:abe7593d0049737ef2b5408aae585be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1576b8f54d4d38f8a0224d0a5829d"><td class="memTemplParams" colspan="2"><a id="afab1576b8f54d4d38f8a0224d0a5829d"></a>
template&lt;class P , class T , class I &gt; </td></tr>
<tr class="memitem:afab1576b8f54d4d38f8a0224d0a5829d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_nd_row</b> (std::stringstream &amp;out, P &amp;printer, const T &amp;expr, const std::size_t &amp;edgeitems, const std::vector&lt; I &gt; &amp;idx)</td></tr>
<tr class="separator:afab1576b8f54d4d38f8a0224d0a5829d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51897ca08c8e5198be73ab8701cf944d"><td class="memTemplParams" colspan="2"><a id="a51897ca08c8e5198be73ab8701cf944d"></a>
template&lt;class P , class T , class I &gt; </td></tr>
<tr class="memitem:a51897ca08c8e5198be73ab8701cf944d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_nd_table_impl</b> (std::stringstream &amp;out, P &amp;printer, const T &amp;expr, const std::size_t &amp;edgeitems, const std::vector&lt; I &gt; &amp;idx)</td></tr>
<tr class="separator:a51897ca08c8e5198be73ab8701cf944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac996882322d3d40e77a700d78d608e73"><td class="memTemplParams" colspan="2"><a id="ac996882322d3d40e77a700d78d608e73"></a>
template&lt;class P , class T &gt; </td></tr>
<tr class="memitem:ac996882322d3d40e77a700d78d608e73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_nd_table</b> (std::stringstream &amp;out, P &amp;printer, const T &amp;expr, const std::size_t &amp;edgeitems)</td></tr>
<tr class="separator:ac996882322d3d40e77a700d78d608e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29a974e4bcf96d3eb3ba7a5e7d32bce"><td class="memTemplParams" colspan="2"><a id="aa29a974e4bcf96d3eb3ba7a5e7d32bce"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:aa29a974e4bcf96d3eb3ba7a5e7d32bce"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr_impl</b> (const E &amp;expr)</td></tr>
<tr class="separator:aa29a974e4bcf96d3eb3ba7a5e7d32bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed89d8615d428e66fb5a6cec4caf15aa"><td class="memTemplParams" colspan="2"><a id="aed89d8615d428e66fb5a6cec4caf15aa"></a>
template&lt;class F , class CT &gt; </td></tr>
<tr class="memitem:aed89d8615d428e66fb5a6cec4caf15aa"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xfunctor__view.html">xfunctor_view</a>&lt; F, CT &gt; &amp;expr)</td></tr>
<tr class="separator:aed89d8615d428e66fb5a6cec4caf15aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fae79a9a18b06dbd344e31b6942022"><td class="memTemplParams" colspan="2"><a id="a20fae79a9a18b06dbd344e31b6942022"></a>
template&lt;class F , class... CT&gt; </td></tr>
<tr class="memitem:a20fae79a9a18b06dbd344e31b6942022"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xfunction.html">xfunction</a>&lt; F, CT... &gt; &amp;expr)</td></tr>
<tr class="separator:a20fae79a9a18b06dbd344e31b6942022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe94f47140a7cc0d14d83d305e1b9b6d"><td class="memTemplParams" colspan="2"><a id="afe94f47140a7cc0d14d83d305e1b9b6d"></a>
template&lt;class EC , layout_type L, class SC , class Tag &gt; </td></tr>
<tr class="memitem:afe94f47140a7cc0d14d83d305e1b9b6d"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xarray__container.html">xarray_container</a>&lt; EC, L, SC, Tag &gt; &amp;expr)</td></tr>
<tr class="separator:afe94f47140a7cc0d14d83d305e1b9b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a249184c4e47e63e6046579064b0e89"><td class="memTemplParams" colspan="2"><a id="a0a249184c4e47e63e6046579064b0e89"></a>
template&lt;class EC , std::size_t N, layout_type L, class Tag &gt; </td></tr>
<tr class="memitem:a0a249184c4e47e63e6046579064b0e89"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xtensor__container.html">xtensor_container</a>&lt; EC, N, L, Tag &gt; &amp;expr)</td></tr>
<tr class="separator:a0a249184c4e47e63e6046579064b0e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b9193b7ad2564949faf2ee2cec6d30"><td class="memTemplParams" colspan="2"><a id="ae3b9193b7ad2564949faf2ee2cec6d30"></a>
template&lt;class ET , class S , layout_type L, bool SH, class Tag &gt; </td></tr>
<tr class="memitem:ae3b9193b7ad2564949faf2ee2cec6d30"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xfixed__container.html">xfixed_container</a>&lt; ET, S, L, SH, Tag &gt; &amp;expr)</td></tr>
<tr class="separator:ae3b9193b7ad2564949faf2ee2cec6d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6332c5c91da421761fd31cf59817326"><td class="memTemplParams" colspan="2"><a id="ab6332c5c91da421761fd31cf59817326"></a>
template&lt;class F , class CT , class X , class O &gt; </td></tr>
<tr class="memitem:ab6332c5c91da421761fd31cf59817326"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xreducer.html">xreducer</a>&lt; F, CT, X, O &gt; &amp;expr)</td></tr>
<tr class="separator:ab6332c5c91da421761fd31cf59817326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc327f0dd96000d31a1a5c0172a24132"><td class="memTemplParams" colspan="2"><a id="acc327f0dd96000d31a1a5c0172a24132"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:acc327f0dd96000d31a1a5c0172a24132"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xoptional__assembly.html">xoptional_assembly</a>&lt; VE, FE &gt; &amp;expr)</td></tr>
<tr class="separator:acc327f0dd96000d31a1a5c0172a24132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20115d96071031eefe37d89a77492c26"><td class="memTemplParams" colspan="2"><a id="a20115d96071031eefe37d89a77492c26"></a>
template&lt;class VEC , class FEC &gt; </td></tr>
<tr class="memitem:a20115d96071031eefe37d89a77492c26"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xoptional__assembly__adaptor.html">xoptional_assembly_adaptor</a>&lt; VEC, FEC &gt; &amp;expr)</td></tr>
<tr class="separator:a20115d96071031eefe37d89a77492c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbda10dadad4d4d02561df769551032"><td class="memTemplParams" colspan="2"><a id="aabbda10dadad4d4d02561df769551032"></a>
template&lt;class CT &gt; </td></tr>
<tr class="memitem:aabbda10dadad4d4d02561df769551032"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xscalar.html">xscalar</a>&lt; CT &gt; &amp;expr)</td></tr>
<tr class="separator:aabbda10dadad4d4d02561df769551032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747d4ad1570e7b6d9a9d0d46393b974"><td class="memTemplParams" colspan="2"><a id="ae747d4ad1570e7b6d9a9d0d46393b974"></a>
template&lt;class CT , class X &gt; </td></tr>
<tr class="memitem:ae747d4ad1570e7b6d9a9d0d46393b974"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xbroadcast.html">xbroadcast</a>&lt; CT, X &gt; &amp;expr)</td></tr>
<tr class="separator:ae747d4ad1570e7b6d9a9d0d46393b974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec18023a9d73e60f3d2a3fc4811935c"><td class="memTemplParams" colspan="2"><a id="aaec18023a9d73e60f3d2a3fc4811935c"></a>
template&lt;class F , class R , class S &gt; </td></tr>
<tr class="memitem:aaec18023a9d73e60f3d2a3fc4811935c"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xgenerator.html">xgenerator</a>&lt; F, R, S &gt; &amp;expr)</td></tr>
<tr class="separator:aaec18023a9d73e60f3d2a3fc4811935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cc9aa59d0fd96112fe4aad26994cd4"><td class="memTemplParams" colspan="2"><a id="ab4cc9aa59d0fd96112fe4aad26994cd4"></a>
template&lt;class CT , class... S&gt; </td></tr>
<tr class="memitem:ab4cc9aa59d0fd96112fe4aad26994cd4"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xview.html">xview</a>&lt; CT, S... &gt; &amp;expr)</td></tr>
<tr class="separator:ab4cc9aa59d0fd96112fe4aad26994cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40038c6db9d3c7484b083ec5dcae125"><td class="memTemplParams" colspan="2"><a id="ad40038c6db9d3c7484b083ec5dcae125"></a>
template&lt;class CT , class S , layout_type L, class FST &gt; </td></tr>
<tr class="memitem:ad40038c6db9d3c7484b083ec5dcae125"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xstrided__view.html">xstrided_view</a>&lt; CT, S, L, FST &gt; &amp;expr)</td></tr>
<tr class="separator:ad40038c6db9d3c7484b083ec5dcae125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4143dfc690aadbe17119ff716bafa409"><td class="memTemplParams" colspan="2"><a id="a4143dfc690aadbe17119ff716bafa409"></a>
template&lt;class CTD , class CTM &gt; </td></tr>
<tr class="memitem:a4143dfc690aadbe17119ff716bafa409"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xmasked__view.html">xmasked_view</a>&lt; CTD, CTM &gt; &amp;expr)</td></tr>
<tr class="separator:a4143dfc690aadbe17119ff716bafa409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e39d2ac050b1a3302c45c6d346a01f"><td class="memTemplParams" colspan="2"><a id="a57e39d2ac050b1a3302c45c6d346a01f"></a>
template&lt;class T , class B &gt; </td></tr>
<tr class="memitem:a57e39d2ac050b1a3302c45c6d346a01f"><td class="memTemplItemLeft" align="right" valign="top">nlohmann::json&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mime_bundle_repr</b> (const <a class="el" href="classxt_1_1xmasked__value.html">xmasked_value</a>&lt; T, B &gt; &amp;v)</td></tr>
<tr class="separator:a57e39d2ac050b1a3302c45c6d346a01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386882508a26fe05a3d3a9de54f9bcd5"><td class="memTemplParams" colspan="2"><a id="a386882508a26fe05a3d3a9de54f9bcd5"></a>
template&lt;class A &gt; </td></tr>
<tr class="memitem:a386882508a26fe05a3d3a9de54f9bcd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1noalias__proxy.html">noalias_proxy</a>&lt; xtl::closure_type_t&lt; A &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>noalias</b> (A &amp;&amp;a) noexcept</td></tr>
<tr class="separator:a386882508a26fe05a3d3a9de54f9bcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29e1eba5e05138bd5db7bfc577215f1"><td class="memTemplParams" colspan="2">template&lt;class E , class X , class EVS , class &gt; </td></tr>
<tr class="memitem:gad29e1eba5e05138bd5db7bfc577215f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gad29e1eba5e05138bd5db7bfc577215f1">norm_l0</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es) noexcept</td></tr>
<tr class="memdesc:gad29e1eba5e05138bd5db7bfc577215f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">L0 (count) pseudo-norm of an array-like argument over given axes.  <a href="group__red__functions.html#gad29e1eba5e05138bd5db7bfc577215f1">More...</a><br /></td></tr>
<tr class="separator:gad29e1eba5e05138bd5db7bfc577215f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75c1f16a4c45c0ded05f6a50f8245385"><td class="memTemplParams" colspan="2">template&lt;class E , class X , class EVS , class &gt; </td></tr>
<tr class="memitem:ga75c1f16a4c45c0ded05f6a50f8245385"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga75c1f16a4c45c0ded05f6a50f8245385">norm_l1</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es) noexcept</td></tr>
<tr class="memdesc:ga75c1f16a4c45c0ded05f6a50f8245385"><td class="mdescLeft">&#160;</td><td class="mdescRight">L1 norm of an array-like argument over given axes.  <a href="group__red__functions.html#ga75c1f16a4c45c0ded05f6a50f8245385">More...</a><br /></td></tr>
<tr class="separator:ga75c1f16a4c45c0ded05f6a50f8245385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga243ff01254cf5c1bcfe3ef6b6b67331d"><td class="memTemplParams" colspan="2">template&lt;class E , class X , class EVS , class &gt; </td></tr>
<tr class="memitem:ga243ff01254cf5c1bcfe3ef6b6b67331d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga243ff01254cf5c1bcfe3ef6b6b67331d">norm_sq</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es) noexcept</td></tr>
<tr class="memdesc:ga243ff01254cf5c1bcfe3ef6b6b67331d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared L2 norm of an array-like argument over given axes.  <a href="group__red__functions.html#ga243ff01254cf5c1bcfe3ef6b6b67331d">More...</a><br /></td></tr>
<tr class="separator:ga243ff01254cf5c1bcfe3ef6b6b67331d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612264ac7b3ed369ebe6da569e2bf7f5"><td class="memTemplParams" colspan="2">template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_xexpression&lt; E &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga612264ac7b3ed369ebe6da569e2bf7f5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga612264ac7b3ed369ebe6da569e2bf7f5">norm_l2</a> (E &amp;&amp;e, EVS es=EVS()) noexcept</td></tr>
<tr class="memdesc:ga612264ac7b3ed369ebe6da569e2bf7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2 norm of a scalar or array-like argument.  <a href="group__red__functions.html#ga612264ac7b3ed369ebe6da569e2bf7f5">More...</a><br /></td></tr>
<tr class="separator:ga612264ac7b3ed369ebe6da569e2bf7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d838a048615ed661350fcd7af66d06"><td class="memTemplParams" colspan="2">template&lt;class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_xexpression&lt; E &gt;, xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gad8d838a048615ed661350fcd7af66d06"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gad8d838a048615ed661350fcd7af66d06">norm_l2</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es=EVS()) noexcept</td></tr>
<tr class="memdesc:gad8d838a048615ed661350fcd7af66d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">L2 norm of an array-like argument over given axes.  <a href="group__red__functions.html#gad8d838a048615ed661350fcd7af66d06">More...</a><br /></td></tr>
<tr class="separator:gad8d838a048615ed661350fcd7af66d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b49f1121f7455240138eef89431032"><td class="memTemplParams" colspan="2"><a id="ac1b49f1121f7455240138eef89431032"></a>
template&lt;class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:ac1b49f1121f7455240138eef89431032"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm_l2</b> (E &amp;&amp;e, const I(&amp;axes)[N], EVS es=EVS()) noexcept</td></tr>
<tr class="separator:ac1b49f1121f7455240138eef89431032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3987362169c6b7f82dc4acaa012c65f"><td class="memTemplParams" colspan="2">template&lt;class E , class X , class EVS , class &gt; </td></tr>
<tr class="memitem:gad3987362169c6b7f82dc4acaa012c65f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gad3987362169c6b7f82dc4acaa012c65f">norm_linf</a> (E &amp;&amp;e, X &amp;&amp;axes, EVS es) noexcept</td></tr>
<tr class="memdesc:gad3987362169c6b7f82dc4acaa012c65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinity (maximum) norm of an array-like argument over given axes.  <a href="group__red__functions.html#gad3987362169c6b7f82dc4acaa012c65f">More...</a><br /></td></tr>
<tr class="separator:gad3987362169c6b7f82dc4acaa012c65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1062bcc8bc659e9a09a5816626d5575"><td class="memTemplParams" colspan="2">template&lt;class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:gaa1062bcc8bc659e9a09a5816626d5575"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#gaa1062bcc8bc659e9a09a5816626d5575">norm_lp_to_p</a> (E &amp;&amp;e, double p, X &amp;&amp;axes, EVS es=EVS()) noexcept</td></tr>
<tr class="memdesc:gaa1062bcc8bc659e9a09a5816626d5575"><td class="mdescLeft">&#160;</td><td class="mdescRight">p-th power of the Lp norm of an array-like argument over given axes.  <a href="group__red__functions.html#gaa1062bcc8bc659e9a09a5816626d5575">More...</a><br /></td></tr>
<tr class="separator:gaa1062bcc8bc659e9a09a5816626d5575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe9b481e942af70ba6d26010bf4339a"><td class="memTemplParams" colspan="2"><a id="adbe9b481e942af70ba6d26010bf4339a"></a>
template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_xexpression&lt; E &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:adbe9b481e942af70ba6d26010bf4339a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm_lp_to_p</b> (E &amp;&amp;e, double p, EVS es=EVS()) noexcept</td></tr>
<tr class="separator:adbe9b481e942af70ba6d26010bf4339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8b1800173e2d4a5971b05edd544050"><td class="memTemplParams" colspan="2"><a id="a3f8b1800173e2d4a5971b05edd544050"></a>
template&lt;class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a3f8b1800173e2d4a5971b05edd544050"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm_lp_to_p</b> (E &amp;&amp;e, double p, const I(&amp;axes)[N], EVS es=EVS()) noexcept</td></tr>
<tr class="separator:a3f8b1800173e2d4a5971b05edd544050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f5622197f95e83dafec8394265fd750"><td class="memTemplParams" colspan="2">template&lt;class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga4f5622197f95e83dafec8394265fd750"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga4f5622197f95e83dafec8394265fd750">norm_lp</a> (E &amp;&amp;e, double p, X &amp;&amp;axes, EVS es=EVS())</td></tr>
<tr class="memdesc:ga4f5622197f95e83dafec8394265fd750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lp norm of an array-like argument over given axes.  <a href="group__red__functions.html#ga4f5622197f95e83dafec8394265fd750">More...</a><br /></td></tr>
<tr class="separator:ga4f5622197f95e83dafec8394265fd750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdeb024d8cac3017df8806813ea23d0"><td class="memTemplParams" colspan="2"><a id="a7bdeb024d8cac3017df8806813ea23d0"></a>
template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_xexpression&lt; E &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7bdeb024d8cac3017df8806813ea23d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm_lp</b> (E &amp;&amp;e, double p, EVS es=EVS())</td></tr>
<tr class="separator:a7bdeb024d8cac3017df8806813ea23d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf4a1114141d3680adfe5b481662c3a"><td class="memTemplParams" colspan="2"><a id="a2bf4a1114141d3680adfe5b481662c3a"></a>
template&lt;class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;&gt; </td></tr>
<tr class="memitem:a2bf4a1114141d3680adfe5b481662c3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm_lp</b> (E &amp;&amp;e, double p, const I(&amp;axes)[N], EVS es=EVS())</td></tr>
<tr class="separator:a2bf4a1114141d3680adfe5b481662c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6756e0125ea6eaf41da4d72c863222ad"><td class="memTemplParams" colspan="2">template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_xexpression&lt; E &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga6756e0125ea6eaf41da4d72c863222ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga6756e0125ea6eaf41da4d72c863222ad">norm_induced_l1</a> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="memdesc:ga6756e0125ea6eaf41da4d72c863222ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Induced L1 norm of a matrix.  <a href="group__red__functions.html#ga6756e0125ea6eaf41da4d72c863222ad">More...</a><br /></td></tr>
<tr class="separator:ga6756e0125ea6eaf41da4d72c863222ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32553e96de228c6a760ea1e7eac51dbd"><td class="memTemplParams" colspan="2">template&lt;class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_xexpression&lt; E &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ga32553e96de228c6a760ea1e7eac51dbd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__red__functions.html#ga32553e96de228c6a760ea1e7eac51dbd">norm_induced_linf</a> (E &amp;&amp;e, EVS es=EVS())</td></tr>
<tr class="memdesc:ga32553e96de228c6a760ea1e7eac51dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Induced L-infinity norm of a matrix.  <a href="group__red__functions.html#ga32553e96de228c6a760ea1e7eac51dbd">More...</a><br /></td></tr>
<tr class="separator:ga32553e96de228c6a760ea1e7eac51dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb704b012b5b4a60523e183342660a8"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:abbb704b012b5b4a60523e183342660a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#abbb704b012b5b4a60523e183342660a8">dump_npy</a> (const std::string &amp;filename, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="memdesc:abbb704b012b5b4a60523e183342660a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save xexpression to NumPy npy format.  <a href="namespacext.html#abbb704b012b5b4a60523e183342660a8">More...</a><br /></td></tr>
<tr class="separator:abbb704b012b5b4a60523e183342660a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d48f3428b263994fcfb707ca476847e"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a6d48f3428b263994fcfb707ca476847e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a6d48f3428b263994fcfb707ca476847e">dump_npy</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="memdesc:a6d48f3428b263994fcfb707ca476847e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save xexpression to NumPy npy format in a string.  <a href="namespacext.html#a6d48f3428b263994fcfb707ca476847e">More...</a><br /></td></tr>
<tr class="separator:a6d48f3428b263994fcfb707ca476847e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f40ac64487910bfee944c044c9739c"><td class="memTemplParams" colspan="2">template&lt;typename T , layout_type L = layout_type::dynamic&gt; </td></tr>
<tr class="memitem:a09f40ac64487910bfee944c044c9739c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a09f40ac64487910bfee944c044c9739c">load_npy</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:a09f40ac64487910bfee944c044c9739c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a npy file (the numpy storage format)  <a href="namespacext.html#a09f40ac64487910bfee944c044c9739c">More...</a><br /></td></tr>
<tr class="separator:a09f40ac64487910bfee944c044c9739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2466a03b0fed69ae73a2e01490af1fec"><td class="memTemplParams" colspan="2">template&lt;typename T , layout_type L = layout_type::dynamic&gt; </td></tr>
<tr class="memitem:a2466a03b0fed69ae73a2e01490af1fec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2466a03b0fed69ae73a2e01490af1fec">load_npy</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a2466a03b0fed69ae73a2e01490af1fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a npy file (the numpy storage format)  <a href="namespacext.html#a2466a03b0fed69ae73a2e01490af1fec">More...</a><br /></td></tr>
<tr class="separator:a2466a03b0fed69ae73a2e01490af1fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f6fda1324731f7d8c7bedfd786fd711"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga4f6fda1324731f7d8c7bedfd786fd711"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__operators.html#ga4f6fda1324731f7d8c7bedfd786fd711">operator+</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; detail::identity, E &gt;</td></tr>
<tr class="memdesc:ga4f6fda1324731f7d8c7bedfd786fd711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity.  <a href="group__arithmetic__operators.html#ga4f6fda1324731f7d8c7bedfd786fd711">More...</a><br /></td></tr>
<tr class="separator:ga4f6fda1324731f7d8c7bedfd786fd711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9984fddddb53d90fcef38c017ebb5c9"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gae9984fddddb53d90fcef38c017ebb5c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__operators.html#gae9984fddddb53d90fcef38c017ebb5c9">operator-</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; detail::negate, E &gt;</td></tr>
<tr class="memdesc:gae9984fddddb53d90fcef38c017ebb5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opposite.  <a href="group__arithmetic__operators.html#gae9984fddddb53d90fcef38c017ebb5c9">More...</a><br /></td></tr>
<tr class="separator:gae9984fddddb53d90fcef38c017ebb5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0012dd54e6eddb1dc1499bda3835fc"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga3a0012dd54e6eddb1dc1499bda3835fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__operators.html#ga3a0012dd54e6eddb1dc1499bda3835fc">operator+</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::plus, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga3a0012dd54e6eddb1dc1499bda3835fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition.  <a href="group__arithmetic__operators.html#ga3a0012dd54e6eddb1dc1499bda3835fc">More...</a><br /></td></tr>
<tr class="separator:ga3a0012dd54e6eddb1dc1499bda3835fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc7da6c96325690024067869af4e3bf"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gadcc7da6c96325690024067869af4e3bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__operators.html#gadcc7da6c96325690024067869af4e3bf">operator-</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::minus, E1, E2 &gt;</td></tr>
<tr class="memdesc:gadcc7da6c96325690024067869af4e3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substraction.  <a href="group__arithmetic__operators.html#gadcc7da6c96325690024067869af4e3bf">More...</a><br /></td></tr>
<tr class="separator:gadcc7da6c96325690024067869af4e3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee209a211df9c1fdd671fe786c01eca6"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaee209a211df9c1fdd671fe786c01eca6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__operators.html#gaee209a211df9c1fdd671fe786c01eca6">operator*</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::multiplies, E1, E2 &gt;</td></tr>
<tr class="memdesc:gaee209a211df9c1fdd671fe786c01eca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication.  <a href="group__arithmetic__operators.html#gaee209a211df9c1fdd671fe786c01eca6">More...</a><br /></td></tr>
<tr class="separator:gaee209a211df9c1fdd671fe786c01eca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9e3cca169a86ea0974e67d562f7f8c"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga5c9e3cca169a86ea0974e67d562f7f8c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__operators.html#ga5c9e3cca169a86ea0974e67d562f7f8c">operator/</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::divides, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga5c9e3cca169a86ea0974e67d562f7f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division.  <a href="group__arithmetic__operators.html#ga5c9e3cca169a86ea0974e67d562f7f8c">More...</a><br /></td></tr>
<tr class="separator:ga5c9e3cca169a86ea0974e67d562f7f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3c78e8ff8a284881563ccbdd64bf145"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaa3c78e8ff8a284881563ccbdd64bf145"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__arithmetic__operators.html#gaa3c78e8ff8a284881563ccbdd64bf145">operator%</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::modulus, E1, E2 &gt;</td></tr>
<tr class="memdesc:gaa3c78e8ff8a284881563ccbdd64bf145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modulus.  <a href="group__arithmetic__operators.html#gaa3c78e8ff8a284881563ccbdd64bf145">More...</a><br /></td></tr>
<tr class="separator:gaa3c78e8ff8a284881563ccbdd64bf145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fb5db8b5da410253c08053a1c9c518"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gab0fb5db8b5da410253c08053a1c9c518"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#gab0fb5db8b5da410253c08053a1c9c518">operator||</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::logical_or, E1, E2 &gt;</td></tr>
<tr class="memdesc:gab0fb5db8b5da410253c08053a1c9c518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Or.  <a href="group__logical__operators.html#gab0fb5db8b5da410253c08053a1c9c518">More...</a><br /></td></tr>
<tr class="separator:gab0fb5db8b5da410253c08053a1c9c518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f7645635520ba70e7d0d9b0e989205"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga95f7645635520ba70e7d0d9b0e989205"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga95f7645635520ba70e7d0d9b0e989205">operator&amp;&amp;</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::logical_and, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga95f7645635520ba70e7d0d9b0e989205"><td class="mdescLeft">&#160;</td><td class="mdescRight">And.  <a href="group__logical__operators.html#ga95f7645635520ba70e7d0d9b0e989205">More...</a><br /></td></tr>
<tr class="separator:ga95f7645635520ba70e7d0d9b0e989205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669c5968e594e618cd199674074c32e4"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga669c5968e594e618cd199674074c32e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga669c5968e594e618cd199674074c32e4">operator!</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; detail::logical_not, E &gt;</td></tr>
<tr class="memdesc:ga669c5968e594e618cd199674074c32e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not.  <a href="group__logical__operators.html#ga669c5968e594e618cd199674074c32e4">More...</a><br /></td></tr>
<tr class="separator:ga669c5968e594e618cd199674074c32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0084d8f6f0f513d35a35e79f7fffc2fb"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga0084d8f6f0f513d35a35e79f7fffc2fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#ga0084d8f6f0f513d35a35e79f7fffc2fb">operator&amp;</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::bitwise_and, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga0084d8f6f0f513d35a35e79f7fffc2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise and.  <a href="group__bitwise__operators.html#ga0084d8f6f0f513d35a35e79f7fffc2fb">More...</a><br /></td></tr>
<tr class="separator:ga0084d8f6f0f513d35a35e79f7fffc2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1e3650f1eae70c7ab951cce7df0b7ac"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gac1e3650f1eae70c7ab951cce7df0b7ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#gac1e3650f1eae70c7ab951cce7df0b7ac">operator|</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::bitwise_or, E1, E2 &gt;</td></tr>
<tr class="memdesc:gac1e3650f1eae70c7ab951cce7df0b7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise or.  <a href="group__bitwise__operators.html#gac1e3650f1eae70c7ab951cce7df0b7ac">More...</a><br /></td></tr>
<tr class="separator:gac1e3650f1eae70c7ab951cce7df0b7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c9a2b613116854aa104a4005f2a0f4"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga85c9a2b613116854aa104a4005f2a0f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#ga85c9a2b613116854aa104a4005f2a0f4">operator^</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::bitwise_xor, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga85c9a2b613116854aa104a4005f2a0f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise xor.  <a href="group__bitwise__operators.html#ga85c9a2b613116854aa104a4005f2a0f4">More...</a><br /></td></tr>
<tr class="separator:ga85c9a2b613116854aa104a4005f2a0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f9831f1f2da86982f23d8e4e45e3db"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga61f9831f1f2da86982f23d8e4e45e3db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#ga61f9831f1f2da86982f23d8e4e45e3db">operator~</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; detail::bitwise_not, E &gt;</td></tr>
<tr class="memdesc:ga61f9831f1f2da86982f23d8e4e45e3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise not.  <a href="group__bitwise__operators.html#ga61f9831f1f2da86982f23d8e4e45e3db">More...</a><br /></td></tr>
<tr class="separator:ga61f9831f1f2da86982f23d8e4e45e3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cd49affcc3745f02fbb43f1bed16ed1"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga2cd49affcc3745f02fbb43f1bed16ed1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#ga2cd49affcc3745f02fbb43f1bed16ed1">left_shift</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::left_shift, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga2cd49affcc3745f02fbb43f1bed16ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift.  <a href="group__bitwise__operators.html#ga2cd49affcc3745f02fbb43f1bed16ed1">More...</a><br /></td></tr>
<tr class="separator:ga2cd49affcc3745f02fbb43f1bed16ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eab76876895cd0cae2a667e513c9f92"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga2eab76876895cd0cae2a667e513c9f92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#ga2eab76876895cd0cae2a667e513c9f92">right_shift</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::right_shift, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga2eab76876895cd0cae2a667e513c9f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift.  <a href="group__bitwise__operators.html#ga2eab76876895cd0cae2a667e513c9f92">More...</a><br /></td></tr>
<tr class="separator:ga2eab76876895cd0cae2a667e513c9f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b48fdbaa2c12656338470eb3cc5c8e"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaa7b48fdbaa2c12656338470eb3cc5c8e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#gaa7b48fdbaa2c12656338470eb3cc5c8e">operator&lt;&lt;</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::shift_return_type_t&lt; detail::left_shift, E1, E2 &gt;</td></tr>
<tr class="memdesc:gaa7b48fdbaa2c12656338470eb3cc5c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise left shift.  <a href="group__bitwise__operators.html#gaa7b48fdbaa2c12656338470eb3cc5c8e">More...</a><br /></td></tr>
<tr class="separator:gaa7b48fdbaa2c12656338470eb3cc5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace6ce969d4a7bdee37e410309448df92"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gace6ce969d4a7bdee37e410309448df92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bitwise__operators.html#gace6ce969d4a7bdee37e410309448df92">operator&gt;&gt;</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) -&gt; detail::shift_return_type_t&lt; detail::right_shift, E1, E2 &gt;</td></tr>
<tr class="memdesc:gace6ce969d4a7bdee37e410309448df92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitwise right shift.  <a href="group__bitwise__operators.html#gace6ce969d4a7bdee37e410309448df92">More...</a><br /></td></tr>
<tr class="separator:gace6ce969d4a7bdee37e410309448df92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2adbdc9609fe51aa3e50955fe039ba67"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga2adbdc9609fe51aa3e50955fe039ba67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga2adbdc9609fe51aa3e50955fe039ba67">operator&lt;</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::less, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga2adbdc9609fe51aa3e50955fe039ba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lesser than.  <a href="group__comparison__operators.html#ga2adbdc9609fe51aa3e50955fe039ba67">More...</a><br /></td></tr>
<tr class="separator:ga2adbdc9609fe51aa3e50955fe039ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b3cb0fe146e5a95a750a1291bfdcca"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaf7b3cb0fe146e5a95a750a1291bfdcca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#gaf7b3cb0fe146e5a95a750a1291bfdcca">operator&lt;=</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::less_equal, E1, E2 &gt;</td></tr>
<tr class="memdesc:gaf7b3cb0fe146e5a95a750a1291bfdcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lesser or equal.  <a href="group__comparison__operators.html#gaf7b3cb0fe146e5a95a750a1291bfdcca">More...</a><br /></td></tr>
<tr class="separator:gaf7b3cb0fe146e5a95a750a1291bfdcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3addaced4bd7bdacea4a842d9d6c850a"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga3addaced4bd7bdacea4a842d9d6c850a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga3addaced4bd7bdacea4a842d9d6c850a">operator&gt;</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::greater, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga3addaced4bd7bdacea4a842d9d6c850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than.  <a href="group__comparison__operators.html#ga3addaced4bd7bdacea4a842d9d6c850a">More...</a><br /></td></tr>
<tr class="separator:ga3addaced4bd7bdacea4a842d9d6c850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40baca1e4f53789261cd3e8736a98ef"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaa40baca1e4f53789261cd3e8736a98ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#gaa40baca1e4f53789261cd3e8736a98ef">operator&gt;=</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::greater_equal, E1, E2 &gt;</td></tr>
<tr class="memdesc:gaa40baca1e4f53789261cd3e8736a98ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater or equal.  <a href="group__comparison__operators.html#gaa40baca1e4f53789261cd3e8736a98ef">More...</a><br /></td></tr>
<tr class="separator:gaa40baca1e4f53789261cd3e8736a98ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d14e885233442e054ca0a7dd72ef895"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga5d14e885233442e054ca0a7dd72ef895"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structxt_1_1xoptional__comparable.html">xoptional_comparable</a>&lt; E1, E2 &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga5d14e885233442e054ca0a7dd72ef895">operator==</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;e1, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;e2)</td></tr>
<tr class="memdesc:ga5d14e885233442e054ca0a7dd72ef895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality.  <a href="group__comparison__operators.html#ga5d14e885233442e054ca0a7dd72ef895">More...</a><br /></td></tr>
<tr class="separator:ga5d14e885233442e054ca0a7dd72ef895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae699c5c8cda32f45372da2daee9a9b4"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:gaae699c5c8cda32f45372da2daee9a9b4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#gaae699c5c8cda32f45372da2daee9a9b4">operator!=</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;e1, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;e2)</td></tr>
<tr class="memdesc:gaae699c5c8cda32f45372da2daee9a9b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality.  <a href="group__comparison__operators.html#gaae699c5c8cda32f45372da2daee9a9b4">More...</a><br /></td></tr>
<tr class="separator:gaae699c5c8cda32f45372da2daee9a9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c778acba0a9407a9093505fad0506d2"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga4c778acba0a9407a9093505fad0506d2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga4c778acba0a9407a9093505fad0506d2">equal</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::equal_to, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga4c778acba0a9407a9093505fad0506d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise equality.  <a href="group__comparison__operators.html#ga4c778acba0a9407a9093505fad0506d2">More...</a><br /></td></tr>
<tr class="separator:ga4c778acba0a9407a9093505fad0506d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014ea335af4e1334f9d95ca6f9b9f6ce"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga014ea335af4e1334f9d95ca6f9b9f6ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga014ea335af4e1334f9d95ca6f9b9f6ce">not_equal</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; detail::xfunction_type_t&lt; detail::not_equal_to, E1, E2 &gt;</td></tr>
<tr class="memdesc:ga014ea335af4e1334f9d95ca6f9b9f6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise inequality.  <a href="group__comparison__operators.html#ga014ea335af4e1334f9d95ca6f9b9f6ce">More...</a><br /></td></tr>
<tr class="separator:ga014ea335af4e1334f9d95ca6f9b9f6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c830ecb583258f639e710642dbf0d7c"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga2c830ecb583258f639e710642dbf0d7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga2c830ecb583258f639e710642dbf0d7c">less</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; decltype(std::forward&lt; E1 &gt;(e1)&lt; std::forward&lt; E2 &gt;(e2))</td></tr>
<tr class="memdesc:ga2c830ecb583258f639e710642dbf0d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lesser than.  <a href="group__comparison__operators.html#ga2c830ecb583258f639e710642dbf0d7c">More...</a><br /></td></tr>
<tr class="separator:ga2c830ecb583258f639e710642dbf0d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e84bf652cf6e810f974a8bcb51f1511"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga9e84bf652cf6e810f974a8bcb51f1511"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga9e84bf652cf6e810f974a8bcb51f1511">less_equal</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; decltype(std::forward&lt; E1 &gt;(e1)&lt;=std::forward&lt; E2 &gt;(e2))</td></tr>
<tr class="memdesc:ga9e84bf652cf6e810f974a8bcb51f1511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lesser or equal.  <a href="group__comparison__operators.html#ga9e84bf652cf6e810f974a8bcb51f1511">More...</a><br /></td></tr>
<tr class="separator:ga9e84bf652cf6e810f974a8bcb51f1511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7efdc8246d1ae40ab7f6a8cffe0958"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga7c7efdc8246d1ae40ab7f6a8cffe0958"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga7c7efdc8246d1ae40ab7f6a8cffe0958">greater</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; decltype(std::forward&lt; E1 &gt;(e1) &gt; std::forward&lt; E2 &gt;(e2))</td></tr>
<tr class="memdesc:ga7c7efdc8246d1ae40ab7f6a8cffe0958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than.  <a href="group__comparison__operators.html#ga7c7efdc8246d1ae40ab7f6a8cffe0958">More...</a><br /></td></tr>
<tr class="separator:ga7c7efdc8246d1ae40ab7f6a8cffe0958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a359635b6a5d0940f97c7586a61ea3"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ga68a359635b6a5d0940f97c7586a61ea3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparison__operators.html#ga68a359635b6a5d0940f97c7586a61ea3">greater_equal</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2) noexcept -&gt; decltype(std::forward&lt; E1 &gt;(e1) &gt;=std::forward&lt; E2 &gt;(e2))</td></tr>
<tr class="memdesc:ga68a359635b6a5d0940f97c7586a61ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater or equal.  <a href="group__comparison__operators.html#ga68a359635b6a5d0940f97c7586a61ea3">More...</a><br /></td></tr>
<tr class="separator:ga68a359635b6a5d0940f97c7586a61ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe2a59ff19cc1341bdaf0f833793cbd5"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 , class E3 &gt; </td></tr>
<tr class="memitem:gabe2a59ff19cc1341bdaf0f833793cbd5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#gabe2a59ff19cc1341bdaf0f833793cbd5">where</a> (E1 &amp;&amp;e1, E2 &amp;&amp;e2, E3 &amp;&amp;e3) noexcept -&gt; detail::xfunction_type_t&lt; detail::conditional_ternary, E1, E2, E3 &gt;</td></tr>
<tr class="memdesc:gabe2a59ff19cc1341bdaf0f833793cbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ternary selection.  <a href="group__logical__operators.html#gabe2a59ff19cc1341bdaf0f833793cbd5">More...</a><br /></td></tr>
<tr class="separator:gabe2a59ff19cc1341bdaf0f833793cbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f570271ba6f20a0d6a5880fa4ae83cb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9f570271ba6f20a0d6a5880fa4ae83cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga9f570271ba6f20a0d6a5880fa4ae83cb">nonzero</a> (const T &amp;arr)</td></tr>
<tr class="memdesc:ga9f570271ba6f20a0d6a5880fa4ae83cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return vector of indices where T is not zero  <a href="group__logical__operators.html#ga9f570271ba6f20a0d6a5880fa4ae83cb">More...</a><br /></td></tr>
<tr class="separator:ga9f570271ba6f20a0d6a5880fa4ae83cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad36802fb44a519f60e8c2d20ab5b6ef8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad36802fb44a519f60e8c2d20ab5b6ef8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#gad36802fb44a519f60e8c2d20ab5b6ef8">where</a> (const T &amp;condition)</td></tr>
<tr class="memdesc:gad36802fb44a519f60e8c2d20ab5b6ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return vector of indices where condition is true (equivalent to <em>nonzero(condition)</em>)  <a href="group__logical__operators.html#gad36802fb44a519f60e8c2d20ab5b6ef8">More...</a><br /></td></tr>
<tr class="separator:gad36802fb44a519f60e8c2d20ab5b6ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e8213a0ec55abe31dc046b6a03379d7"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class T &gt; </td></tr>
<tr class="memitem:ga8e8213a0ec55abe31dc046b6a03379d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga8e8213a0ec55abe31dc046b6a03379d7">argwhere</a> (const T &amp;arr)</td></tr>
<tr class="memdesc:ga8e8213a0ec55abe31dc046b6a03379d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">return vector of indices where arr is not zero  <a href="group__logical__operators.html#ga8e8213a0ec55abe31dc046b6a03379d7">More...</a><br /></td></tr>
<tr class="separator:ga8e8213a0ec55abe31dc046b6a03379d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5680cca336e22d483b0bfa188db592"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:gadf5680cca336e22d483b0bfa188db592"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#gadf5680cca336e22d483b0bfa188db592">any</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:gadf5680cca336e22d483b0bfa188db592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any.  <a href="group__logical__operators.html#gadf5680cca336e22d483b0bfa188db592">More...</a><br /></td></tr>
<tr class="separator:gadf5680cca336e22d483b0bfa188db592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da84f179efb13f3d860c5950b5c626e"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga8da84f179efb13f3d860c5950b5c626e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga8da84f179efb13f3d860c5950b5c626e">all</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:ga8da84f179efb13f3d860c5950b5c626e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any.  <a href="group__logical__operators.html#ga8da84f179efb13f3d860c5950b5c626e">More...</a><br /></td></tr>
<tr class="separator:ga8da84f179efb13f3d860c5950b5c626e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d57e20151af53f5ffec3afa6f834cf4"><td class="memTemplParams" colspan="2">template&lt;class R , class E &gt; </td></tr>
<tr class="memitem:ga8d57e20151af53f5ffec3afa6f834cf4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__casting__operators.html#ga8d57e20151af53f5ffec3afa6f834cf4">cast</a> (E &amp;&amp;e) noexcept -&gt; detail::xfunction_type_t&lt; typename detail::cast&lt; R &gt;::functor, E &gt;</td></tr>
<tr class="memdesc:ga8d57e20151af53f5ffec3afa6f834cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-wise <code>static_cast</code>.  <a href="group__casting__operators.html#ga8d57e20151af53f5ffec3afa6f834cf4">More...</a><br /></td></tr>
<tr class="separator:ga8d57e20151af53f5ffec3afa6f834cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185ce67740496368a91e04dd4aa4ce4c"><td class="memTemplParams" colspan="2"><a id="a185ce67740496368a91e04dd4aa4ce4c"></a>
template&lt;class T , class B &gt; </td></tr>
<tr class="memitem:a185ce67740496368a91e04dd4aa4ce4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sign</b> (const xtl::xoptional&lt; T, B &gt; &amp;e)</td></tr>
<tr class="separator:a185ce67740496368a91e04dd4aa4ce4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add75cd2e00bf010a0fb9925de09cb756"><td class="memTemplParams" colspan="2"><a id="add75cd2e00bf010a0fb9925de09cb756"></a>
template&lt;class E , xtl::check_concept&lt; is_xexpression&lt; E &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:add75cd2e00bf010a0fb9925de09cb756"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> (E &amp;&amp;e) -&gt; detail::value_expression_t&lt; E &gt;</td></tr>
<tr class="separator:add75cd2e00bf010a0fb9925de09cb756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf387d0cd347802dfe68ee381d25b6c8"><td class="memTemplParams" colspan="2"><a id="abf387d0cd347802dfe68ee381d25b6c8"></a>
template&lt;class E , xtl::check_concept&lt; is_xexpression&lt; E &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:abf387d0cd347802dfe68ee381d25b6c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_value</b> (E &amp;&amp;e) -&gt; detail::flag_expression_t&lt; E &gt;</td></tr>
<tr class="separator:abf387d0cd347802dfe68ee381d25b6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27edfcd641cfcd6911578af36c4bae56"><td class="memTemplParams" colspan="2"><a id="a27edfcd641cfcd6911578af36c4bae56"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:a27edfcd641cfcd6911578af36c4bae56"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;lhs, const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;rhs)</td></tr>
<tr class="separator:a27edfcd641cfcd6911578af36c4bae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e93972ec2591f3a9400ec258ecda13"><td class="memTemplParams" colspan="2"><a id="a75e93972ec2591f3a9400ec258ecda13"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:a75e93972ec2591f3a9400ec258ecda13"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;lhs, const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;rhs)</td></tr>
<tr class="separator:a75e93972ec2591f3a9400ec258ecda13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a684d1974788cc9717d46e12f7ecd4"><td class="memTemplParams" colspan="2"><a id="a77a684d1974788cc9717d46e12f7ecd4"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:a77a684d1974788cc9717d46e12f7ecd4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;lhs, const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;rhs)</td></tr>
<tr class="separator:a77a684d1974788cc9717d46e12f7ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6570d57275be2b7c10649036e78c29"><td class="memTemplParams" colspan="2"><a id="a1a6570d57275be2b7c10649036e78c29"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:a1a6570d57275be2b7c10649036e78c29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;lhs, const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;rhs)</td></tr>
<tr class="separator:a1a6570d57275be2b7c10649036e78c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8abe6065b427dcae9303709819ea6a"><td class="memTemplParams" colspan="2"><a id="abc8abe6065b427dcae9303709819ea6a"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:abc8abe6065b427dcae9303709819ea6a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;lhs, const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;rhs)</td></tr>
<tr class="separator:abc8abe6065b427dcae9303709819ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dda29491c72743b97493ceb2ab75efd"><td class="memTemplParams" colspan="2"><a id="a9dda29491c72743b97493ceb2ab75efd"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:a9dda29491c72743b97493ceb2ab75efd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;lhs, const <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;rhs)</td></tr>
<tr class="separator:a9dda29491c72743b97493ceb2ab75efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67272be950dacc5ece660fc9ef5f59e6"><td class="memTemplParams" colspan="2"><a id="a67272be950dacc5ece660fc9ef5f59e6"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:a67272be950dacc5ece660fc9ef5f59e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;lhs, <a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a67272be950dacc5ece660fc9ef5f59e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc3786ff18761ee1f3d9c52e74a8c3d"><td class="memTemplParams" colspan="2"><a id="abbc3786ff18761ee1f3d9c52e74a8c3d"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:abbc3786ff18761ee1f3d9c52e74a8c3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_assembly_storage</b> (const VE &amp;value, const FE &amp;flag)</td></tr>
<tr class="separator:abbc3786ff18761ee1f3d9c52e74a8c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf45ad12e20398978f34d0360a2fee44"><td class="memTemplParams" colspan="2"><a id="adf45ad12e20398978f34d0360a2fee44"></a>
template&lt;class VE , class FE &gt; </td></tr>
<tr class="memitem:adf45ad12e20398978f34d0360a2fee44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xoptional__assembly__storage.html">xoptional_assembly_storage</a>&lt; VE, FE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optional_assembly_storage</b> (VE &amp;value, FE &amp;flag)</td></tr>
<tr class="separator:adf45ad12e20398978f34d0360a2fee44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0006ff814bef7534b9fa5187b1863feb"><td class="memTemplParams" colspan="2">template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, class V  = typename std::decay_t&lt;E&gt;::value_type&gt; </td></tr>
<tr class="memitem:a0006ff814bef7534b9fa5187b1863feb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a0006ff814bef7534b9fa5187b1863feb">pad</a> (E &amp;&amp;e, const std::vector&lt; std::vector&lt; S &gt;&gt; &amp;pad_width, <a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">pad_mode</a> mode=pad_mode::constant, V constant_value=0)</td></tr>
<tr class="memdesc:a0006ff814bef7534b9fa5187b1863feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad an array.  <a href="namespacext.html#a0006ff814bef7534b9fa5187b1863feb">More...</a><br /></td></tr>
<tr class="separator:a0006ff814bef7534b9fa5187b1863feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5658ce24f2035e2175546c9ca6ec59"><td class="memTemplParams" colspan="2">template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, class V  = typename std::decay_t&lt;E&gt;::value_type&gt; </td></tr>
<tr class="memitem:abd5658ce24f2035e2175546c9ca6ec59"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#abd5658ce24f2035e2175546c9ca6ec59">pad</a> (E &amp;&amp;e, const std::vector&lt; S &gt; &amp;pad_width, <a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">pad_mode</a> mode=pad_mode::constant, V constant_value=0)</td></tr>
<tr class="memdesc:abd5658ce24f2035e2175546c9ca6ec59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad an array.  <a href="namespacext.html#abd5658ce24f2035e2175546c9ca6ec59">More...</a><br /></td></tr>
<tr class="separator:abd5658ce24f2035e2175546c9ca6ec59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10c047180a5ce9129d25c180369ad00"><td class="memTemplParams" colspan="2">template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, class V  = typename std::decay_t&lt;E&gt;::value_type&gt; </td></tr>
<tr class="memitem:ad10c047180a5ce9129d25c180369ad00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad10c047180a5ce9129d25c180369ad00">pad</a> (E &amp;&amp;e, S pad_width, <a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">pad_mode</a> mode=pad_mode::constant, V constant_value=0)</td></tr>
<tr class="memdesc:ad10c047180a5ce9129d25c180369ad00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad an array.  <a href="namespacext.html#ad10c047180a5ce9129d25c180369ad00">More...</a><br /></td></tr>
<tr class="separator:ad10c047180a5ce9129d25c180369ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ddcadd66cb7d479944b1da073f2ce9"><td class="memTemplParams" colspan="2">template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type&gt; </td></tr>
<tr class="memitem:a65ddcadd66cb7d479944b1da073f2ce9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a65ddcadd66cb7d479944b1da073f2ce9">tile</a> (E &amp;&amp;e, std::initializer_list&lt; S &gt; reps)</td></tr>
<tr class="memdesc:a65ddcadd66cb7d479944b1da073f2ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile an array.  <a href="namespacext.html#a65ddcadd66cb7d479944b1da073f2ce9">More...</a><br /></td></tr>
<tr class="separator:a65ddcadd66cb7d479944b1da073f2ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac902441c74aed8f72ba5b712902324"><td class="memTemplParams" colspan="2"><a id="a9ac902441c74aed8f72ba5b712902324"></a>
template&lt;class E , class C , xtl::check_concept&lt; xtl::negation&lt; xtl::is_integral&lt; C &gt;&gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9ac902441c74aed8f72ba5b712902324"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tile</b> (E &amp;&amp;e, const C &amp;reps)</td></tr>
<tr class="separator:a9ac902441c74aed8f72ba5b712902324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5270a2924bb17bc641c5846355149bc"><td class="memTemplParams" colspan="2">template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, xtl::check_concept&lt; xtl::is_integral&lt; S &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad5270a2924bb17bc641c5846355149bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad5270a2924bb17bc641c5846355149bc">tile</a> (E &amp;&amp;e, S reps)</td></tr>
<tr class="memdesc:ad5270a2924bb17bc641c5846355149bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile an array.  <a href="namespacext.html#ad5270a2924bb17bc641c5846355149bc">More...</a><br /></td></tr>
<tr class="separator:ad5270a2924bb17bc641c5846355149bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89188d735877104c272f5af17c122786"><td class="memTemplParams" colspan="2"><a id="a89188d735877104c272f5af17c122786"></a>
template&lt;template&lt; class... &gt; class A, class... AX, class X , xtl::check_concept&lt; is_evaluation_strategy&lt; AX &gt;..., is_evaluation_strategy&lt; X &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a89188d735877104c272f5af17c122786"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const A&lt; AX... &gt; &amp;args, const A&lt; X &gt; &amp;rhs)</td></tr>
<tr class="separator:a89188d735877104c272f5af17c122786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcb4b44e69b105a41c304eed94860e9"><td class="memTemplParams" colspan="2"><a id="affcb4b44e69b105a41c304eed94860e9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:affcb4b44e69b105a41c304eed94860e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initial</b> (T val)</td></tr>
<tr class="separator:affcb4b44e69b105a41c304eed94860e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa326f1fe4bcca54c32871dbaf4f2df"><td class="memTemplParams" colspan="2"><a id="abfa326f1fe4bcca54c32871dbaf4f2df"></a>
template&lt;class F , class E , class R , xtl::check_concept&lt; std::is_convertible&lt; typename E::value_type, typename R::value_type &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:abfa326f1fe4bcca54c32871dbaf4f2df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_to_reduced</b> (F &amp;, const E &amp;e, R &amp;result)</td></tr>
<tr class="separator:abfa326f1fe4bcca54c32871dbaf4f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ee88ad0d5f4b8d9c3e2a3202f0f80f"><td class="memTemplParams" colspan="2"><a id="a16ee88ad0d5f4b8d9c3e2a3202f0f80f"></a>
template&lt;class F , class E , class X , class O &gt; </td></tr>
<tr class="memitem:a16ee88ad0d5f4b8d9c3e2a3202f0f80f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_immediate</b> (F &amp;&amp;f, E &amp;&amp;e, X &amp;&amp;axes, O &amp;&amp;raw_options)</td></tr>
<tr class="separator:a16ee88ad0d5f4b8d9c3e2a3202f0f80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c2320e34a8620e1dee4f82c61b63da"><td class="memTemplParams" colspan="2"><a id="aa8c2320e34a8620e1dee4f82c61b63da"></a>
template&lt;class RF &gt; </td></tr>
<tr class="memitem:aa8c2320e34a8620e1dee4f82c61b63da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_xreducer_functor</b> (RF &amp;&amp;reduce_func)</td></tr>
<tr class="separator:aa8c2320e34a8620e1dee4f82c61b63da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3e90e71f06aaf4acbb346eb9d911d0"><td class="memTemplParams" colspan="2"><a id="a9a3e90e71f06aaf4acbb346eb9d911d0"></a>
template&lt;class RF , class IF &gt; </td></tr>
<tr class="memitem:a9a3e90e71f06aaf4acbb346eb9d911d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_xreducer_functor</b> (RF &amp;&amp;reduce_func, IF &amp;&amp;init_func)</td></tr>
<tr class="separator:a9a3e90e71f06aaf4acbb346eb9d911d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037bb39f8c5426b198384302727ff97d"><td class="memTemplParams" colspan="2"><a id="a037bb39f8c5426b198384302727ff97d"></a>
template&lt;class RF , class IF , class MF &gt; </td></tr>
<tr class="memitem:a037bb39f8c5426b198384302727ff97d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_xreducer_functor</b> (RF &amp;&amp;reduce_func, IF &amp;&amp;init_func, MF &amp;&amp;merge_func)</td></tr>
<tr class="separator:a037bb39f8c5426b198384302727ff97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf61f96fdc4316d3eefa8dff6174ece"><td class="memTemplParams" colspan="2">template&lt;class F , class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, detail::is_xreducer_functors&lt; F &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2bf61f96fdc4316d3eefa8dff6174ece"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2bf61f96fdc4316d3eefa8dff6174ece">reduce</a> (F &amp;&amp;f, E &amp;&amp;e, X &amp;&amp;axes, EVS &amp;&amp;options=EVS())</td></tr>
<tr class="memdesc:a2bf61f96fdc4316d3eefa8dff6174ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> applying the specified reducing function to an expression over the given axes.  <a href="namespacext.html#a2bf61f96fdc4316d3eefa8dff6174ece">More...</a><br /></td></tr>
<tr class="separator:a2bf61f96fdc4316d3eefa8dff6174ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce9fee9f55c9ce07d63bbf28554c614"><td class="memTemplParams" colspan="2"><a id="acce9fee9f55c9ce07d63bbf28554c614"></a>
template&lt;class F , class E , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; is_reducer_options&lt; EVS &gt;, detail::is_xreducer_functors&lt; F &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:acce9fee9f55c9ce07d63bbf28554c614"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce</b> (F &amp;&amp;f, E &amp;&amp;e, EVS &amp;&amp;options=EVS())</td></tr>
<tr class="separator:acce9fee9f55c9ce07d63bbf28554c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68e24d2b002d736e5ed656cd68f09e"><td class="memTemplParams" colspan="2"><a id="a1a68e24d2b002d736e5ed656cd68f09e"></a>
template&lt;class F , class E , class I , std::size_t N, class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; detail::is_xreducer_functors&lt; F &gt; &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1a68e24d2b002d736e5ed656cd68f09e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce</b> (F &amp;&amp;f, E &amp;&amp;e, const I(&amp;axes)[N], EVS options=EVS())</td></tr>
<tr class="separator:a1a68e24d2b002d736e5ed656cd68f09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1e768a4b5b19507a83567687fcd0ec"><td class="memTemplParams" colspan="2"><a id="adb1e768a4b5b19507a83567687fcd0ec"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adb1e768a4b5b19507a83567687fcd0ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xscalar.html">xscalar</a>&lt; T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xref</b> (T &amp;t)</td></tr>
<tr class="separator:adb1e768a4b5b19507a83567687fcd0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d215c9e2bd56bdd12bbbfbdbafdb35"><td class="memTemplParams" colspan="2"><a id="a05d215c9e2bd56bdd12bbbfbdbafdb35"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a05d215c9e2bd56bdd12bbbfbdbafdb35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xscalar.html">xscalar</a>&lt; const T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xcref</b> (T &amp;t)</td></tr>
<tr class="separator:a05d215c9e2bd56bdd12bbbfbdbafdb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb759383ee774b57d1968d4d52b398a2"><td class="memTemplParams" colspan="2"><a id="aeb759383ee774b57d1968d4d52b398a2"></a>
template&lt;bool is_const, class CT &gt; </td></tr>
<tr class="memitem:aeb759383ee774b57d1968d4d52b398a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1xdummy__iterator.html">xdummy_iterator</a>&lt; is_const, CT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xdummy__iterator.html">xdummy_iterator</a>&lt; is_const, CT &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aeb759383ee774b57d1968d4d52b398a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483e1968158560748a9917f166273ac9"><td class="memTemplParams" colspan="2"><a id="a483e1968158560748a9917f166273ac9"></a>
template&lt;bool is_const, class CT &gt; </td></tr>
<tr class="memitem:a483e1968158560748a9917f166273ac9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1xdummy__iterator.html">xdummy_iterator</a>&lt; is_const, CT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xdummy__iterator.html">xdummy_iterator</a>&lt; is_const, CT &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a483e1968158560748a9917f166273ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cfca2f768bccd20d059436dbfae59f"><td class="memTemplParams" colspan="2"><a id="a00cfca2f768bccd20d059436dbfae59f"></a>
template&lt;class CT &gt; </td></tr>
<tr class="memitem:a00cfca2f768bccd20d059436dbfae59f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_begin</b> (<a class="el" href="classxt_1_1xscalar.html">xscalar</a>&lt; CT &gt; &amp;c) noexcept -&gt; decltype(c.dummy_begin())</td></tr>
<tr class="separator:a00cfca2f768bccd20d059436dbfae59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501788251dba1765f363054645a6e46b"><td class="memTemplParams" colspan="2"><a id="a501788251dba1765f363054645a6e46b"></a>
template&lt;class CT &gt; </td></tr>
<tr class="memitem:a501788251dba1765f363054645a6e46b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_end</b> (<a class="el" href="classxt_1_1xscalar.html">xscalar</a>&lt; CT &gt; &amp;c) noexcept -&gt; decltype(c.dummy_end())</td></tr>
<tr class="separator:a501788251dba1765f363054645a6e46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1d4f63ed23fe5aba8445b3722669e1"><td class="memTemplParams" colspan="2"><a id="a9c1d4f63ed23fe5aba8445b3722669e1"></a>
template&lt;class CT &gt; </td></tr>
<tr class="memitem:a9c1d4f63ed23fe5aba8445b3722669e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_begin</b> (const <a class="el" href="classxt_1_1xscalar.html">xscalar</a>&lt; CT &gt; &amp;c) noexcept -&gt; decltype(c.dummy_begin())</td></tr>
<tr class="separator:a9c1d4f63ed23fe5aba8445b3722669e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab014b4e9cf73ce2d82a7a9854f8f2cda"><td class="memTemplParams" colspan="2"><a id="ab014b4e9cf73ce2d82a7a9854f8f2cda"></a>
template&lt;class CT &gt; </td></tr>
<tr class="memitem:ab014b4e9cf73ce2d82a7a9854f8f2cda"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>linear_end</b> (const <a class="el" href="classxt_1_1xscalar.html">xscalar</a>&lt; CT &gt; &amp;c) noexcept -&gt; decltype(c.dummy_end())</td></tr>
<tr class="separator:ab014b4e9cf73ce2d82a7a9854f8f2cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71ec22119ac398c4c737d48197e5399"><td class="memTemplParams" colspan="2">template&lt;class E , class T &gt; </td></tr>
<tr class="memitem:gac71ec22119ac398c4c737d48197e5399"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#gac71ec22119ac398c4c737d48197e5399">isin</a> (E &amp;&amp;element, std::initializer_list&lt; T &gt; test_elements) noexcept</td></tr>
<tr class="memdesc:gac71ec22119ac398c4c737d48197e5399"><td class="mdescLeft">&#160;</td><td class="mdescRight">isin  <a href="group__logical__operators.html#gac71ec22119ac398c4c737d48197e5399">More...</a><br /></td></tr>
<tr class="separator:gac71ec22119ac398c4c737d48197e5399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84c1d8a7eaaa5d9f7e0484b9dfc0c646"><td class="memTemplParams" colspan="2">template&lt;class E , class F , class  = typename std::enable_if_t&lt;has_iterator_interface&lt;F&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga84c1d8a7eaaa5d9f7e0484b9dfc0c646"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga84c1d8a7eaaa5d9f7e0484b9dfc0c646">isin</a> (E &amp;&amp;element, F &amp;&amp;test_elements) noexcept</td></tr>
<tr class="memdesc:ga84c1d8a7eaaa5d9f7e0484b9dfc0c646"><td class="mdescLeft">&#160;</td><td class="mdescRight">isin  <a href="group__logical__operators.html#ga84c1d8a7eaaa5d9f7e0484b9dfc0c646">More...</a><br /></td></tr>
<tr class="separator:ga84c1d8a7eaaa5d9f7e0484b9dfc0c646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef46d45350e3699429eff9ca45755f7"><td class="memTemplParams" colspan="2">template&lt;class E , class I , class  = typename std::enable_if_t&lt;is_iterator&lt;I&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gaaef46d45350e3699429eff9ca45755f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#gaaef46d45350e3699429eff9ca45755f7">isin</a> (E &amp;&amp;element, I &amp;&amp;test_elements_begin, I &amp;&amp;test_elements_end) noexcept</td></tr>
<tr class="memdesc:gaaef46d45350e3699429eff9ca45755f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">isin  <a href="group__logical__operators.html#gaaef46d45350e3699429eff9ca45755f7">More...</a><br /></td></tr>
<tr class="separator:gaaef46d45350e3699429eff9ca45755f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1bbf85dbe7bc76561321466d657bed4"><td class="memTemplParams" colspan="2">template&lt;class E , class T &gt; </td></tr>
<tr class="memitem:gab1bbf85dbe7bc76561321466d657bed4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#gab1bbf85dbe7bc76561321466d657bed4">in1d</a> (E &amp;&amp;element, std::initializer_list&lt; T &gt; test_elements) noexcept</td></tr>
<tr class="memdesc:gab1bbf85dbe7bc76561321466d657bed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">in1d  <a href="group__logical__operators.html#gab1bbf85dbe7bc76561321466d657bed4">More...</a><br /></td></tr>
<tr class="separator:gab1bbf85dbe7bc76561321466d657bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aab6400780394dfb5d0d938c19f1f63"><td class="memTemplParams" colspan="2">template&lt;class E , class F , class  = typename std::enable_if_t&lt;has_iterator_interface&lt;F&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga3aab6400780394dfb5d0d938c19f1f63"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga3aab6400780394dfb5d0d938c19f1f63">in1d</a> (E &amp;&amp;element, F &amp;&amp;test_elements) noexcept</td></tr>
<tr class="memdesc:ga3aab6400780394dfb5d0d938c19f1f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">in1d  <a href="group__logical__operators.html#ga3aab6400780394dfb5d0d938c19f1f63">More...</a><br /></td></tr>
<tr class="separator:ga3aab6400780394dfb5d0d938c19f1f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga835cd37cf9a3142a7836509b4f082a64"><td class="memTemplParams" colspan="2">template&lt;class E , class I , class  = typename std::enable_if_t&lt;is_iterator&lt;I&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga835cd37cf9a3142a7836509b4f082a64"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical__operators.html#ga835cd37cf9a3142a7836509b4f082a64">in1d</a> (E &amp;&amp;element, I &amp;&amp;test_elements_begin, I &amp;&amp;test_elements_end) noexcept</td></tr>
<tr class="memdesc:ga835cd37cf9a3142a7836509b4f082a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">in1d  <a href="group__logical__operators.html#ga835cd37cf9a3142a7836509b4f082a64">More...</a><br /></td></tr>
<tr class="separator:ga835cd37cf9a3142a7836509b4f082a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2dbcb81b8a765fe3972a7490d62618"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a7f2dbcb81b8a765fe3972a7490d62618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a7f2dbcb81b8a765fe3972a7490d62618">searchsorted</a> (E1 &amp;&amp;a, E2 &amp;&amp;v, bool right=true)</td></tr>
<tr class="memdesc:a7f2dbcb81b8a765fe3972a7490d62618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find indices where elements should be inserted to maintain order.  <a href="namespacext.html#a7f2dbcb81b8a765fe3972a7490d62618">More...</a><br /></td></tr>
<tr class="separator:a7f2dbcb81b8a765fe3972a7490d62618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c10cfb8271fbf79932a98edc5491ac7"><td class="memTemplParams" colspan="2">template&lt;class S1 , class S2 &gt; </td></tr>
<tr class="memitem:a3c10cfb8271fbf79932a98edc5491ac7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a3c10cfb8271fbf79932a98edc5491ac7">same_shape</a> (const S1 &amp;s1, const S2 &amp;s2) noexcept</td></tr>
<tr class="memdesc:a3c10cfb8271fbf79932a98edc5491ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">same_shape  <a href="namespacext.html#a3c10cfb8271fbf79932a98edc5491ac7">More...</a><br /></td></tr>
<tr class="separator:a3c10cfb8271fbf79932a98edc5491ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3023c5760bcda67404f149bb31858a"><td class="memTemplParams" colspan="2"><a id="aaa3023c5760bcda67404f149bb31858a"></a>
template&lt;class R , class T &gt; </td></tr>
<tr class="memitem:aaa3023c5760bcda67404f149bb31858a"><td class="memTemplItemLeft" align="right" valign="top">constexpr R&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shape</b> (T t)</td></tr>
<tr class="separator:aaa3023c5760bcda67404f149bb31858a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad761751bf328e1bedb307676ab8e7c8f"><td class="memTemplParams" colspan="2"><a id="ad761751bf328e1bedb307676ab8e7c8f"></a>
template&lt;class R  = std::size_t, class T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad761751bf328e1bedb307676ab8e7c8f"><td class="memTemplItemLeft" align="right" valign="top">xt::static_shape&lt; R, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad761751bf328e1bedb307676ab8e7c8f">shape</a> (const T(&amp;list)[N])</td></tr>
<tr class="memdesc:ad761751bf328e1bedb307676ab8e7c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an xt::static_shape of the given size. <br /></td></tr>
<tr class="separator:ad761751bf328e1bedb307676ab8e7c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d28aa1be818adaecee7803249dad7d"><td class="memTemplParams" colspan="2">template&lt;class E , class S &gt; </td></tr>
<tr class="memitem:a56d28aa1be818adaecee7803249dad7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a56d28aa1be818adaecee7803249dad7d">has_shape</a> (const E &amp;e, std::initializer_list&lt; S &gt; shape) noexcept</td></tr>
<tr class="memdesc:a56d28aa1be818adaecee7803249dad7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">has_shape  <a href="namespacext.html#a56d28aa1be818adaecee7803249dad7d">More...</a><br /></td></tr>
<tr class="separator:a56d28aa1be818adaecee7803249dad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4453a49484a5833cbf48e51eff2ed3df"><td class="memTemplParams" colspan="2">template&lt;class E , class S , class  = typename std::enable_if_t&lt;has_iterator_interface&lt;S&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a4453a49484a5833cbf48e51eff2ed3df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a4453a49484a5833cbf48e51eff2ed3df">has_shape</a> (const E &amp;e, const S &amp;shape)</td></tr>
<tr class="memdesc:a4453a49484a5833cbf48e51eff2ed3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">has_shape  <a href="namespacext.html#a4453a49484a5833cbf48e51eff2ed3df">More...</a><br /></td></tr>
<tr class="separator:a4453a49484a5833cbf48e51eff2ed3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1607ba0be938e3d0a9acecee22eb2efe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#a1607ba0be938e3d0a9acecee22eb2efe">all</a> () noexcept</td></tr>
<tr class="memdesc:a1607ba0be938e3d0a9acecee22eb2efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice representing a full dimension, to be used as an argument of view function.  <a href="namespacext.html#a1607ba0be938e3d0a9acecee22eb2efe">More...</a><br /></td></tr>
<tr class="separator:a1607ba0be938e3d0a9acecee22eb2efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7674e27693c74603e341cbf7beb91e7b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#a7674e27693c74603e341cbf7beb91e7b">ellipsis</a> () noexcept</td></tr>
<tr class="memdesc:a7674e27693c74603e341cbf7beb91e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice representing all remaining dimensions, and selecting all in these dimensions.  <a href="namespacext.html#a7674e27693c74603e341cbf7beb91e7b">More...</a><br /></td></tr>
<tr class="separator:a7674e27693c74603e341cbf7beb91e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534914903c805a597a5fac60e60e7c43"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacext.html#a534914903c805a597a5fac60e60e7c43">newaxis</a> () noexcept</td></tr>
<tr class="memdesc:a534914903c805a597a5fac60e60e7c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice representing a new axis of length one, to be used as an argument of view function.  <a href="namespacext.html#a534914903c805a597a5fac60e60e7c43">More...</a><br /></td></tr>
<tr class="separator:a534914903c805a597a5fac60e60e7c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2d8b5c3e1c55828c6cc62cb712f15f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acf2d8b5c3e1c55828c6cc62cb712f15f"><td class="memTemplItemLeft" align="right" valign="top">detail::disable_integral_keep&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#acf2d8b5c3e1c55828c6cc62cb712f15f">keep</a> (T &amp;&amp;indices)</td></tr>
<tr class="memdesc:acf2d8b5c3e1c55828c6cc62cb712f15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a non-contigous slice from a container of indices to keep.  <a href="namespacext.html#acf2d8b5c3e1c55828c6cc62cb712f15f">More...</a><br /></td></tr>
<tr class="separator:acf2d8b5c3e1c55828c6cc62cb712f15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94a48b72ff00b2cc1973fa5c53df5ef"><td class="memTemplParams" colspan="2"><a id="ab94a48b72ff00b2cc1973fa5c53df5ef"></a>
template&lt;class R  = std::ptrdiff_t, class T &gt; </td></tr>
<tr class="memitem:ab94a48b72ff00b2cc1973fa5c53df5ef"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_integral_keep&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keep</b> (T i)</td></tr>
<tr class="separator:ab94a48b72ff00b2cc1973fa5c53df5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc927d67d9a4cba47092b6c0e0735bfc"><td class="memTemplParams" colspan="2"><a id="afc927d67d9a4cba47092b6c0e0735bfc"></a>
template&lt;class R  = std::ptrdiff_t, class Arg0 , class Arg1 , class... Args&gt; </td></tr>
<tr class="memitem:afc927d67d9a4cba47092b6c0e0735bfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xkeep__slice.html">xkeep_slice</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>keep</b> (Arg0 i0, Arg1 i1, Args... args)</td></tr>
<tr class="separator:afc927d67d9a4cba47092b6c0e0735bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7803c646dad8f762ce42c50153ec6d0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af7803c646dad8f762ce42c50153ec6d0"><td class="memTemplItemLeft" align="right" valign="top">detail::disable_integral_drop&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af7803c646dad8f762ce42c50153ec6d0">drop</a> (T &amp;&amp;indices)</td></tr>
<tr class="memdesc:af7803c646dad8f762ce42c50153ec6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a non-contigous slice from a container of indices to drop.  <a href="namespacext.html#af7803c646dad8f762ce42c50153ec6d0">More...</a><br /></td></tr>
<tr class="separator:af7803c646dad8f762ce42c50153ec6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7011a3524c2ede5310ca42653e1a73df"><td class="memTemplParams" colspan="2"><a id="a7011a3524c2ede5310ca42653e1a73df"></a>
template&lt;class R  = std::ptrdiff_t, class T &gt; </td></tr>
<tr class="memitem:a7011a3524c2ede5310ca42653e1a73df"><td class="memTemplItemLeft" align="right" valign="top">detail::enable_integral_drop&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drop</b> (T i)</td></tr>
<tr class="separator:a7011a3524c2ede5310ca42653e1a73df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24aebf01badfb73f6f6d625c7497c7c"><td class="memTemplParams" colspan="2"><a id="ae24aebf01badfb73f6f6d625c7497c7c"></a>
template&lt;class R  = std::ptrdiff_t, class Arg0 , class Arg1 , class... Args&gt; </td></tr>
<tr class="memitem:ae24aebf01badfb73f6f6d625c7497c7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xdrop__slice.html">xdrop_slice</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>drop</b> (Arg0 i0, Arg1 i1, Args... args)</td></tr>
<tr class="separator:ae24aebf01badfb73f6f6d625c7497c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d00d7773a654d2e2252004fb69ff566"><td class="memItemLeft" align="right" valign="top"><a id="a1d00d7773a654d2e2252004fb69ff566"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>xnone</b> ()</td></tr>
<tr class="separator:a1d00d7773a654d2e2252004fb69ff566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12df38a6d4e688b6df1a4641930c6181"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:a12df38a6d4e688b6df1a4641930c6181"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">range</a> (A start_val, B stop_val)</td></tr>
<tr class="memdesc:a12df38a6d4e688b6df1a4641930c6181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a range from start_val to stop_val (excluded).  <a href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">More...</a><br /></td></tr>
<tr class="separator:a12df38a6d4e688b6df1a4641930c6181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1605028ad21316d7118d9c2c56b93a4"><td class="memTemplParams" colspan="2">template&lt;class A , class B , class C &gt; </td></tr>
<tr class="memitem:ad1605028ad21316d7118d9c2c56b93a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad1605028ad21316d7118d9c2c56b93a4">range</a> (A start_val, B stop_val, C step)</td></tr>
<tr class="memdesc:ad1605028ad21316d7118d9c2c56b93a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select a range from start_val to stop_val (excluded) with step You can use the shorthand <code>_</code> syntax to select from the start or until the end.  <a href="namespacext.html#ad1605028ad21316d7118d9c2c56b93a4">More...</a><br /></td></tr>
<tr class="separator:ad1605028ad21316d7118d9c2c56b93a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7813116e19b666384c7a0e4c72e496"><td class="memTemplParams" colspan="2"><a id="adb7813116e19b666384c7a0e4c72e496"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:adb7813116e19b666384c7a0e4c72e496"><td class="memTemplItemLeft" align="right" valign="top">disable_xslice&lt; S, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_size</b> (const S &amp;) noexcept</td></tr>
<tr class="separator:adb7813116e19b666384c7a0e4c72e496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56737617c546e2621ef370d004c8efd7"><td class="memTemplParams" colspan="2"><a id="a56737617c546e2621ef370d004c8efd7"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a56737617c546e2621ef370d004c8efd7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_size</b> (const <a class="el" href="classxt_1_1xslice.html">xslice</a>&lt; S &gt; &amp;slice) noexcept</td></tr>
<tr class="separator:a56737617c546e2621ef370d004c8efd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b605e18ab4d1ba35ac8034bb184a299"><td class="memTemplParams" colspan="2"><a id="a9b605e18ab4d1ba35ac8034bb184a299"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a9b605e18ab4d1ba35ac8034bb184a299"><td class="memTemplItemLeft" align="right" valign="top">disable_xslice&lt; S, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>step_size</b> (const S &amp;, std::size_t) noexcept</td></tr>
<tr class="separator:a9b605e18ab4d1ba35ac8034bb184a299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa7e08cb241d2d5a3a19110d0ba2566"><td class="memTemplParams" colspan="2"><a id="acaa7e08cb241d2d5a3a19110d0ba2566"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:acaa7e08cb241d2d5a3a19110d0ba2566"><td class="memTemplItemLeft" align="right" valign="top">disable_xslice&lt; S, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>step_size</b> (const S &amp;, std::size_t, std::size_t) noexcept</td></tr>
<tr class="separator:acaa7e08cb241d2d5a3a19110d0ba2566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd73f9eaca28411da7d5debf258b1372"><td class="memTemplParams" colspan="2"><a id="acd73f9eaca28411da7d5debf258b1372"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:acd73f9eaca28411da7d5debf258b1372"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>step_size</b> (const <a class="el" href="classxt_1_1xslice.html">xslice</a>&lt; S &gt; &amp;slice, std::size_t idx) noexcept</td></tr>
<tr class="separator:acd73f9eaca28411da7d5debf258b1372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa578cdc860fa8248c9bc5993891919fb"><td class="memTemplParams" colspan="2"><a id="aa578cdc860fa8248c9bc5993891919fb"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:aa578cdc860fa8248c9bc5993891919fb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>step_size</b> (const <a class="el" href="classxt_1_1xslice.html">xslice</a>&lt; S &gt; &amp;slice, std::size_t idx, std::size_t n) noexcept</td></tr>
<tr class="separator:aa578cdc860fa8248c9bc5993891919fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c68dcd3358d3fd6fd9a8083e5a30489"><td class="memTemplParams" colspan="2"><a id="a4c68dcd3358d3fd6fd9a8083e5a30489"></a>
template&lt;class S , class I &gt; </td></tr>
<tr class="memitem:a4c68dcd3358d3fd6fd9a8083e5a30489"><td class="memTemplItemLeft" align="right" valign="top">disable_xslice&lt; S, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> (const S &amp;s, I) noexcept</td></tr>
<tr class="separator:a4c68dcd3358d3fd6fd9a8083e5a30489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061470c5ddb136937a4f2d2c0d9a1246"><td class="memTemplParams" colspan="2"><a id="a061470c5ddb136937a4f2d2c0d9a1246"></a>
template&lt;class S , class I &gt; </td></tr>
<tr class="memitem:a061470c5ddb136937a4f2d2c0d9a1246"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>value</b> (const <a class="el" href="classxt_1_1xslice.html">xslice</a>&lt; S &gt; &amp;slice, I i) noexcept</td></tr>
<tr class="separator:a061470c5ddb136937a4f2d2c0d9a1246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3c4c7c2fad6bf3820243845009f83c"><td class="memTemplParams" colspan="2"><a id="a7c3c4c7c2fad6bf3820243845009f83c"></a>
template&lt;class E , class SL &gt; </td></tr>
<tr class="memitem:a7c3c4c7c2fad6bf3820243845009f83c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_slice_implementation</b> (E &amp;e, SL &amp;&amp;slice, std::size_t index)</td></tr>
<tr class="separator:a7c3c4c7c2fad6bf3820243845009f83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa2c393a6cf46a93fe6200a2f1480ec"><td class="memTemplParams" colspan="2"><a id="a3aa2c393a6cf46a93fe6200a2f1480ec"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a3aa2c393a6cf46a93fe6200a2f1480ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>)</td></tr>
<tr class="separator:a3aa2c393a6cf46a93fe6200a2f1480ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae455f4aaacbc04bebc76451907003ee3"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ae455f4aaacbc04bebc76451907003ee3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae455f4aaacbc04bebc76451907003ee3">sort</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::ptrdiff_t axis=-1)</td></tr>
<tr class="memdesc:ae455f4aaacbc04bebc76451907003ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort xexpression (optionally along axis) The sort is performed using the <code>std::sort</code> functions.  <a href="namespacext.html#ae455f4aaacbc04bebc76451907003ee3">More...</a><br /></td></tr>
<tr class="separator:ae455f4aaacbc04bebc76451907003ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d191e6ab9d2a0ac7dff33baddd88554"><td class="memTemplParams" colspan="2"><a id="a8d191e6ab9d2a0ac7dff33baddd88554"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a8d191e6ab9d2a0ac7dff33baddd88554"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argsort</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>)</td></tr>
<tr class="separator:a8d191e6ab9d2a0ac7dff33baddd88554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3bfb99c8fdab94a100f960ddcb4fdf"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:abe3bfb99c8fdab94a100f960ddcb4fdf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#abe3bfb99c8fdab94a100f960ddcb4fdf">argsort</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::ptrdiff_t axis=-1)</td></tr>
<tr class="memdesc:abe3bfb99c8fdab94a100f960ddcb4fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Argsort xexpression (optionally along axis) Performs an indirect sort along the given axis.  <a href="namespacext.html#abe3bfb99c8fdab94a100f960ddcb4fdf">More...</a><br /></td></tr>
<tr class="separator:abe3bfb99c8fdab94a100f960ddcb4fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ff136e0f1b09d37952f7828c65316e"><td class="memTemplParams" colspan="2">template&lt;class E , class C , class R  = detail::flatten_sort_result_type_t&lt;E&gt;, class  = std::enable_if_t&lt;!xtl::is_integral&lt;C&gt;::value, int&gt;&gt; </td></tr>
<tr class="memitem:a08ff136e0f1b09d37952f7828c65316e"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a08ff136e0f1b09d37952f7828c65316e">partition</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const C &amp;kth_container, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>)</td></tr>
<tr class="memdesc:a08ff136e0f1b09d37952f7828c65316e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially sort xexpression.  <a href="namespacext.html#a08ff136e0f1b09d37952f7828c65316e">More...</a><br /></td></tr>
<tr class="separator:a08ff136e0f1b09d37952f7828c65316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee8342d10ac62a2ae3100efa7876622"><td class="memTemplParams" colspan="2"><a id="afee8342d10ac62a2ae3100efa7876622"></a>
template&lt;class E , class I , std::size_t N, class R  = detail::flatten_sort_result_type_t&lt;E&gt;&gt; </td></tr>
<tr class="memitem:afee8342d10ac62a2ae3100efa7876622"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><b>partition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const I(&amp;kth_container)[N], <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> tag)</td></tr>
<tr class="separator:afee8342d10ac62a2ae3100efa7876622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65ded269d5a44b38238e2b7a0bc7040"><td class="memTemplParams" colspan="2"><a id="ac65ded269d5a44b38238e2b7a0bc7040"></a>
template&lt;class E , class R  = detail::flatten_sort_result_type_t&lt;E&gt;&gt; </td></tr>
<tr class="memitem:ac65ded269d5a44b38238e2b7a0bc7040"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><b>partition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::size_t kth, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> tag)</td></tr>
<tr class="separator:ac65ded269d5a44b38238e2b7a0bc7040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8891f333bf675d21535e936f1d0f630d"><td class="memTemplParams" colspan="2"><a id="a8891f333bf675d21535e936f1d0f630d"></a>
template&lt;class E , class C , class  = std::enable_if_t&lt;!xtl::is_integral&lt;C&gt;::value, int&gt;&gt; </td></tr>
<tr class="memitem:a8891f333bf675d21535e936f1d0f630d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>partition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const C &amp;kth_container, std::ptrdiff_t axis=-1)</td></tr>
<tr class="separator:a8891f333bf675d21535e936f1d0f630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d672460ff360c017d64e17fecbdbe29"><td class="memTemplParams" colspan="2"><a id="a0d672460ff360c017d64e17fecbdbe29"></a>
template&lt;class E , class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0d672460ff360c017d64e17fecbdbe29"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>partition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const T(&amp;kth_container)[N], std::ptrdiff_t axis=-1)</td></tr>
<tr class="separator:a0d672460ff360c017d64e17fecbdbe29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06629a838d9582950432a76fab6a99fe"><td class="memTemplParams" colspan="2"><a id="a06629a838d9582950432a76fab6a99fe"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a06629a838d9582950432a76fab6a99fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>partition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::size_t kth, std::ptrdiff_t axis=-1)</td></tr>
<tr class="separator:a06629a838d9582950432a76fab6a99fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6161585ce399b9dcb2480c464f0c0c6"><td class="memTemplParams" colspan="2">template&lt;class E , class C , class R  = typename detail::linear_argsort_result_type&lt;typename detail::sort_eval_type&lt;E&gt;::type&gt;::type, class  = std::enable_if_t&lt;!xtl::is_integral&lt;C&gt;::value, int&gt;&gt; </td></tr>
<tr class="memitem:ab6161585ce399b9dcb2480c464f0c0c6"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ab6161585ce399b9dcb2480c464f0c0c6">argpartition</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const C &amp;kth_container, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>)</td></tr>
<tr class="memdesc:ab6161585ce399b9dcb2480c464f0c0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially sort arguments.  <a href="namespacext.html#ab6161585ce399b9dcb2480c464f0c0c6">More...</a><br /></td></tr>
<tr class="separator:ab6161585ce399b9dcb2480c464f0c0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a5b3988f8b5429627561291d62b188"><td class="memTemplParams" colspan="2"><a id="a97a5b3988f8b5429627561291d62b188"></a>
template&lt;class E , class I , std::size_t N&gt; </td></tr>
<tr class="memitem:a97a5b3988f8b5429627561291d62b188"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argpartition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const I(&amp;kth_container)[N], <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> tag)</td></tr>
<tr class="separator:a97a5b3988f8b5429627561291d62b188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462bdb89bdbd963faac3a54befd6f6ae"><td class="memTemplParams" colspan="2"><a id="a462bdb89bdbd963faac3a54befd6f6ae"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a462bdb89bdbd963faac3a54befd6f6ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argpartition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::size_t kth, <a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a> tag)</td></tr>
<tr class="separator:a462bdb89bdbd963faac3a54befd6f6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351ae4b2134faab9b490a4b4aabf4b0"><td class="memTemplParams" colspan="2"><a id="a4351ae4b2134faab9b490a4b4aabf4b0"></a>
template&lt;class E , class C , class  = std::enable_if_t&lt;!xtl::is_integral&lt;C&gt;::value, int&gt;&gt; </td></tr>
<tr class="memitem:a4351ae4b2134faab9b490a4b4aabf4b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argpartition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const C &amp;kth_container, std::ptrdiff_t axis=-1)</td></tr>
<tr class="separator:a4351ae4b2134faab9b490a4b4aabf4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81a515a0990dde86ce52b3f2fedbf09"><td class="memTemplParams" colspan="2"><a id="ad81a515a0990dde86ce52b3f2fedbf09"></a>
template&lt;class E , class I , std::size_t N&gt; </td></tr>
<tr class="memitem:ad81a515a0990dde86ce52b3f2fedbf09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argpartition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, const I(&amp;kth_container)[N], std::ptrdiff_t axis=-1)</td></tr>
<tr class="separator:ad81a515a0990dde86ce52b3f2fedbf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9af4982d69351b620442e81dfac3d3"><td class="memTemplParams" colspan="2"><a id="a2d9af4982d69351b620442e81dfac3d3"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a2d9af4982d69351b620442e81dfac3d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argpartition</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::size_t kth, std::ptrdiff_t axis=-1)</td></tr>
<tr class="separator:a2d9af4982d69351b620442e81dfac3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1640a4d9888e8fed1746a80f06a4d38"><td class="memTemplParams" colspan="2"><a id="af1640a4d9888e8fed1746a80f06a4d38"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:af1640a4d9888e8fed1746a80f06a4d38"><td class="memTemplItemLeft" align="right" valign="top">std::decay_t&lt; E &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>median</b> (E &amp;&amp;e)</td></tr>
<tr class="separator:af1640a4d9888e8fed1746a80f06a4d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a650f8da9d0066e26ecda36ee293e4"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ae6a650f8da9d0066e26ecda36ee293e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae6a650f8da9d0066e26ecda36ee293e4">median</a> (E &amp;&amp;e, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:ae6a650f8da9d0066e26ecda36ee293e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the median along the specified axis.  <a href="namespacext.html#ae6a650f8da9d0066e26ecda36ee293e4">More...</a><br /></td></tr>
<tr class="separator:ae6a650f8da9d0066e26ecda36ee293e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24e546173e7a9eab03c0dd51618bc07"><td class="memTemplParams" colspan="2"><a id="ab24e546173e7a9eab03c0dd51618bc07"></a>
template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </td></tr>
<tr class="memitem:ab24e546173e7a9eab03c0dd51618bc07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argmin</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:ab24e546173e7a9eab03c0dd51618bc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af262fae4388b98687913a18fe321f88d"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </td></tr>
<tr class="memitem:af262fae4388b98687913a18fe321f88d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af262fae4388b98687913a18fe321f88d">argmin</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:af262fae4388b98687913a18fe321f88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find position of minimal value in xexpression.  <a href="namespacext.html#af262fae4388b98687913a18fe321f88d">More...</a><br /></td></tr>
<tr class="separator:af262fae4388b98687913a18fe321f88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af577450eeec3b27f6ad4b0d487e8d9e3"><td class="memTemplParams" colspan="2"><a id="af577450eeec3b27f6ad4b0d487e8d9e3"></a>
template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </td></tr>
<tr class="memitem:af577450eeec3b27f6ad4b0d487e8d9e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argmax</b> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="separator:af577450eeec3b27f6ad4b0d487e8d9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b6c4df6acf24de4bec48be87f0218"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </td></tr>
<tr class="memitem:a258b6c4df6acf24de4bec48be87f0218"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a258b6c4df6acf24de4bec48be87f0218">argmax</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e, std::ptrdiff_t axis)</td></tr>
<tr class="memdesc:a258b6c4df6acf24de4bec48be87f0218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find position of maximal value in xexpression.  <a href="namespacext.html#a258b6c4df6acf24de4bec48be87f0218">More...</a><br /></td></tr>
<tr class="separator:a258b6c4df6acf24de4bec48be87f0218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b46eaf022e2fcd9e82ae5223fdd3ed5"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a2b46eaf022e2fcd9e82ae5223fdd3ed5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2b46eaf022e2fcd9e82ae5223fdd3ed5">unique</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;e)</td></tr>
<tr class="memdesc:a2b46eaf022e2fcd9e82ae5223fdd3ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find unique elements of a xexpression.  <a href="namespacext.html#a2b46eaf022e2fcd9e82ae5223fdd3ed5">More...</a><br /></td></tr>
<tr class="separator:a2b46eaf022e2fcd9e82ae5223fdd3ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6eedcadc051be2d6e3ad7890a5c2d90"><td class="memTemplParams" colspan="2">template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:ab6eedcadc051be2d6e3ad7890a5c2d90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ab6eedcadc051be2d6e3ad7890a5c2d90">setdiff1d</a> (const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;ar1, const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;ar2)</td></tr>
<tr class="memdesc:ab6eedcadc051be2d6e3ad7890a5c2d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the set difference of two xexpressions.  <a href="namespacext.html#ab6eedcadc051be2d6e3ad7890a5c2d90">More...</a><br /></td></tr>
<tr class="separator:ab6eedcadc051be2d6e3ad7890a5c2d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cc92dd4bb9300e3f4c82b0a5c3d39e"><td class="memTemplParams" colspan="2"><a id="a01cc92dd4bb9300e3f4c82b0a5c3d39e"></a>
template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a01cc92dd4bb9300e3f4c82b0a5c3d39e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;lhs, const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;rhs)</td></tr>
<tr class="separator:a01cc92dd4bb9300e3f4c82b0a5c3d39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2dd97c88be41a56b5c10698d9608dc"><td class="memTemplParams" colspan="2"><a id="afc2dd97c88be41a56b5c10698d9608dc"></a>
template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:afc2dd97c88be41a56b5c10698d9608dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;lhs, const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;rhs)</td></tr>
<tr class="separator:afc2dd97c88be41a56b5c10698d9608dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dc6244c8561be58625c70143184a30"><td class="memTemplParams" colspan="2"><a id="a98dc6244c8561be58625c70143184a30"></a>
template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a98dc6244c8561be58625c70143184a30"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;lhs, const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;rhs)</td></tr>
<tr class="separator:a98dc6244c8561be58625c70143184a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89ccc1f20aeae36046359451ebd589b"><td class="memTemplParams" colspan="2"><a id="ab89ccc1f20aeae36046359451ebd589b"></a>
template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:ab89ccc1f20aeae36046359451ebd589b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;lhs, const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;rhs)</td></tr>
<tr class="separator:ab89ccc1f20aeae36046359451ebd589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8185b0352be4f2fff096d10568eda488"><td class="memTemplParams" colspan="2"><a id="a8185b0352be4f2fff096d10568eda488"></a>
template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a8185b0352be4f2fff096d10568eda488"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;lhs, const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;rhs)</td></tr>
<tr class="separator:a8185b0352be4f2fff096d10568eda488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4468f837fe688be28c3c98497fdffc"><td class="memTemplParams" colspan="2"><a id="acf4468f837fe688be28c3c98497fdffc"></a>
template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:acf4468f837fe688be28c3c98497fdffc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;lhs, const <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;rhs)</td></tr>
<tr class="separator:acf4468f837fe688be28c3c98497fdffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf048a883f24fca116d86364dd47fc7f"><td class="memTemplParams" colspan="2"><a id="abf048a883f24fca116d86364dd47fc7f"></a>
template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:abf048a883f24fca116d86364dd47fc7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;lhs, <a class="el" href="classxt_1_1uvector.html">uvector</a>&lt; T, A &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:abf048a883f24fca116d86364dd47fc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc103cd31101f2fdc1963f4514f1565"><td class="memTemplParams" colspan="2"><a id="a3bc103cd31101f2fdc1963f4514f1565"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a3bc103cd31101f2fdc1963f4514f1565"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const std::vector&lt; T &gt; &amp;lhs, const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs)</td></tr>
<tr class="separator:a3bc103cd31101f2fdc1963f4514f1565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c29fed5ff3ca0085876add7cd02383e"><td class="memTemplParams" colspan="2"><a id="a0c29fed5ff3ca0085876add7cd02383e"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a0c29fed5ff3ca0085876add7cd02383e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, const std::vector&lt; T &gt; &amp;rhs)</td></tr>
<tr class="separator:a0c29fed5ff3ca0085876add7cd02383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf619c847735265e61f4e50121aa020"><td class="memTemplParams" colspan="2"><a id="adaf619c847735265e61f4e50121aa020"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:adaf619c847735265e61f4e50121aa020"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs)</td></tr>
<tr class="separator:adaf619c847735265e61f4e50121aa020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d05522f8e5a3a3397c11d46504b028f"><td class="memTemplParams" colspan="2"><a id="a8d05522f8e5a3a3397c11d46504b028f"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a8d05522f8e5a3a3397c11d46504b028f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs)</td></tr>
<tr class="separator:a8d05522f8e5a3a3397c11d46504b028f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9732f5ac5dd992f92fc99da574d255c2"><td class="memTemplParams" colspan="2"><a id="a9732f5ac5dd992f92fc99da574d255c2"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a9732f5ac5dd992f92fc99da574d255c2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs)</td></tr>
<tr class="separator:a9732f5ac5dd992f92fc99da574d255c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151bf9bf9a1ef115e1bfb8b86ab10616"><td class="memTemplParams" colspan="2"><a id="a151bf9bf9a1ef115e1bfb8b86ab10616"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a151bf9bf9a1ef115e1bfb8b86ab10616"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs)</td></tr>
<tr class="separator:a151bf9bf9a1ef115e1bfb8b86ab10616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140dface65370832588fb769e1d307eb"><td class="memTemplParams" colspan="2"><a id="a140dface65370832588fb769e1d307eb"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a140dface65370832588fb769e1d307eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs)</td></tr>
<tr class="separator:a140dface65370832588fb769e1d307eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940c88f3523bcd82ca2ddef367ebc313"><td class="memTemplParams" colspan="2"><a id="a940c88f3523bcd82ca2ddef367ebc313"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a940c88f3523bcd82ca2ddef367ebc313"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, const <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs)</td></tr>
<tr class="separator:a940c88f3523bcd82ca2ddef367ebc313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b721f5e74cb0ca5265fe914e09580ee"><td class="memTemplParams" colspan="2"><a id="a0b721f5e74cb0ca5265fe914e09580ee"></a>
template&lt;class T , std::size_t N, class A , bool Init&gt; </td></tr>
<tr class="memitem:a0b721f5e74cb0ca5265fe914e09580ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;lhs, <a class="el" href="classxt_1_1svector.html">svector</a>&lt; T, N, A, Init &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a0b721f5e74cb0ca5265fe914e09580ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa497f2d4a57bf126dc47eaddebfea5c6"><td class="memTemplParams" colspan="2"><a id="aa497f2d4a57bf126dc47eaddebfea5c6"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa497f2d4a57bf126dc47eaddebfea5c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:aa497f2d4a57bf126dc47eaddebfea5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad457465595632121fe37a81bee867240"><td class="memTemplParams" colspan="2"><a id="ad457465595632121fe37a81bee867240"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad457465595632121fe37a81bee867240"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:ad457465595632121fe37a81bee867240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e98cecc02c37c2eb071406995c8bff1"><td class="memTemplParams" colspan="2"><a id="a2e98cecc02c37c2eb071406995c8bff1"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a2e98cecc02c37c2eb071406995c8bff1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:a2e98cecc02c37c2eb071406995c8bff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6a56209779dbb965950d13f774f1e1"><td class="memTemplParams" colspan="2"><a id="a1c6a56209779dbb965950d13f774f1e1"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1c6a56209779dbb965950d13f774f1e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:a1c6a56209779dbb965950d13f774f1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b38028a96a5da28451784037addf79e"><td class="memTemplParams" colspan="2"><a id="a5b38028a96a5da28451784037addf79e"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5b38028a96a5da28451784037addf79e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:a5b38028a96a5da28451784037addf79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b0a3e47c93887750883c01a3d622c8"><td class="memTemplParams" colspan="2"><a id="a88b0a3e47c93887750883c01a3d622c8"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a88b0a3e47c93887750883c01a3d622c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;lhs, const <a class="el" href="structxt_1_1const__array.html">const_array</a>&lt; T, N &gt; &amp;rhs)</td></tr>
<tr class="separator:a88b0a3e47c93887750883c01a3d622c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455d3edd303c3250f262f4cff67eb682"><td class="memTemplParams" colspan="2"><a id="a455d3edd303c3250f262f4cff67eb682"></a>
template&lt;class T , std::ptrdiff_t TB, std::ptrdiff_t TE&gt; </td></tr>
<tr class="memitem:a455d3edd303c3250f262f4cff67eb682"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1sequence__view.html">sequence_view</a>&lt; T, TB, TE &gt; &amp;lhs, const <a class="el" href="classxt_1_1sequence__view.html">sequence_view</a>&lt; T, TB, TE &gt; &amp;rhs)</td></tr>
<tr class="separator:a455d3edd303c3250f262f4cff67eb682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9f3abdacf6929994b35d0ce30cdef7"><td class="memTemplParams" colspan="2"><a id="afc9f3abdacf6929994b35d0ce30cdef7"></a>
template&lt;class T , std::ptrdiff_t TB, std::ptrdiff_t TE&gt; </td></tr>
<tr class="memitem:afc9f3abdacf6929994b35d0ce30cdef7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classxt_1_1sequence__view.html">sequence_view</a>&lt; T, TB, TE &gt; &amp;lhs, const <a class="el" href="classxt_1_1sequence__view.html">sequence_view</a>&lt; T, TB, TE &gt; &amp;rhs)</td></tr>
<tr class="separator:afc9f3abdacf6929994b35d0ce30cdef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cb1a1805f292fca0ce0a8b8996110f"><td class="memTemplParams" colspan="2"><a id="a48cb1a1805f292fca0ce0a8b8996110f"></a>
template&lt;class shape_type &gt; </td></tr>
<tr class="memitem:a48cb1a1805f292fca0ce0a8b8996110f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_size</b> (const shape_type &amp;shape) noexcept</td></tr>
<tr class="separator:a48cb1a1805f292fca0ce0a8b8996110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21cd1e3942394c72dbe3d607cdb6025"><td class="memTemplParams" colspan="2"><a id="ac21cd1e3942394c72dbe3d607cdb6025"></a>
template&lt;class offset_type , class S &gt; </td></tr>
<tr class="memitem:ac21cd1e3942394c72dbe3d607cdb6025"><td class="memTemplItemLeft" align="right" valign="top">offset_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_offset</b> (const S &amp;strides) noexcept</td></tr>
<tr class="separator:ac21cd1e3942394c72dbe3d607cdb6025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcc575a1a2870d78b96ff674e700ec7"><td class="memTemplParams" colspan="2"><a id="a3bcc575a1a2870d78b96ff674e700ec7"></a>
template&lt;class offset_type , class S , class Arg , class... Args&gt; </td></tr>
<tr class="memitem:a3bcc575a1a2870d78b96ff674e700ec7"><td class="memTemplItemLeft" align="right" valign="top">offset_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>data_offset</b> (const S &amp;strides, Arg <a class="el" href="namespacext.html#a79e6cc463f0aeee688d90dcd320cd672">arg</a>, Args... args) noexcept</td></tr>
<tr class="separator:a3bcc575a1a2870d78b96ff674e700ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28087f5024e75d95d460029cd2445b74"><td class="memTemplParams" colspan="2"><a id="a28087f5024e75d95d460029cd2445b74"></a>
template&lt;class offset_type , layout_type L = layout_type::dynamic, class S , class... Args&gt; </td></tr>
<tr class="memitem:a28087f5024e75d95d460029cd2445b74"><td class="memTemplItemLeft" align="right" valign="top">offset_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unchecked_data_offset</b> (const S &amp;strides, Args... args) noexcept</td></tr>
<tr class="separator:a28087f5024e75d95d460029cd2445b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31ab6daa4131ad102f0121ee533d94f"><td class="memTemplParams" colspan="2"><a id="af31ab6daa4131ad102f0121ee533d94f"></a>
template&lt;class offset_type , class S , class It &gt; </td></tr>
<tr class="memitem:af31ab6daa4131ad102f0121ee533d94f"><td class="memTemplItemLeft" align="right" valign="top">offset_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>element_offset</b> (const S &amp;strides, It first, It last) noexcept</td></tr>
<tr class="separator:af31ab6daa4131ad102f0121ee533d94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b03c8046a44a3bf2d4800c7296ecefd"><td class="memTemplParams" colspan="2"><a id="a3b03c8046a44a3bf2d4800c7296ecefd"></a>
template&lt;layout_type L = layout_type::dynamic, class shape_type , class strides_type &gt; </td></tr>
<tr class="memitem:a3b03c8046a44a3bf2d4800c7296ecefd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_strides</b> (const shape_type &amp;shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l, strides_type &amp;strides)</td></tr>
<tr class="separator:a3b03c8046a44a3bf2d4800c7296ecefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc67bb5ee188decbb4454d3fcd8e138"><td class="memTemplParams" colspan="2"><a id="a4dc67bb5ee188decbb4454d3fcd8e138"></a>
template&lt;layout_type L = layout_type::dynamic, class shape_type , class strides_type , class backstrides_type &gt; </td></tr>
<tr class="memitem:a4dc67bb5ee188decbb4454d3fcd8e138"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_strides</b> (const shape_type &amp;shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l, strides_type &amp;strides, backstrides_type &amp;backstrides)</td></tr>
<tr class="separator:a4dc67bb5ee188decbb4454d3fcd8e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb2d215543196380ebced06df774ddf"><td class="memTemplParams" colspan="2"><a id="adfb2d215543196380ebced06df774ddf"></a>
template&lt;class shape_type , class strides_type &gt; </td></tr>
<tr class="memitem:adfb2d215543196380ebced06df774ddf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adapt_strides</b> (const shape_type &amp;shape, strides_type &amp;strides) noexcept</td></tr>
<tr class="separator:adfb2d215543196380ebced06df774ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ebc25aa5a2755b3b45afc999da9bef"><td class="memTemplParams" colspan="2"><a id="a62ebc25aa5a2755b3b45afc999da9bef"></a>
template&lt;class shape_type , class strides_type , class backstrides_type &gt; </td></tr>
<tr class="memitem:a62ebc25aa5a2755b3b45afc999da9bef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adapt_strides</b> (const shape_type &amp;shape, strides_type &amp;strides, backstrides_type &amp;backstrides) noexcept</td></tr>
<tr class="separator:a62ebc25aa5a2755b3b45afc999da9bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b405aff9367250baf84222f2da41f65"><td class="memTemplParams" colspan="2"><a id="a7b405aff9367250baf84222f2da41f65"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:a7b405aff9367250baf84222f2da41f65"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unravel_from_strides</b> (typename S::value_type index, const S &amp;strides, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l=<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">layout_type::row_major</a>)</td></tr>
<tr class="separator:a7b405aff9367250baf84222f2da41f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62634d7a6435ff6a9d88b8c4d0c7d95"><td class="memTemplParams" colspan="2"><a id="aa62634d7a6435ff6a9d88b8c4d0c7d95"></a>
template&lt;class S &gt; </td></tr>
<tr class="memitem:aa62634d7a6435ff6a9d88b8c4d0c7d95"><td class="memTemplItemLeft" align="right" valign="top">get_strides_t&lt; S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unravel_index</b> (typename S::value_type index, const S &amp;shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l=<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">layout_type::row_major</a>)</td></tr>
<tr class="separator:aa62634d7a6435ff6a9d88b8c4d0c7d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d5e94a4f70ae8c81886d20335242da"><td class="memTemplParams" colspan="2"><a id="a99d5e94a4f70ae8c81886d20335242da"></a>
template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:a99d5e94a4f70ae8c81886d20335242da"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; get_strides_t&lt; S &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unravel_indices</b> (const T &amp;indices, const S &amp;shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l=<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">layout_type::row_major</a>)</td></tr>
<tr class="separator:a99d5e94a4f70ae8c81886d20335242da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb351152f178adafd675deffac1c85"><td class="memTemplParams" colspan="2"><a id="a8ceb351152f178adafd675deffac1c85"></a>
template&lt;class S , class size_type &gt; </td></tr>
<tr class="memitem:a8ceb351152f178adafd675deffac1c85"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><b>uninitialized_shape</b> (size_type size)</td></tr>
<tr class="separator:a8ceb351152f178adafd675deffac1c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb8fba36845f127a55551a8f405b074"><td class="memTemplParams" colspan="2"><a id="a0fb8fba36845f127a55551a8f405b074"></a>
template&lt;class S1 , class S2 &gt; </td></tr>
<tr class="memitem:a0fb8fba36845f127a55551a8f405b074"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcast_shape</b> (const S1 &amp;input, S2 &amp;output)</td></tr>
<tr class="separator:a0fb8fba36845f127a55551a8f405b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab72e45b2a78ada5ff6e3a392a539196"><td class="memTemplParams" colspan="2"><a id="aab72e45b2a78ada5ff6e3a392a539196"></a>
template&lt;class S1 , class S2 &gt; </td></tr>
<tr class="memitem:aab72e45b2a78ada5ff6e3a392a539196"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcastable</b> (const S1 &amp;s1, S2 &amp;s2)</td></tr>
<tr class="separator:aab72e45b2a78ada5ff6e3a392a539196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f9ded8fbe013b13c186ae66474912d"><td class="memTemplParams" colspan="2"><a id="a42f9ded8fbe013b13c186ae66474912d"></a>
template&lt;class S , class... Args&gt; </td></tr>
<tr class="memitem:a42f9ded8fbe013b13c186ae66474912d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>in_bounds</b> (const S &amp;shape, Args &amp;... args)</td></tr>
<tr class="separator:a42f9ded8fbe013b13c186ae66474912d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa51177b0954ec061327dab5d8055ddb"><td class="memTemplParams" colspan="2"><a id="afa51177b0954ec061327dab5d8055ddb"></a>
template&lt;class S , class... Args&gt; </td></tr>
<tr class="memitem:afa51177b0954ec061327dab5d8055ddb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>normalize_periodic</b> (const S &amp;shape, Args &amp;... args)</td></tr>
<tr class="separator:afa51177b0954ec061327dab5d8055ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9a370f20056144df03b9a5298f0dd2"><td class="memTemplParams" colspan="2"><a id="a8e9a370f20056144df03b9a5298f0dd2"></a>
template&lt;class C , class It , class size_type &gt; </td></tr>
<tr class="memitem:a8e9a370f20056144df03b9a5298f0dd2"><td class="memTemplItemLeft" align="right" valign="top">It&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strided_data_end</b> (const C &amp;c, It begin, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l, size_type offset)</td></tr>
<tr class="separator:a8e9a370f20056144df03b9a5298f0dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68697053f16b2820924ee16fa5e8dfc"><td class="memTemplParams" colspan="2"><a id="af68697053f16b2820924ee16fa5e8dfc"></a>
template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:af68697053f16b2820924ee16fa5e8dfc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stride_match_condition</b> (const T1 &amp;stride, const T2 &amp;shape, const T1 &amp;data_size, bool zero_strides)</td></tr>
<tr class="separator:af68697053f16b2820924ee16fa5e8dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe4feab7005a0378a5a5462d92f5a1a"><td class="memTemplParams" colspan="2"><a id="adfe4feab7005a0378a5a5462d92f5a1a"></a>
template&lt;class shape_type , class strides_type &gt; </td></tr>
<tr class="memitem:adfe4feab7005a0378a5a5462d92f5a1a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>do_strides_match</b> (const shape_type &amp;shape, const strides_type &amp;strides, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l, bool zero_strides)</td></tr>
<tr class="separator:adfe4feab7005a0378a5a5462d92f5a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4be4b35cc4086faa4f1a12d69268e1"><td class="memTemplParams" colspan="2"><a id="aea4be4b35cc4086faa4f1a12d69268e1"></a>
template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:aea4be4b35cc4086faa4f1a12d69268e1"><td class="memTemplItemLeft" align="right" valign="top">get_value_type_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ravel_from_strides</b> (const T &amp;index, const S &amp;strides)</td></tr>
<tr class="separator:aea4be4b35cc4086faa4f1a12d69268e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535d9ce6ebe393170d80d32e25d77daf"><td class="memTemplParams" colspan="2"><a id="a535d9ce6ebe393170d80d32e25d77daf"></a>
template&lt;class S , class T &gt; </td></tr>
<tr class="memitem:a535d9ce6ebe393170d80d32e25d77daf"><td class="memTemplItemLeft" align="right" valign="top">get_value_type_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ravel_index</b> (const T &amp;index, const S &amp;shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l)</td></tr>
<tr class="separator:a535d9ce6ebe393170d80d32e25d77daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c7398476cca0c568168d5d3a33e905"><td class="memTemplParams" colspan="2"><a id="a93c7398476cca0c568168d5d3a33e905"></a>
template&lt;class S , class stype &gt; </td></tr>
<tr class="memitem:a93c7398476cca0c568168d5d3a33e905"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><b>uninitialized_shape</b> (stype size)</td></tr>
<tr class="separator:a93c7398476cca0c568168d5d3a33e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007cdb5b065b9487bc1aac7a3f1fe07"><td class="memTemplParams" colspan="2"><a id="a3007cdb5b065b9487bc1aac7a3f1fe07"></a>
template&lt;class S1 , class S2 &gt; </td></tr>
<tr class="memitem:a3007cdb5b065b9487bc1aac7a3f1fe07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>broadcastable</b> (const S1 &amp;src_shape, const S2 &amp;dst_shape)</td></tr>
<tr class="separator:a3007cdb5b065b9487bc1aac7a3f1fe07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883cf04b3f22a7b8273379eb8f93bdbb"><td class="memTemplParams" colspan="2"><a id="a883cf04b3f22a7b8273379eb8f93bdbb"></a>
template&lt;class S , class... Args&gt; </td></tr>
<tr class="memitem:a883cf04b3f22a7b8273379eb8f93bdbb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_in_bounds</b> (const S &amp;shape, Args &amp;... args)</td></tr>
<tr class="separator:a883cf04b3f22a7b8273379eb8f93bdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabb42f66c35d3fc5bb6d51b41eab928"><td class="memTemplParams" colspan="2"><a id="aaabb42f66c35d3fc5bb6d51b41eab928"></a>
template&lt;std::size_t I, class... Args&gt; </td></tr>
<tr class="memitem:aaabb42f66c35d3fc5bb6d51b41eab928"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>argument</b> (Args &amp;&amp;... args) noexcept</td></tr>
<tr class="separator:aaabb42f66c35d3fc5bb6d51b41eab928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2039583d2a61f634f0343bfcd9b32819"><td class="memTemplParams" colspan="2"><a id="a2039583d2a61f634f0343bfcd9b32819"></a>
template&lt;class R , class F , class... S&gt; </td></tr>
<tr class="memitem:a2039583d2a61f634f0343bfcd9b32819"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (std::size_t index, F &amp;&amp;func, const std::tuple&lt; S... &gt; &amp;s) noexcept(noexcept(func(std::get&lt; 0 &gt;(s))))</td></tr>
<tr class="separator:a2039583d2a61f634f0343bfcd9b32819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3900f91c57f29da57d4f26bb3aa66651"><td class="memTemplParams" colspan="2"><a id="a3900f91c57f29da57d4f26bb3aa66651"></a>
template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:a3900f91c57f29da57d4f26bb3aa66651"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nested_copy</b> (T &amp;&amp;iter, const S &amp;s)</td></tr>
<tr class="separator:a3900f91c57f29da57d4f26bb3aa66651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ea23aef4651371c98266bf8997469c"><td class="memTemplParams" colspan="2"><a id="ae9ea23aef4651371c98266bf8997469c"></a>
template&lt;class T , class S &gt; </td></tr>
<tr class="memitem:ae9ea23aef4651371c98266bf8997469c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nested_copy</b> (T &amp;&amp;iter, std::initializer_list&lt; S &gt; s)</td></tr>
<tr class="separator:ae9ea23aef4651371c98266bf8997469c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa177a13186987c02586aa480404ac0e8"><td class="memTemplParams" colspan="2"><a id="aa177a13186987c02586aa480404ac0e8"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:aa177a13186987c02586aa480404ac0e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>resize_container</b> (C &amp;c, typename C::size_type size)</td></tr>
<tr class="separator:aa177a13186987c02586aa480404ac0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab0005b4ddc1e4cab864e3c53cc91ee"><td class="memTemplParams" colspan="2"><a id="abab0005b4ddc1e4cab864e3c53cc91ee"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:abab0005b4ddc1e4cab864e3c53cc91ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>resize_container</b> (std::array&lt; T, N &gt; &amp;a, typename std::array&lt; T, N &gt;::size_type size)</td></tr>
<tr class="separator:abab0005b4ddc1e4cab864e3c53cc91ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d96aa76942a6b75f4319adb2af03e07"><td class="memTemplParams" colspan="2"><a id="a2d96aa76942a6b75f4319adb2af03e07"></a>
template&lt;std::size_t... I&gt; </td></tr>
<tr class="memitem:a2d96aa76942a6b75f4319adb2af03e07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>resize_container</b> (<a class="el" href="classxt_1_1fixed__shape.html">fixed_shape</a>&lt; I... &gt; &amp;a, std::size_t size)</td></tr>
<tr class="separator:a2d96aa76942a6b75f4319adb2af03e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bd5011b96e5b66c2a797343851b2bd"><td class="memItemLeft" align="right" valign="top"><a id="a68bd5011b96e5b66c2a797343851b2bd"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>normalize_axis</b> (std::size_t dim, std::ptrdiff_t axis)</td></tr>
<tr class="separator:a68bd5011b96e5b66c2a797343851b2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e23269aada3eda01847b4643eb89f8c"><td class="memTemplParams" colspan="2"><a id="a6e23269aada3eda01847b4643eb89f8c"></a>
template&lt;class F , class... T&gt; </td></tr>
<tr class="memitem:a6e23269aada3eda01847b4643eb89f8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each</b> (F &amp;&amp;f, std::tuple&lt; T... &gt; &amp;t) noexcept(noexcept(detail::for_each_impl&lt; 0, F, T... &gt;(std::forward&lt; F &gt;(f), t)))</td></tr>
<tr class="separator:a6e23269aada3eda01847b4643eb89f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d377ad8bfe49c32772c69bcd217071"><td class="memTemplParams" colspan="2"><a id="af1d377ad8bfe49c32772c69bcd217071"></a>
template&lt;class F , class... T&gt; </td></tr>
<tr class="memitem:af1d377ad8bfe49c32772c69bcd217071"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>for_each</b> (F &amp;&amp;f, const std::tuple&lt; T... &gt; &amp;t) noexcept(noexcept(detail::for_each_impl&lt; 0, F, T... &gt;(std::forward&lt; F &gt;(f), t)))</td></tr>
<tr class="separator:af1d377ad8bfe49c32772c69bcd217071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005f67f28ef56223fa56c657f5f262ad"><td class="memTemplParams" colspan="2"><a id="a005f67f28ef56223fa56c657f5f262ad"></a>
template&lt;class E , class C &gt; </td></tr>
<tr class="memitem:a005f67f28ef56223fa56c657f5f262ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!xtl::is_integral&lt; std::decay_t&lt; C &gt; &gt;::value &amp;&amp;xtl::is_signed&lt; typename std::decay_t&lt; C &gt;::value_type &gt;::value, rebind_container_t&lt; std::size_t, std::decay_t&lt; C &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>normalize_axis</b> (E &amp;expr, C &amp;&amp;axes)</td></tr>
<tr class="separator:a005f67f28ef56223fa56c657f5f262ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1877c52b4a2ad242fc9200c2fdf2e65"><td class="memTemplParams" colspan="2"><a id="aa1877c52b4a2ad242fc9200c2fdf2e65"></a>
template&lt;class C , class E &gt; </td></tr>
<tr class="memitem:aa1877c52b4a2ad242fc9200c2fdf2e65"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!xtl::is_integral&lt; std::decay_t&lt; C &gt; &gt;::value &amp;&amp;std::is_unsigned&lt; typename std::decay_t&lt; C &gt;::value_type &gt;::value, C &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>normalize_axis</b> (E &amp;expr, C &amp;&amp;axes)</td></tr>
<tr class="separator:aa1877c52b4a2ad242fc9200c2fdf2e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827cfe1306c0039dbbd7f76dcc4bc4ee"><td class="memTemplParams" colspan="2"><a id="a827cfe1306c0039dbbd7f76dcc4bc4ee"></a>
template&lt;class R , class E , class C &gt; </td></tr>
<tr class="memitem:a827cfe1306c0039dbbd7f76dcc4bc4ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>forward_normalize</b> (E &amp;expr, C &amp;&amp;axes) -&gt; std::enable_if_t&lt; xtl::is_signed&lt; std::decay_t&lt; decltype(*std::begin(axes))&gt;&gt;::value, R &gt;</td></tr>
<tr class="separator:a827cfe1306c0039dbbd7f76dcc4bc4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484706c866aa2ee94ce8a422d7a3a928"><td class="memTemplParams" colspan="2"><a id="a484706c866aa2ee94ce8a422d7a3a928"></a>
template&lt;std::size_t I, template&lt; typename... Args &gt; class T, typename ... Args&gt; </td></tr>
<tr class="memitem:a484706c866aa2ee94ce8a422d7a3a928"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (T&lt; Args... &gt; &amp;&amp;v)</td></tr>
<tr class="separator:a484706c866aa2ee94ce8a422d7a3a928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94b62b51822b8a288b6a422c871186a"><td class="memTemplParams" colspan="2"><a id="ab94b62b51822b8a288b6a422c871186a"></a>
template&lt;std::size_t I, template&lt; typename... Args &gt; class T, typename ... Args&gt; </td></tr>
<tr class="memitem:ab94b62b51822b8a288b6a422c871186a"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (T&lt; Args... &gt; &amp;v)</td></tr>
<tr class="separator:ab94b62b51822b8a288b6a422c871186a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98f7632afc5c9fc4be209979022c44d"><td class="memTemplParams" colspan="2"><a id="ae98f7632afc5c9fc4be209979022c44d"></a>
template&lt;std::size_t I, template&lt; typename... Args &gt; class T, typename ... Args&gt; </td></tr>
<tr class="memitem:ae98f7632afc5c9fc4be209979022c44d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const T&lt; Args... &gt; &amp;v)</td></tr>
<tr class="separator:ae98f7632afc5c9fc4be209979022c44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cbf616acd2f650182bc408f46a341e"><td class="memTemplParams" colspan="2"><a id="a28cbf616acd2f650182bc408f46a341e"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a28cbf616acd2f650182bc408f46a341e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; std::remove_cv_t&lt; T &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_array</b> (T(&amp;a)[N])</td></tr>
<tr class="separator:a28cbf616acd2f650182bc408f46a341e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e4d7a6138e79eca4aeff6fbd1c58ec"><td class="memTemplParams" colspan="2"><a id="a04e4d7a6138e79eca4aeff6fbd1c58ec"></a>
template&lt;class C &gt; </td></tr>
<tr class="memitem:a04e4d7a6138e79eca4aeff6fbd1c58ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequence_size</b> (const C &amp;c) -&gt; decltype(c.size())</td></tr>
<tr class="separator:a04e4d7a6138e79eca4aeff6fbd1c58ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10555a3d6c847a0f369075616160589e"><td class="memTemplParams" colspan="2"><a id="a10555a3d6c847a0f369075616160589e"></a>
template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a10555a3d6c847a0f369075616160589e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sequence_size</b> (const T(&amp;)[N])</td></tr>
<tr class="separator:a10555a3d6c847a0f369075616160589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af155a86146879d345b8acaa16d48c748"><td class="memTemplParams" colspan="2">template&lt;bool condition, class T , class U &gt; </td></tr>
<tr class="memitem:af155a86146879d345b8acaa16d48c748"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af155a86146879d345b8acaa16d48c748">conditional_cast</a> (U &amp;&amp;u)</td></tr>
<tr class="memdesc:af155a86146879d345b8acaa16d48c748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a type cast when a condition is true.  <a href="namespacext.html#af155a86146879d345b8acaa16d48c748">More...</a><br /></td></tr>
<tr class="separator:af155a86146879d345b8acaa16d48c748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4599aeaff973b77ef1f93aeeb8b3e2"><td class="memTemplParams" colspan="2"><a id="aba4599aeaff973b77ef1f93aeeb8b3e2"></a>
template&lt;class T , class AT , alloc_tracking::policy PT, class U , class AU , alloc_tracking::policy PU&gt; </td></tr>
<tr class="memitem:aba4599aeaff973b77ef1f93aeeb8b3e2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structxt_1_1tracking__allocator.html">tracking_allocator</a>&lt; T, AT, PT &gt; &amp;, const <a class="el" href="structxt_1_1tracking__allocator.html">tracking_allocator</a>&lt; U, AU, PU &gt; &amp;)</td></tr>
<tr class="separator:aba4599aeaff973b77ef1f93aeeb8b3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60831a10d78af0b1801a2ee0c5f43ca6"><td class="memTemplParams" colspan="2"><a id="a60831a10d78af0b1801a2ee0c5f43ca6"></a>
template&lt;class T , class AT , alloc_tracking::policy PT, class U , class AU , alloc_tracking::policy PU&gt; </td></tr>
<tr class="memitem:a60831a10d78af0b1801a2ee0c5f43ca6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structxt_1_1tracking__allocator.html">tracking_allocator</a>&lt; T, AT, PT &gt; &amp;a, const <a class="el" href="structxt_1_1tracking__allocator.html">tracking_allocator</a>&lt; U, AU, PU &gt; &amp;b)</td></tr>
<tr class="separator:a60831a10d78af0b1801a2ee0c5f43ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a38ea55244a6081c5917d640cc42fd"><td class="memTemplParams" colspan="2"><a id="a12a38ea55244a6081c5917d640cc42fd"></a>
template&lt;class R , class... Args&gt; </td></tr>
<tr class="memitem:a12a38ea55244a6081c5917d640cc42fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xvectorizer.html">xvectorizer</a>&lt; R(*)(Args...), R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (R(*f)(Args...))</td></tr>
<tr class="separator:a12a38ea55244a6081c5917d640cc42fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130831e301fe235e99c337202f1a7ba6"><td class="memTemplParams" colspan="2"><a id="a130831e301fe235e99c337202f1a7ba6"></a>
template&lt;class F , class R , class... Args&gt; </td></tr>
<tr class="memitem:a130831e301fe235e99c337202f1a7ba6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xvectorizer.html">xvectorizer</a>&lt; F, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (F &amp;&amp;f, R(*)(Args...))</td></tr>
<tr class="separator:a130831e301fe235e99c337202f1a7ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cfdee4d9e2784e09f09127e7982a75"><td class="memTemplParams" colspan="2"><a id="a21cfdee4d9e2784e09f09127e7982a75"></a>
template&lt;class F &gt; </td></tr>
<tr class="memitem:a21cfdee4d9e2784e09f09127e7982a75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorize</b> (F &amp;&amp;f) -&gt; decltype(vectorize(std::forward&lt; F &gt;(f), std::declval&lt; detail::get_function_type&lt; F &gt; * &gt;()))</td></tr>
<tr class="separator:a21cfdee4d9e2784e09f09127e7982a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bba33fff9f307fd3de1593fa7c2273c"><td class="memTemplParams" colspan="2"><a id="a5bba33fff9f307fd3de1593fa7c2273c"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:a5bba33fff9f307fd3de1593fa7c2273c"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_count</b> ()</td></tr>
<tr class="separator:a5bba33fff9f307fd3de1593fa7c2273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e263141c4ff74e228ad7509b19cceb"><td class="memTemplParams" colspan="2"><a id="a45e263141c4ff74e228ad7509b19cceb"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:a45e263141c4ff74e228ad7509b19cceb"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_count_before</b> (std::size_t i)</td></tr>
<tr class="separator:a45e263141c4ff74e228ad7509b19cceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa7e487003ea729c9ca0ce33e937814"><td class="memTemplParams" colspan="2"><a id="a4aa7e487003ea729c9ca0ce33e937814"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:a4aa7e487003ea729c9ca0ce33e937814"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>integral_skip</b> (std::size_t i)</td></tr>
<tr class="separator:a4aa7e487003ea729c9ca0ce33e937814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd43e351e933750db53b19c10a06230"><td class="memTemplParams" colspan="2"><a id="a7cd43e351e933750db53b19c10a06230"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:a7cd43e351e933750db53b19c10a06230"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>newaxis_count</b> ()</td></tr>
<tr class="separator:a7cd43e351e933750db53b19c10a06230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ddac56019964a876681e05570febdd"><td class="memTemplParams" colspan="2"><a id="ac6ddac56019964a876681e05570febdd"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:ac6ddac56019964a876681e05570febdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>newaxis_count_before</b> (std::size_t i)</td></tr>
<tr class="separator:ac6ddac56019964a876681e05570febdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3da33ccf36a391c2f0a45f7b7a6da89"><td class="memTemplParams" colspan="2"><a id="aa3da33ccf36a391c2f0a45f7b7a6da89"></a>
template&lt;class... S&gt; </td></tr>
<tr class="memitem:aa3da33ccf36a391c2f0a45f7b7a6da89"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>newaxis_skip</b> (std::size_t i)</td></tr>
<tr class="separator:aa3da33ccf36a391c2f0a45f7b7a6da89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c99782d1951929f4bc0e425f21aae0e"><td class="memTemplParams" colspan="2"><a id="a1c99782d1951929f4bc0e425f21aae0e"></a>
template&lt;class S , class It &gt; </td></tr>
<tr class="memitem:a1c99782d1951929f4bc0e425f21aae0e"><td class="memTemplItemLeft" align="right" valign="top">disable_xslice&lt; S, std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_slice_value</b> (const S &amp;s, It &amp;) noexcept</td></tr>
<tr class="separator:a1c99782d1951929f4bc0e425f21aae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd9014e14589db5e8252fd0e459685e"><td class="memTemplParams" colspan="2"><a id="a2bd9014e14589db5e8252fd0e459685e"></a>
template&lt;class S , class It &gt; </td></tr>
<tr class="memitem:a2bd9014e14589db5e8252fd0e459685e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_slice_value</b> (const <a class="el" href="classxt_1_1xslice.html">xslice</a>&lt; S &gt; &amp;slice, It &amp;it) noexcept</td></tr>
<tr class="separator:a2bd9014e14589db5e8252fd0e459685e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reference</div></td></tr>
<tr class="memitem:a49dd71cabe349f77ec771f01fc46aeb3"><td class="memTemplParams" colspan="2">template&lt;class CT &gt; </td></tr>
<tr class="memitem:a49dd71cabe349f77ec771f01fc46aeb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a49dd71cabe349f77ec771f01fc46aeb3">operator==</a> (const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a49dd71cabe349f77ec771f01fc46aeb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality of the iterators.  <a href="namespacext.html#a49dd71cabe349f77ec771f01fc46aeb3">More...</a><br /></td></tr>
<tr class="separator:a49dd71cabe349f77ec771f01fc46aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb4918c6aea49e7968e4ed024a70a99"><td class="memTemplParams" colspan="2">template&lt;class CT &gt; </td></tr>
<tr class="memitem:aafb4918c6aea49e7968e4ed024a70a99"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aafb4918c6aea49e7968e4ed024a70a99">operator!=</a> (const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aafb4918c6aea49e7968e4ed024a70a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks inequality of the iterators.  <a href="namespacext.html#aafb4918c6aea49e7968e4ed024a70a99">More...</a><br /></td></tr>
<tr class="separator:aafb4918c6aea49e7968e4ed024a70a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8afbf971ca9887515e974de1775cf03"><td class="memTemplParams" colspan="2">template&lt;class CT &gt; </td></tr>
<tr class="memitem:aa8afbf971ca9887515e974de1775cf03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aa8afbf971ca9887515e974de1775cf03">operator==</a> (const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa8afbf971ca9887515e974de1775cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality of the iterators.  <a href="namespacext.html#aa8afbf971ca9887515e974de1775cf03">More...</a><br /></td></tr>
<tr class="separator:aa8afbf971ca9887515e974de1775cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e99b6c54f3a5fca29006d1b114e356d"><td class="memTemplParams" colspan="2">template&lt;class CT &gt; </td></tr>
<tr class="memitem:a1e99b6c54f3a5fca29006d1b114e356d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a1e99b6c54f3a5fca29006d1b114e356d">operator!=</a> (const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a1e99b6c54f3a5fca29006d1b114e356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks inequality of the iterators.  <a href="namespacext.html#a1e99b6c54f3a5fca29006d1b114e356d">More...</a><br /></td></tr>
<tr class="separator:a1e99b6c54f3a5fca29006d1b114e356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr class="memitem:a10d6b6dddf20a721f48bec57deee85c1"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a10d6b6dddf20a721f48bec57deee85c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a10d6b6dddf20a721f48bec57deee85c1">axis_begin</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a10d6b6dddf20a721f48bec57deee85c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the expression for axis 0.  <a href="namespacext.html#a10d6b6dddf20a721f48bec57deee85c1">More...</a><br /></td></tr>
<tr class="separator:a10d6b6dddf20a721f48bec57deee85c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff80d8045ec5b2276cb70d3171890ef"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:aeff80d8045ec5b2276cb70d3171890ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aeff80d8045ec5b2276cb70d3171890ef">axis_begin</a> (E &amp;&amp;e, typename std::decay_t&lt; E &gt;::size_type axis)</td></tr>
<tr class="memdesc:aeff80d8045ec5b2276cb70d3171890ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the expression for the specified axis.  <a href="namespacext.html#aeff80d8045ec5b2276cb70d3171890ef">More...</a><br /></td></tr>
<tr class="separator:aeff80d8045ec5b2276cb70d3171890ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8febb08b64e215650861f319845e0ba8"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a8febb08b64e215650861f319845e0ba8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a8febb08b64e215650861f319845e0ba8">axis_end</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a8febb08b64e215650861f319845e0ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the expression for axis 0.  <a href="namespacext.html#a8febb08b64e215650861f319845e0ba8">More...</a><br /></td></tr>
<tr class="separator:a8febb08b64e215650861f319845e0ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9d61065999823b0947aac4741a5255"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a6a9d61065999823b0947aac4741a5255"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a6a9d61065999823b0947aac4741a5255">axis_end</a> (E &amp;&amp;e, typename std::decay_t&lt; E &gt;::size_type axis)</td></tr>
<tr class="memdesc:a6a9d61065999823b0947aac4741a5255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the expression for the specified axis.  <a href="namespacext.html#a6a9d61065999823b0947aac4741a5255">More...</a><br /></td></tr>
<tr class="separator:a6a9d61065999823b0947aac4741a5255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac347d148c68881cdf4f5dbc488dc02bf"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ac347d148c68881cdf4f5dbc488dc02bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ac347d148c68881cdf4f5dbc488dc02bf">axis_slice_begin</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:ac347d148c68881cdf4f5dbc488dc02bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the expression for axis 0.  <a href="namespacext.html#ac347d148c68881cdf4f5dbc488dc02bf">More...</a><br /></td></tr>
<tr class="separator:ac347d148c68881cdf4f5dbc488dc02bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a64b30629191a33452d47762e67386b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a2a64b30629191a33452d47762e67386b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a2a64b30629191a33452d47762e67386b">axis_slice_begin</a> (E &amp;&amp;e, typename std::decay_t&lt; E &gt;::size_type axis)</td></tr>
<tr class="memdesc:a2a64b30629191a33452d47762e67386b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the expression for the specified axis.  <a href="namespacext.html#a2a64b30629191a33452d47762e67386b">More...</a><br /></td></tr>
<tr class="separator:a2a64b30629191a33452d47762e67386b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af214429c748c24ec2f26271be60ff9ea"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:af214429c748c24ec2f26271be60ff9ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#af214429c748c24ec2f26271be60ff9ea">axis_slice_end</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:af214429c748c24ec2f26271be60ff9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the expression for axis 0.  <a href="namespacext.html#af214429c748c24ec2f26271be60ff9ea">More...</a><br /></td></tr>
<tr class="separator:af214429c748c24ec2f26271be60ff9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a091d187f0ba564daabc12be1725ca"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a79a091d187f0ba564daabc12be1725ca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a79a091d187f0ba564daabc12be1725ca">axis_slice_end</a> (E &amp;&amp;e, typename std::decay_t&lt; E &gt;::size_type axis)</td></tr>
<tr class="memdesc:a79a091d187f0ba564daabc12be1725ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the element following the last element of the expression for the specified axis.  <a href="namespacext.html#a79a091d187f0ba564daabc12be1725ca">More...</a><br /></td></tr>
<tr class="separator:a79a091d187f0ba564daabc12be1725ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Broadcasting</div></td></tr>
<tr class="memitem:a0df5cd5480ba0d774ff8612c9b53dbae"><td class="memTemplParams" colspan="2"><a id="a0df5cd5480ba0d774ff8612c9b53dbae"></a>
template&lt;class F , class... CT&gt; </td></tr>
<tr class="memitem:a0df5cd5480ba0d774ff8612c9b53dbae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1xfunction__iterator.html">xfunction_iterator</a>&lt; F, CT... &gt; &amp;it1, const <a class="el" href="classxt_1_1xfunction__iterator.html">xfunction_iterator</a>&lt; F, CT... &gt; &amp;it2)</td></tr>
<tr class="separator:a0df5cd5480ba0d774ff8612c9b53dbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88902eb40ae9fe68abdc85309d9601d4"><td class="memTemplParams" colspan="2"><a id="a88902eb40ae9fe68abdc85309d9601d4"></a>
template&lt;class F , class... CT&gt; </td></tr>
<tr class="memitem:a88902eb40ae9fe68abdc85309d9601d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1xfunction__iterator.html">xfunction_iterator</a>&lt; F, CT... &gt; &amp;it1, const <a class="el" href="classxt_1_1xfunction__iterator.html">xfunction_iterator</a>&lt; F, CT... &gt; &amp;it2)</td></tr>
<tr class="separator:a88902eb40ae9fe68abdc85309d9601d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc2027ff309134dff5b0720699c5ffa"><td class="memTemplParams" colspan="2">template&lt;class E , class... S&gt; </td></tr>
<tr class="memitem:aedc2027ff309134dff5b0720699c5ffa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa">view</a> (E &amp;&amp;e, S &amp;&amp;... slices)</td></tr>
<tr class="memdesc:aedc2027ff309134dff5b0720699c5ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a view on the specified xexpression.  <a href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa">More...</a><br /></td></tr>
<tr class="separator:aedc2027ff309134dff5b0720699c5ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445fa98828eab51048b87fc29d8e88ad"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a445fa98828eab51048b87fc29d8e88ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a445fa98828eab51048b87fc29d8e88ad">row</a> (E &amp;&amp;e, std::ptrdiff_t index)</td></tr>
<tr class="memdesc:a445fa98828eab51048b87fc29d8e88ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a row (sliced view) on the specified expression.  <a href="namespacext.html#a445fa98828eab51048b87fc29d8e88ad">More...</a><br /></td></tr>
<tr class="separator:a445fa98828eab51048b87fc29d8e88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5772db4fd8ebf31bc242dd1c2d2ddd1b"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a5772db4fd8ebf31bc242dd1c2d2ddd1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a5772db4fd8ebf31bc242dd1c2d2ddd1b">col</a> (E &amp;&amp;e, std::ptrdiff_t index)</td></tr>
<tr class="memdesc:a5772db4fd8ebf31bc242dd1c2d2ddd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs and returns a column (sliced view) on the specified expression.  <a href="namespacext.html#a5772db4fd8ebf31bc242dd1c2d2ddd1b">More...</a><br /></td></tr>
<tr class="separator:a5772db4fd8ebf31bc242dd1c2d2ddd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computed assignement</div></td></tr>
<tr class="memitem:abb28cb642ab427195ca6120d59f34f76"><td class="memTemplParams" colspan="2">template&lt;class E , class I &gt; </td></tr>
<tr class="memitem:abb28cb642ab427195ca6120d59f34f76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#abb28cb642ab427195ca6120d59f34f76">index_view</a> (E &amp;&amp;e, I &amp;&amp;indices) noexcept</td></tr>
<tr class="memdesc:abb28cb642ab427195ca6120d59f34f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an indexview from a container of indices.  <a href="namespacext.html#abb28cb642ab427195ca6120d59f34f76">More...</a><br /></td></tr>
<tr class="separator:abb28cb642ab427195ca6120d59f34f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634a2ef5030e354e0a6da1185d674be0"><td class="memTemplParams" colspan="2"><a id="a634a2ef5030e354e0a6da1185d674be0"></a>
template&lt;class E , std::size_t L&gt; </td></tr>
<tr class="memitem:a634a2ef5030e354e0a6da1185d674be0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>index_view</b> (E &amp;&amp;e, const <a class="el" href="classxt_1_1svector.html">xindex</a>(&amp;indices)[L]) noexcept</td></tr>
<tr class="separator:a634a2ef5030e354e0a6da1185d674be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36e1cf727c1a3ea6c7889f149c0737b"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E , class O &gt; </td></tr>
<tr class="memitem:ae36e1cf727c1a3ea6c7889f149c0737b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae36e1cf727c1a3ea6c7889f149c0737b">filter</a> (E &amp;&amp;e, O &amp;&amp;condition) noexcept</td></tr>
<tr class="memdesc:ae36e1cf727c1a3ea6c7889f149c0737b"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a view into <em>e</em> filtered by <em>condition</em>.  <a href="namespacext.html#ae36e1cf727c1a3ea6c7889f149c0737b">More...</a><br /></td></tr>
<tr class="separator:ae36e1cf727c1a3ea6c7889f149c0737b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588bc1e3b2c1f7c9b8238dddaf05a9df"><td class="memTemplParams" colspan="2">template&lt;class E , class C &gt; </td></tr>
<tr class="memitem:a588bc1e3b2c1f7c9b8238dddaf05a9df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a588bc1e3b2c1f7c9b8238dddaf05a9df">filtration</a> (E &amp;&amp;e, C &amp;&amp;condition) noexcept</td></tr>
<tr class="memdesc:a588bc1e3b2c1f7c9b8238dddaf05a9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a filtration of <code>e</code> filtered by <em>condition</em>.  <a href="namespacext.html#a588bc1e3b2c1f7c9b8238dddaf05a9df">More...</a><br /></td></tr>
<tr class="separator:a588bc1e3b2c1f7c9b8238dddaf05a9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data</div></td></tr>
<tr class="memitem:a204e3f61b092a36cd21583d550fc33f0"><td class="memTemplParams" colspan="2"><a id="a204e3f61b092a36cd21583d550fc33f0"></a>
template&lt;class CTD , class CTM &gt; </td></tr>
<tr class="memitem:a204e3f61b092a36cd21583d550fc33f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xmasked__view.html">xmasked_view</a>&lt; CTD, CTM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>masked_view</b> (CTD &amp;&amp;data, CTM &amp;&amp;mask)</td></tr>
<tr class="separator:a204e3f61b092a36cd21583d550fc33f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6714111810062b91a1c9e31bd69b26"><td class="memTemplParams" colspan="2">template&lt;layout_type L = layout_type::dynamic, class E , class S , class X &gt; </td></tr>
<tr class="memitem:aca6714111810062b91a1c9e31bd69b26"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26">strided_view</a> (E &amp;&amp;e, S &amp;&amp;shape, X &amp;&amp;strides, std::size_t offset, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> layout) noexcept</td></tr>
<tr class="memdesc:aca6714111810062b91a1c9e31bd69b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a strided view from an xexpression, shape, strides and offset.  <a href="namespacext.html#aca6714111810062b91a1c9e31bd69b26">More...</a><br /></td></tr>
<tr class="separator:aca6714111810062b91a1c9e31bd69b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c7088d2beee486998238fbc29ee7b9"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ae5c7088d2beee486998238fbc29ee7b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ae5c7088d2beee486998238fbc29ee7b9">strided_view</a> (E &amp;&amp;e, const <a class="el" href="namespacext.html#a6e111c2e160e2edb6a2139d16c66d65a">xstrided_slice_vector</a> &amp;slices)</td></tr>
<tr class="memdesc:ae5c7088d2beee486998238fbc29ee7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create a dynamic view from an xexpression and an xstrided_slice_vector.  <a href="namespacext.html#ae5c7088d2beee486998238fbc29ee7b9">More...</a><br /></td></tr>
<tr class="separator:ae5c7088d2beee486998238fbc29ee7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea5a790ce39a21b24b486f32b25ce00"><td class="memTemplParams" colspan="2"><a id="a2ea5a790ce39a21b24b486f32b25ce00"></a>
template&lt;layout_type L = ::xt::layout_type::row_major, class E , class S &gt; </td></tr>
<tr class="memitem:a2ea5a790ce39a21b24b486f32b25ce00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reshape_view</b> (E &amp;&amp;e, S &amp;&amp;shape)</td></tr>
<tr class="separator:a2ea5a790ce39a21b24b486f32b25ce00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda1677287d8bee76befd8c427e3898"><td class="memTemplParams" colspan="2">template&lt;layout_type L = ::xt::layout_type::row_major, class E , class S &gt; </td></tr>
<tr class="memitem:a7bda1677287d8bee76befd8c427e3898"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a7bda1677287d8bee76befd8c427e3898">reshape_view</a> (E &amp;&amp;e, S &amp;&amp;shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>)</td></tr>
<tr class="memdesc:a7bda1677287d8bee76befd8c427e3898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a view on a container with a new shape.  <a href="namespacext.html#a7bda1677287d8bee76befd8c427e3898">More...</a><br /></td></tr>
<tr class="separator:a7bda1677287d8bee76befd8c427e3898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251d99e1e75ec473fff0cca302d091bd"><td class="memTemplParams" colspan="2"><a id="a251d99e1e75ec473fff0cca302d091bd"></a>
template&lt;layout_type L = ::xt::layout_type::row_major, class E , class I , std::size_t N&gt; </td></tr>
<tr class="memitem:a251d99e1e75ec473fff0cca302d091bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reshape_view</b> (E &amp;&amp;e, const I(&amp;shape)[N], <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> order)</td></tr>
<tr class="separator:a251d99e1e75ec473fff0cca302d091bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bbe5885d14453cb73e9ceab3314ffa"><td class="memTemplParams" colspan="2"><a id="ab2bbe5885d14453cb73e9ceab3314ffa"></a>
template&lt;layout_type L = ::xt::layout_type::row_major, class E , class I , std::size_t N&gt; </td></tr>
<tr class="memitem:ab2bbe5885d14453cb73e9ceab3314ffa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reshape_view</b> (E &amp;&amp;e, const I(&amp;shape)[N])</td></tr>
<tr class="separator:ab2bbe5885d14453cb73e9ceab3314ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac30a3b739582fbcf8c42a96e3571c680"><td class="memItemLeft" align="right" valign="top"><a id="ac30a3b739582fbcf8c42a96e3571c680"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>keep_dims</b> = std::tuple&lt;<a class="el" href="structxt_1_1keep__dims__type.html">keep_dims_type</a>&gt;{}</td></tr>
<tr class="separator:ac30a3b739582fbcf8c42a96e3571c680"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Downcast functions</h2></td></tr>
<tr class="memitem:a2c475cb62a3dc8a88f965483cf8283b8"><td class="memTemplParams" colspan="2"><a id="a2c475cb62a3dc8a88f965483cf8283b8"></a>
template&lt;template&lt; class &gt; class B, class E &gt; </td></tr>
<tr class="memitem:a2c475cb62a3dc8a88f965483cf8283b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_crtp_base_of</b> = detail::is_crtp_base_of_impl&lt; B, std::decay_t&lt; E &gt; &gt;</td></tr>
<tr class="separator:a2c475cb62a3dc8a88f965483cf8283b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb8d6f6ae51a4d88cbce07eda93c920"><td class="memTemplParams" colspan="2"><a id="acfb8d6f6ae51a4d88cbce07eda93c920"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:acfb8d6f6ae51a4d88cbce07eda93c920"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_xexpression</b> = is_crtp_base_of&lt; <a class="el" href="classxt_1_1xexpression.html">xexpression</a>, E &gt;</td></tr>
<tr class="separator:acfb8d6f6ae51a4d88cbce07eda93c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d725b73c78e485ce4398abf906ebf"><td class="memTemplParams" colspan="2"><a id="ada2d725b73c78e485ce4398abf906ebf"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:ada2d725b73c78e485ce4398abf906ebf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_xexpression</b> = typename std::enable_if&lt; is_xexpression&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:ada2d725b73c78e485ce4398abf906ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a58c2f48de03c1b25a281b5daaf5791"><td class="memTemplParams" colspan="2"><a id="a8a58c2f48de03c1b25a281b5daaf5791"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:a8a58c2f48de03c1b25a281b5daaf5791"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_xexpression</b> = typename std::enable_if&lt;!is_xexpression&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a8a58c2f48de03c1b25a281b5daaf5791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2b3cc6fe5f09870816e7552385471c"><td class="memTemplParams" colspan="2"><a id="a2b2b3cc6fe5f09870816e7552385471c"></a>
template&lt;class... E&gt; </td></tr>
<tr class="memitem:a2b2b3cc6fe5f09870816e7552385471c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_xexpression</b> = xtl::disjunction&lt; is_xexpression&lt; E &gt;... &gt;</td></tr>
<tr class="separator:a2b2b3cc6fe5f09870816e7552385471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fe13d9e6130dc5f643d67bbebae194"><td class="memTemplParams" colspan="2"><a id="a45fe13d9e6130dc5f643d67bbebae194"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a45fe13d9e6130dc5f643d67bbebae194"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_xsharable_expression</b> = is_crtp_base_of&lt; <a class="el" href="classxt_1_1xsharable__expression.html">xsharable_expression</a>, E &gt;</td></tr>
<tr class="separator:a45fe13d9e6130dc5f643d67bbebae194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee72850ddcfa07e43d7f1a537ff09e0"><td class="memTemplParams" colspan="2"><a id="aaee72850ddcfa07e43d7f1a537ff09e0"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:aaee72850ddcfa07e43d7f1a537ff09e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_xsharable_expression</b> = typename std::enable_if&lt; is_xsharable_expression&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:aaee72850ddcfa07e43d7f1a537ff09e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a666d4e2b273e57b610f6894b4f564"><td class="memTemplParams" colspan="2"><a id="ad5a666d4e2b273e57b610f6894b4f564"></a>
template&lt;class E , class R  = void&gt; </td></tr>
<tr class="memitem:ad5a666d4e2b273e57b610f6894b4f564"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>disable_xsharable_expression</b> = typename std::enable_if&lt;!is_xsharable_expression&lt; E &gt;::value, R &gt;::type</td></tr>
<tr class="separator:ad5a666d4e2b273e57b610f6894b4f564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360d1039e3b664e5e7a898ca72957806"><td class="memTemplParams" colspan="2"><a id="a360d1039e3b664e5e7a898ca72957806"></a>
template&lt;class LHS , class RHS , class R  = void&gt; </td></tr>
<tr class="memitem:a360d1039e3b664e5e7a898ca72957806"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_assignable_expression</b> = typename std::enable_if&lt; <a class="el" href="structxt_1_1can__assign.html">can_assign</a>&lt; LHS, RHS &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a360d1039e3b664e5e7a898ca72957806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228297a86f7db5754e8c8136f6a6cdd8"><td class="memTemplParams" colspan="2"><a id="a228297a86f7db5754e8c8136f6a6cdd8"></a>
template&lt;class LHS , class RHS , class R  = void&gt; </td></tr>
<tr class="memitem:a228297a86f7db5754e8c8136f6a6cdd8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_not_assignable_expression</b> = typename std::enable_if&lt;!<a class="el" href="structxt_1_1can__assign.html">can_assign</a>&lt; LHS, RHS &gt;::value, R &gt;::type</td></tr>
<tr class="separator:a228297a86f7db5754e8c8136f6a6cdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cfbb0a13ea3642916bcc0aa4444ee9"><td class="memTemplParams" colspan="2"><a id="a80cfbb0a13ea3642916bcc0aa4444ee9"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a80cfbb0a13ea3642916bcc0aa4444ee9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xclosure_t</b> = typename <a class="el" href="structxt_1_1xclosure.html">xclosure</a>&lt; E &gt;::type</td></tr>
<tr class="separator:a80cfbb0a13ea3642916bcc0aa4444ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6eda1f9ca7a0ead2390f2f48825bb7"><td class="memTemplParams" colspan="2"><a id="a4d6eda1f9ca7a0ead2390f2f48825bb7"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a4d6eda1f9ca7a0ead2390f2f48825bb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>const_xclosure_t</b> = typename <a class="el" href="structxt_1_1const__xclosure.html">const_xclosure</a>&lt; E &gt;::type</td></tr>
<tr class="separator:a4d6eda1f9ca7a0ead2390f2f48825bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ae3f94418bfab24829fac827663a1b"><td class="memTemplParams" colspan="2"><a id="a51ae3f94418bfab24829fac827663a1b"></a>
template&lt;class... T&gt; </td></tr>
<tr class="memitem:a51ae3f94418bfab24829fac827663a1b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xexpression_tag_t</b> = typename <a class="el" href="structxt_1_1xexpression__tag.html">xexpression_tag</a>&lt; T... &gt;::type</td></tr>
<tr class="separator:a51ae3f94418bfab24829fac827663a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560c81d3d88fa9b3200b72e70b44c288"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a560c81d3d88fa9b3200b72e70b44c288"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classxt_1_1xshared__expression.html">xshared_expression</a>&lt; E &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a560c81d3d88fa9b3200b72e70b44c288">make_xshared</a> (<a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&amp;expr)</td></tr>
<tr class="memdesc:a560c81d3d88fa9b3200b72e70b44c288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create shared expression from any xexpression.  <a href="namespacext.html#a560c81d3d88fa9b3200b72e70b44c288">More...</a><br /></td></tr>
<tr class="separator:a560c81d3d88fa9b3200b72e70b44c288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39563f02e935d00d2df74796f2e19fb0"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:a39563f02e935d00d2df74796f2e19fb0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a39563f02e935d00d2df74796f2e19fb0">share</a> (<a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;expr)</td></tr>
<tr class="memdesc:a39563f02e935d00d2df74796f2e19fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create shared expression from any xexpression.  <a href="namespacext.html#a39563f02e935d00d2df74796f2e19fb0">More...</a><br /></td></tr>
<tr class="separator:a39563f02e935d00d2df74796f2e19fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90d6213ecfc3ae99eba87429935a38a"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ad90d6213ecfc3ae99eba87429935a38a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad90d6213ecfc3ae99eba87429935a38a">share</a> (<a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&amp;expr)</td></tr>
<tr class="memdesc:ad90d6213ecfc3ae99eba87429935a38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create shared expression from any xexpression.  <a href="namespacext.html#ad90d6213ecfc3ae99eba87429935a38a">More...</a><br /></td></tr>
<tr class="separator:ad90d6213ecfc3ae99eba87429935a38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Extended copy semantic</h2></td></tr>
<tr class="memitem:a6876d1118edbd76472a4ab3e350f12a8"><td class="memTemplParams" colspan="2"><a id="a6876d1118edbd76472a4ab3e350f12a8"></a>
template&lt;class C , class Tag &gt; </td></tr>
<tr class="memitem:a6876d1118edbd76472a4ab3e350f12a8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ravel_return_type_t</b> = typename detail::ravel_return_type&lt; C, Tag &gt;::type</td></tr>
<tr class="separator:a6876d1118edbd76472a4ab3e350f12a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af618f07531f4080922e4614c627049a6"><td class="memTemplParams" colspan="2"><a id="af618f07531f4080922e4614c627049a6"></a>
template&lt;class F , class IT &gt; </td></tr>
<tr class="memitem:af618f07531f4080922e4614c627049a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classxt_1_1xfunctor__iterator.html">xfunctor_iterator</a>&lt; F, IT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xfunctor__iterator.html">xfunctor_iterator</a>&lt; F, IT &gt; &amp;rhs)</td></tr>
<tr class="separator:af618f07531f4080922e4614c627049a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5d5276ccb4bc02d699b90b770af58e"><td class="memTemplParams" colspan="2"><a id="a4d5d5276ccb4bc02d699b90b770af58e"></a>
template&lt;class F , class IT &gt; </td></tr>
<tr class="memitem:a4d5d5276ccb4bc02d699b90b770af58e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classxt_1_1xfunctor__iterator.html">xfunctor_iterator</a>&lt; F, IT &gt; &amp;lhs, const <a class="el" href="classxt_1_1xfunctor__iterator.html">xfunctor_iterator</a>&lt; F, IT &gt; &amp;rhs)</td></tr>
<tr class="separator:a4d5d5276ccb4bc02d699b90b770af58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2d67c70b0ec6af8294f4b7f201a722"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ade2d67c70b0ec6af8294f4b7f201a722"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ade2d67c70b0ec6af8294f4b7f201a722">from_indices</a> (const std::vector&lt; T &gt; &amp;idx)</td></tr>
<tr class="memdesc:ade2d67c70b0ec6af8294f4b7f201a722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>std::vector&lt;index_type&gt;</code> (returned e.g.  <a href="namespacext.html#ade2d67c70b0ec6af8294f4b7f201a722">More...</a><br /></td></tr>
<tr class="separator:ade2d67c70b0ec6af8294f4b7f201a722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1acf7068270be8ab0ef904dd0f5a54"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5c1acf7068270be8ab0ef904dd0f5a54"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#a5c1acf7068270be8ab0ef904dd0f5a54">flatten_indices</a> (const std::vector&lt; T &gt; &amp;idx)</td></tr>
<tr class="memdesc:a5c1acf7068270be8ab0ef904dd0f5a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>std::vector&lt;index_type&gt;</code> (returned e.g.  <a href="namespacext.html#a5c1acf7068270be8ab0ef904dd0f5a54">More...</a><br /></td></tr>
<tr class="separator:a5c1acf7068270be8ab0ef904dd0f5a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c2456464d4176eb6b659067f8887bc"><td class="memTemplParams" colspan="2">template&lt;class Tag  = ravel_tensor_tag, class C , class S &gt; </td></tr>
<tr class="memitem:ad2c2456464d4176eb6b659067f8887bc"><td class="memTemplItemLeft" align="right" valign="top">ravel_return_type_t&lt; C, Tag &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacext.html#ad2c2456464d4176eb6b659067f8887bc">ravel_indices</a> (const C &amp;idx, const S &amp;shape, <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> l=<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">layout_type::row_major</a>)</td></tr>
<tr class="memdesc:ad2c2456464d4176eb6b659067f8887bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>std::vector&lt;index_type&gt;</code> (returned e.g.  <a href="namespacext.html#ad2c2456464d4176eb6b659067f8887bc">More...</a><br /></td></tr>
<tr class="separator:ad2c2456464d4176eb6b659067f8887bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>standard mathematical functions for xexpressions </p>
<p>functions to obtain xgenerators generating random numbers with given shape </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a26ed1046ec70cca4784f7eb14ad7c7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ed1046ec70cca4784f7eb14ad7c7e0">&#9670;&nbsp;</a></span>xarray</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;, class SA  = std::allocator&lt;typename std::vector&lt;T, A&gt;::size_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xt::xarray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template on <a class="el" href="classxt_1_1xarray__container.html" title="Dense multidimensional container with tensor semantic.">xarray_container</a> with default parameters for data container type and shape / strides container type. </p>
<p>This allows to write</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = {{1., 2.}, {3., 4.}};</div>
<div class="ttc" id="aclassxt_1_1xarray__container_html"><div class="ttname"><a href="classxt_1_1xarray__container.html">xt::xarray_container</a></div><div class="ttdoc">Dense multidimensional container with tensor semantic.</div><div class="ttdef"><b>Definition:</b> <a href="xarray_8hpp_source.html#l00082">xarray.hpp:85</a></div></div>
</div><!-- fragment --><p>instead of the heavier syntax</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray_container&lt;std::vector&lt;double&gt;</a>, std::vector&lt;std::size_t&gt;&gt; a = ...</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the elements. </td></tr>
    <tr><td class="paramname">L</td><td>The layout_type of the <a class="el" href="classxt_1_1xarray__container.html" title="Dense multidimensional container with tensor semantic.">xarray_container</a> (default: XTENSOR_DEFAULT_LAYOUT). </td></tr>
    <tr><td class="paramname">A</td><td>The allocator of the container holding the elements. </td></tr>
    <tr><td class="paramname">SA</td><td>The allocator of the containers holding the shape and the strides. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xtensor__forward_8hpp_source.html#l00082">82</a> of file <a class="el" href="xtensor__forward_8hpp_source.html">xtensor_forward.hpp</a>.</p>

</div>
</div>
<a id="a2a43cfb1b205ffea56a580218ff20455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a43cfb1b205ffea56a580218ff20455">&#9670;&nbsp;</a></span>xarray_optional</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;, class BC  = xtl::xdynamic_bitset&lt;std::size_t&gt;, class SA  = std::allocator&lt;typename std::vector&lt;T, A&gt;::size_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a2a43cfb1b205ffea56a580218ff20455">xt::xarray_optional</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template on <a class="el" href="classxt_1_1xarray__container.html" title="Dense multidimensional container with tensor semantic.">xarray_container</a> for handling missing values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the elements. </td></tr>
    <tr><td class="paramname">L</td><td>The layout_type of the container (default: XTENSOR_DEFAULT_LAYOUT). </td></tr>
    <tr><td class="paramname">A</td><td>The allocator of the container holding the elements. </td></tr>
    <tr><td class="paramname">BA</td><td>The allocator of the container holding the missing flags. </td></tr>
    <tr><td class="paramname">SA</td><td>The allocator of the containers holding the shape and the strides. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xtensor__forward_8hpp_source.html#l00107">107</a> of file <a class="el" href="xtensor__forward_8hpp_source.html">xtensor_forward.hpp</a>.</p>

</div>
</div>
<a id="a29d0a2d76c0f69cf43aa3b4f55a7a26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d0a2d76c0f69cf43aa3b4f55a7a26d">&#9670;&nbsp;</a></span>xtensor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N, layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xt::xtensor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template on <a class="el" href="classxt_1_1xtensor__container.html" title="Dense multidimensional container with tensor semantic and fixed dimension.">xtensor_container</a> with default parameters for data container type. </p>
<p>This allows to write</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xtensor__container.html">xt::xtensor&lt;double, 2&gt;</a> a = {{1., 2.}, {3., 4.}};</div>
<div class="ttc" id="aclassxt_1_1xtensor__container_html"><div class="ttname"><a href="classxt_1_1xtensor__container.html">xt::xtensor_container</a></div><div class="ttdoc">Dense multidimensional container with tensor semantic and fixed dimension.</div><div class="ttdef"><b>Definition:</b> <a href="xtensor_8hpp_source.html#l00083">xtensor.hpp:86</a></div></div>
</div><!-- fragment --><p>instead of the heavier syntax</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xtensor__container.html">xt::xtensor_container&lt;std::vector&lt;double&gt;</a>, 2&gt; a = ...</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the elements. </td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the tensor. </td></tr>
    <tr><td class="paramname">L</td><td>The layout_type of the tensor (default: XTENSOR_DEFAULT_LAYOUT). </td></tr>
    <tr><td class="paramname">A</td><td>The allocator of the containers holding the elements. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xtensor__forward_8hpp_source.html#l00136">136</a> of file <a class="el" href="xtensor__forward_8hpp_source.html">xtensor_forward.hpp</a>.</p>

</div>
</div>
<a id="a85d9917ae5dc2260d2889b7120b69d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d9917ae5dc2260d2889b7120b69d59">&#9670;&nbsp;</a></span>xtensor_fixed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class FSH , layout_type L = ::xt::layout_type::row_major, bool Sharable = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a85d9917ae5dc2260d2889b7120b69d59">xt::xtensor_fixed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template on <a class="el" href="classxt_1_1xfixed__container.html" title="Dense multidimensional container with tensor semantic and fixed dimension.">xfixed_container</a> with default parameters for layout type. </p>
<p>This allows to write</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xfixed__container.html">xt::xtensor_fixed&lt;double, xt::xshape&lt;2, 2&gt;</a>&gt; a = {{1., 2.}, {3., 4.}};</div>
<div class="ttc" id="aclassxt_1_1xfixed__container_html"><div class="ttname"><a href="classxt_1_1xfixed__container.html">xt::xfixed_container</a></div><div class="ttdoc">Dense multidimensional container with tensor semantic and fixed dimension.</div><div class="ttdef"><b>Definition:</b> <a href="xfixed_8hpp_source.html#l00293">xfixed.hpp:295</a></div></div>
</div><!-- fragment --><p>instead of the syntax</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xfixed__container.html">xt::xfixed_container&lt;double, xt::xshape&lt;2, 2&gt;</a>, <a class="code" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a>&gt; a = ...</div>
<div class="ttc" id="anamespacext_html_a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c"><div class="ttname"><a href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a></div><div class="ttdeci">@ row_major</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the elements. </td></tr>
    <tr><td class="paramname">FSH</td><td>A xshape template shape. </td></tr>
    <tr><td class="paramname">L</td><td>The layout_type of the tensor (default: XTENSOR_DEFAULT_LAYOUT). </td></tr>
    <tr><td class="paramname">Sharable</td><td>Whether the tensor can be used in a shared expression. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xtensor__forward_8hpp_source.html#l00184">184</a> of file <a class="el" href="xtensor__forward_8hpp_source.html">xtensor_forward.hpp</a>.</p>

</div>
</div>
<a id="a125645152bc5adb33f0fa248e24a9868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125645152bc5adb33f0fa248e24a9868">&#9670;&nbsp;</a></span>xtensor_optional</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N, layout_type L = ::xt::layout_type::row_major, class A  = std::allocator&lt; T &gt;, class BC  = xtl::xdynamic_bitset&lt;std::size_t&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a125645152bc5adb33f0fa248e24a9868">xt::xtensor_optional</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias template on <a class="el" href="classxt_1_1xtensor__container.html" title="Dense multidimensional container with tensor semantic and fixed dimension.">xtensor_container</a> for handling missing values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type of the elements. </td></tr>
    <tr><td class="paramname">N</td><td>The dimension of the tensor. </td></tr>
    <tr><td class="paramname">L</td><td>The layout_type of the container (default: XTENSOR_DEFAULT_LAYOUT). </td></tr>
    <tr><td class="paramname">A</td><td>The allocator of the containers holding the elements. </td></tr>
    <tr><td class="paramname">BA</td><td>The allocator of the container holding the missing flags. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xtensor__forward_8hpp_source.html#l00201">201</a> of file <a class="el" href="xtensor__forward_8hpp_source.html">xtensor_forward.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a54ee24a1069c6e670d687af9e6aa4ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee24a1069c6e670d687af9e6aa4ba6">&#9670;&nbsp;</a></span>layout_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">xt::layout_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>layout_type enum for xcontainer based xexpressions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a54ee24a1069c6e670d687af9e6aa4ba6ab72f3bd391ba731a35708bfd8cd8a68f"></a>dynamic&#160;</td><td class="fielddoc"><p>dynamic layout_type: you can resize to row major, column major, or use custom strides </p>
</td></tr>
<tr><td class="fieldname"><a id="a54ee24a1069c6e670d687af9e6aa4ba6a100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>layout_type compatible with all others </p>
</td></tr>
<tr><td class="fieldname"><a id="a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c"></a>row_major&#160;</td><td class="fielddoc"><p>row major layout_type </p>
</td></tr>
<tr><td class="fieldname"><a id="a54ee24a1069c6e670d687af9e6aa4ba6a8c23f260f0ec1479d3bfaf3a1305a347"></a>column_major&#160;</td><td class="fielddoc"><p>column major layout_type </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xlayout_8hpp_source.html#l00021">21</a> of file <a class="el" href="xlayout_8hpp_source.html">xlayout.hpp</a>.</p>

</div>
</div>
<a id="aa9d095239ac8c959a5d0a5b7086b5ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d095239ac8c959a5d0a5b7086b5ae7">&#9670;&nbsp;</a></span>pad_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">xt::pad_mode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines different algorithms to be used in <code><a class="el" href="namespacext.html#a0006ff814bef7534b9fa5187b1863feb" title="Pad an array.">xt::pad</a></code>: </p>
<ul>
<li><code>constant</code>: Pads with a constant value.</li>
<li><code>symmetric</code>: Pads with the reflection of the vector mirrored along the edge of the array.</li>
<li><code>reflect</code>: Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.</li>
<li><code>wrap</code>: Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.</li>
<li><code>periodic</code> : <code>== wrap</code> (pads with periodic repetitions of the vector).</li>
</ul>
<p>OpenCV to xtensor:</p><ul>
<li><code>BORDER_CONSTANT == constant</code></li>
<li><code>BORDER_REFLECT == symmetric</code></li>
<li><code>BORDER_REFLECT_101 == reflect</code></li>
<li><code>BORDER_WRAP == wrap</code> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="xpad_8hpp_source.html#l00038">38</a> of file <a class="el" href="xpad_8hpp_source.html">xpad.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a75bd621231562feb074486e7213ee86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bd621231562feb074486e7213ee86f">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class E , class EVS  = evaluation_strategy::immediate_type, xtl::check_concept&lt; is_evaluation_strategy&lt; EVS &gt; &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::accumulate </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EVS&#160;</td>
          <td class="paramname"><em>evaluation_strategy</em> = <code>EVS()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate and flatten array <b>NOTE</b> This function is not lazy! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>functor to use for accumulation </td></tr>
    <tr><td class="paramname">e</td><td>xexpression to be accumulated </td></tr>
    <tr><td class="paramname">evaluation_strategy</td><td>evaluation strategy of the accumulation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns xarray&lt;T&gt; filled with accumulated values </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaccumulator_8hpp_source.html#l00312">312</a> of file <a class="el" href="xaccumulator_8hpp_source.html">xaccumulator.hpp</a>.</p>

</div>
</div>
<a id="a89df2e50fff4b65f615aacfcdbb9ff74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89df2e50fff4b65f615aacfcdbb9ff74">&#9670;&nbsp;</a></span>accumulate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class E , class EVS  = evaluation_strategy::immediate_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::accumulate </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EVS&#160;</td>
          <td class="paramname"><em>evaluation_strategy</em> = <code>EVS()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accumulate over axis <b>NOTE</b> This function is not lazy! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor to use for accumulation </td></tr>
    <tr><td class="paramname">e</td><td>xexpression to accumulate </td></tr>
    <tr><td class="paramname">axis</td><td>Axis to perform accumulation over </td></tr>
    <tr><td class="paramname">evaluation_strategy</td><td>evaluation strategy of the accumulation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns xarray&lt;T&gt; filled with accumulated values </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaccumulator_8hpp_source.html#l00331">331</a> of file <a class="el" href="xaccumulator_8hpp_source.html">xaccumulator.hpp</a>.</p>

</div>
</div>
<a id="a1607ba0be938e3d0a9acecee22eb2efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1607ba0be938e3d0a9acecee22eb2efe">&#9670;&nbsp;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice representing a full dimension, to be used as an argument of view function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa" title="Constructs and returns a view on the specified xexpression.">view</a>, <a class="el" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26" title="Construct a strided view from an xexpression, shape, strides and offset.">strided_view</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xslice_8hpp_source.html#l00223">223</a> of file <a class="el" href="xslice_8hpp_source.html">xslice.hpp</a>.</p>

</div>
</div>
<a id="ad2d3e146e64f9cb63d1b66e7d0d43867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d3e146e64f9cb63d1b66e7d0d43867">&#9670;&nbsp;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::angle </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deg</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the phase angle elementwise for the complex numbers in e. </p>
<p>Note that this function might be slightly less perfomant than <a class="el" href="namespacext.html#a79e6cc463f0aeee688d90dcd320cd672">arg</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a> </td></tr>
    <tr><td class="paramname">deg</td><td>calculate angle in degrees instead of radians </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xcomplex_8hpp_source.html#l00235">235</a> of file <a class="el" href="xcomplex_8hpp_source.html">xcomplex.hpp</a>.</p>

</div>
</div>
<a id="a156656dea2a291a2b0978a2b02d7f0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156656dea2a291a2b0978a2b02d7f0f7">&#9670;&nbsp;</a></span>arange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::arange </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates numbers evenly spaced within given half-open interval [start, stop). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>start of the interval </td></tr>
    <tr><td class="paramname">stop</td><td>stop of the interval </td></tr>
    <tr><td class="paramname">step</td><td>stepsize </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value_type of xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator that generates the values on access </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00427">427</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="ab7170425dd9da8585aefbd0eb79af4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7170425dd9da8585aefbd0eb79af4ec">&#9670;&nbsp;</a></span>arange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::arange </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate numbers evenly spaced within given half-open interval [0, stop) with a step size of 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop</td><td>stop of the interval </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value_type of xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator that generates the values on access </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00440">440</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a79e6cc463f0aeee688d90dcd320cd672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79e6cc463f0aeee688d90dcd320cd672">&#9670;&nbsp;</a></span>arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::arg </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the phase angle (in radians) elementwise for the complex numbers in e. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xcomplex_8hpp_source.html#l00221">221</a> of file <a class="el" href="xcomplex_8hpp_source.html">xcomplex.hpp</a>.</p>

</div>
</div>
<a id="a258b6c4df6acf24de4bec48be87f0218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258b6c4df6acf24de4bec48be87f0218">&#9670;&nbsp;</a></span>argmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::argmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find position of maximal value in xexpression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">axis</td><td>select axis (or none)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns xarray with positions of maximal value </dd></dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00897">897</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="af262fae4388b98687913a18fe321f88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af262fae4388b98687913a18fe321f88d">&#9670;&nbsp;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::argmin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find position of minimal value in xexpression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">axis</td><td>select axis (or none)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns xarray with positions of minimal value </dd></dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00872">872</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="ab6161585ce399b9dcb2480c464f0c0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6161585ce399b9dcb2480c464f0c0c6">&#9670;&nbsp;</a></span>argpartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class C , class R  = typename detail::linear_argsort_result_type&lt;typename detail::sort_eval_type&lt;E&gt;::type&gt;::type, class  = std::enable_if_t&lt;!xtl::is_integral&lt;C&gt;::value, int&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R xt::argpartition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>kth_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partially sort arguments. </p>
<p>Argpartition shuffles the indices to a xexpression in a way so that the index for the kth element in the returned xexpression is in the place it would appear in a sorted array and all elements smaller than this entry are placed (unsorted) before.</p>
<p>The optional third parameter can either be an axis or <code>xnone()</code> in which case the xexpression will be flattened.</p>
<p>This function uses <code>std::nth_element</code> internally.</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;float&gt;</a> a = {1, 10, -10, 123};</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacext.html#ab6161585ce399b9dcb2480c464f0c0c6">xt::argpartition</a>(a, 0) &lt;&lt; std::endl; <span class="comment">// {2, 0, 3, 1} the correct entry at index 0</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacext.html#ab6161585ce399b9dcb2480c464f0c0c6">xt::argpartition</a>(a, 3) &lt;&lt; std::endl; <span class="comment">// {0, 1, 2, 3} the correct entry at index 3</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacext.html#ab6161585ce399b9dcb2480c464f0c0c6">xt::argpartition</a>(a, {0, 3}) &lt;&lt; std::endl; <span class="comment">// {2, 0, 1, 3} the correct entries at index 0 and 3</span></div>
<div class="ttc" id="anamespacext_html_ab6161585ce399b9dcb2480c464f0c0c6"><div class="ttname"><a href="namespacext.html#ab6161585ce399b9dcb2480c464f0c0c6">xt::argpartition</a></div><div class="ttdeci">R argpartition(const xexpression&lt; E &gt; &amp;e, const C &amp;kth_container, placeholders::xtuph)</div><div class="ttdoc">Partially sort arguments.</div><div class="ttdef"><b>Definition:</b> <a href="xsort_8hpp_source.html#l00542">xsort.hpp:542</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">kth_container</td><td>a container of <code>indices</code> that should contain the correctly sorted value </td></tr>
    <tr><td class="paramname">axis</td><td>either integer (default = -1) to sort along last axis or <code>xnone()</code> to flatten before sorting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xcontainer with indices of partial sort of input </dd></dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00542">542</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="abe3bfb99c8fdab94a100f960ddcb4fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3bfb99c8fdab94a100f960ddcb4fdf">&#9670;&nbsp;</a></span>argsort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::argsort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Argsort xexpression (optionally along axis) Performs an indirect sort along the given axis. </p>
<p>Returns an xarray of indices of the same shape as e that index data along the given axis in sorted order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>xexpression to argsort </td></tr>
    <tr><td class="paramname">axis</td><td>axis along which argsort is performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>argsorted index array </dd></dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00346">346</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="a220444924c684f9f2afbc3384a8ff09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220444924c684f9f2afbc3384a8ff09e">&#9670;&nbsp;</a></span>atleast_1d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::atleast_1d </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand to at least 1D. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a66c613dc60a31ca07c28b45337ee59b7" title="Expand dimensions of xexpression to at least N">atleast_Nd</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00521">521</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="ae2392e470cec79a918e975987d431c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2392e470cec79a918e975987d431c54">&#9670;&nbsp;</a></span>atleast_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::atleast_2d </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand to at least 2D. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a66c613dc60a31ca07c28b45337ee59b7" title="Expand dimensions of xexpression to at least N">atleast_Nd</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00531">531</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="af9edf6c754946e30b77d9617852ed15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9edf6c754946e30b77d9617852ed15c">&#9670;&nbsp;</a></span>atleast_3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::atleast_3d </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand to at least 3D. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a66c613dc60a31ca07c28b45337ee59b7" title="Expand dimensions of xexpression to at least N">atleast_Nd</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00541">541</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a66c613dc60a31ca07c28b45337ee59b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c613dc60a31ca07c28b45337ee59b7">&#9670;&nbsp;</a></span>atleast_Nd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::atleast_Nd </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand dimensions of xexpression to at least <code>N</code> </p>
<p>This adds <code><a class="el" href="namespacext.html#a534914903c805a597a5fac60e60e7c43" title="Returns a slice representing a new axis of length one, to be used as an argument of view function.">newaxis()</a></code> slices to a <code>strided_view</code> until the dimension of the view reaches at least <code>N</code>. Note: dimensions are added equally at the beginning and the end. For example, a 1-D array of shape (N,) becomes a view of shape (1, N, 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of requested dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>strided_view</code> with expanded dimensions </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00496">496</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a10d6b6dddf20a721f48bec57deee85c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d6b6dddf20a721f48bec57deee85c1">&#9670;&nbsp;</a></span>axis_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_begin </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the expression for axis 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__iterator.html" title="Class for iteration over (N-1)-dimensional slices, where N is the dimension of the underlying express...">xaxis_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__iterator_8hpp_source.html#l00281">281</a> of file <a class="el" href="xaxis__iterator_8hpp_source.html">xaxis_iterator.hpp</a>.</p>

</div>
</div>
<a id="aeff80d8045ec5b2276cb70d3171890ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff80d8045ec5b2276cb70d3171890ef">&#9670;&nbsp;</a></span>axis_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_begin </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::decay_t&lt; E &gt;::size_type&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the expression for the specified axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
    <tr><td class="paramname">axis</td><td>the axis to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__iterator.html" title="Class for iteration over (N-1)-dimensional slices, where N is the dimension of the underlying express...">xaxis_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__iterator_8hpp_source.html#l00295">295</a> of file <a class="el" href="xaxis__iterator_8hpp_source.html">xaxis_iterator.hpp</a>.</p>

</div>
</div>
<a id="a8febb08b64e215650861f319845e0ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8febb08b64e215650861f319845e0ba8">&#9670;&nbsp;</a></span>axis_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_end </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the expression for axis 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__iterator.html" title="Class for iteration over (N-1)-dimensional slices, where N is the dimension of the underlying express...">xaxis_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__iterator_8hpp_source.html#l00309">309</a> of file <a class="el" href="xaxis__iterator_8hpp_source.html">xaxis_iterator.hpp</a>.</p>

</div>
</div>
<a id="a6a9d61065999823b0947aac4741a5255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9d61065999823b0947aac4741a5255">&#9670;&nbsp;</a></span>axis_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_end </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::decay_t&lt; E &gt;::size_type&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the expression for the specified axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
    <tr><td class="paramname">axis</td><td>the axis to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__iterator.html" title="Class for iteration over (N-1)-dimensional slices, where N is the dimension of the underlying express...">xaxis_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__iterator_8hpp_source.html#l00325">325</a> of file <a class="el" href="xaxis__iterator_8hpp_source.html">xaxis_iterator.hpp</a>.</p>

</div>
</div>
<a id="ac347d148c68881cdf4f5dbc488dc02bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac347d148c68881cdf4f5dbc488dc02bf">&#9670;&nbsp;</a></span>axis_slice_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_slice_begin </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the expression for axis 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__slice__iterator.html" title="Class for iteration over one-dimensional slices.">xaxis_slice_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__slice__iterator_8hpp_source.html#l00277">277</a> of file <a class="el" href="xaxis__slice__iterator_8hpp_source.html">xaxis_slice_iterator.hpp</a>.</p>

</div>
</div>
<a id="a2a64b30629191a33452d47762e67386b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a64b30629191a33452d47762e67386b">&#9670;&nbsp;</a></span>axis_slice_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_slice_begin </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::decay_t&lt; E &gt;::size_type&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the expression for the specified axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
    <tr><td class="paramname">axis</td><td>the axis to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__slice__iterator.html" title="Class for iteration over one-dimensional slices.">xaxis_slice_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__slice__iterator_8hpp_source.html#l00291">291</a> of file <a class="el" href="xaxis__slice__iterator_8hpp_source.html">xaxis_slice_iterator.hpp</a>.</p>

</div>
</div>
<a id="af214429c748c24ec2f26271be60ff9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af214429c748c24ec2f26271be60ff9ea">&#9670;&nbsp;</a></span>axis_slice_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_slice_end </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the expression for axis 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__slice__iterator.html" title="Class for iteration over one-dimensional slices.">xaxis_slice_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__slice__iterator_8hpp_source.html#l00305">305</a> of file <a class="el" href="xaxis__slice__iterator_8hpp_source.html">xaxis_slice_iterator.hpp</a>.</p>

</div>
</div>
<a id="a79a091d187f0ba564daabc12be1725ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a091d187f0ba564daabc12be1725ca">&#9670;&nbsp;</a></span>axis_slice_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::axis_slice_end </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::decay_t&lt; E &gt;::size_type&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the element following the last element of the expression for the specified axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expession to iterate over </td></tr>
    <tr><td class="paramname">axis</td><td>the axis to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an instance of <a class="el" href="classxt_1_1xaxis__slice__iterator.html" title="Class for iteration over one-dimensional slices.">xaxis_slice_iterator</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__slice__iterator_8hpp_source.html#l00323">323</a> of file <a class="el" href="xaxis__slice__iterator_8hpp_source.html">xaxis_slice_iterator.hpp</a>.</p>

</div>
</div>
<a id="a414b2909d3c9e0bf5142d4074491ffe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414b2909d3c9e0bf5142d4074491ffe7">&#9670;&nbsp;</a></span>bin_items() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xt::xtensor</a>&lt;size_t, 1&gt; xt::bin_items </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items in each bin, given the fraction of items per bin. </p>
<p>The output is such that the total number of items of all bins is exactly "N".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the number of items to distribute </td></tr>
    <tr><td class="paramname">weights</td><td>fraction of items per bin: a 1D container whose size is the number of bins</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1D container with the number of items per bin </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00546">546</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="ae87461823c6747aabd154ee7825700ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87461823c6747aabd154ee7825700ca">&#9670;&nbsp;</a></span>bin_items() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d">xt::xtensor</a>&lt;size_t,1&gt; xt::bin_items </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bins</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items in each bin, with each bin having approximately the same number of items in it,under the constraint that the total number of items of all bins is exactly "N". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the number of items to distribute </td></tr>
    <tr><td class="paramname">bins</td><td>the number of bins</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1D container with the number of items per bin </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00588">588</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="aed5ac7b9e3af63f34daf465b902d0108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5ac7b9e3af63f34daf465b902d0108">&#9670;&nbsp;</a></span>bincount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 , class E2 , xtl::check_concept&lt; is_xexpression&lt; std::decay_t&lt; E2 &gt;&gt; &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::bincount </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>minlength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count number of occurrences of each value in array of non-negative ints. </p>
<p>The number of bins (of size 1) is one larger than the largest value in x. If minlength is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of x). Each bin gives the number of occurrences of its index value in x. If weights is specified the input array is weighted by it, i.e. if a value <code>n</code> is found at position <code>i</code>, <code>out[n] += weight[i]</code> instead of <code>out[n] += 1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the 1D container with integers to count into bins </td></tr>
    <tr><td class="paramname">weights</td><td>a 1D container with the same number of elements as <code>data</code> </td></tr>
    <tr><td class="paramname">minlength</td><td>The minlength</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1D container with the bincount </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00497">497</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="a0879929fad639a3a4256a702b9beba62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0879929fad639a3a4256a702b9beba62">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::broadcast </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> broadcasting the given expression to a specified shape. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a> to broadcast </td></tr>
    <tr><td class="paramname">s</td><td>the specified shape to broadcast.</td></tr>
  </table>
  </dd>
</dl>
<p>The returned expression either hold a const reference to <code>e</code> or a copy depending on whether <code>e</code> is an lvalue or an rvalue. </p>

<p class="definition">Definition at line <a class="el" href="xbroadcast_8hpp_source.html#l00234">234</a> of file <a class="el" href="xbroadcast_8hpp_source.html">xbroadcast.hpp</a>.</p>

</div>
</div>
<a id="a2dae3e469de3f3ec7b0d4fc49f82de5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dae3e469de3f3ec7b0d4fc49f82de5c">&#9670;&nbsp;</a></span>chunked_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; typename E::value_type &gt; &gt; &gt; xt::chunked_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td>
          <td class="paramname"><em>chunk_memory_layout</em> = <code>::<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an in-memory chunked array. </p>
<p>This function returns a <code><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt;xarray&lt;T&gt;&gt;</code> initialized from an expression.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>The layout_type of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to initialize the chunked array from </td></tr>
    <tr><td class="paramname">chunk_memory_layout</td><td>The layout of each chunk (default: XTENSOR_DEFAULT_LAYOUT)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a <code><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt;xarray&lt;T&gt;&gt;</code> from the given expression, with the expression's chunk shape and the given memory layout. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xchunked__array_8hpp_source.html#l00350">350</a> of file <a class="el" href="xchunked__array_8hpp_source.html">xchunked_array.hpp</a>.</p>

</div>
</div>
<a id="a7f77d42d689828b2d8e8cdd57c28ee9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f77d42d689828b2d8e8cdd57c28ee9b">&#9670;&nbsp;</a></span>chunked_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; typename E::value_type &gt; &gt; &gt; xt::chunked_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>chunk_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td>
          <td class="paramname"><em>chunk_memory_layout</em> = <code>::<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an in-memory chunked array. </p>
<p>This function returns a <code><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt;xarray&lt;T&gt;&gt;</code> initialized from an expression.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>The layout_type of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to initialize the chunked array from </td></tr>
    <tr><td class="paramname">chunk_shape</td><td>The shape of a chunk </td></tr>
    <tr><td class="paramname">chunk_memory_layout</td><td>The layout of each chunk (default: XTENSOR_DEFAULT_LAYOUT)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a <code><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt;xarray&lt;T&gt;&gt;</code> from the given expression, with the given chunk shape and memory layout. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xchunked__array_8hpp_source.html#l00342">342</a> of file <a class="el" href="xchunked__array_8hpp_source.html">xchunked_array.hpp</a>.</p>

</div>
</div>
<a id="a8c408e717c7725211a42114adb4557b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c408e717c7725211a42114adb4557b2">&#9670;&nbsp;</a></span>chunked_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , layout_type L = ::xt::layout_type::row_major, class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; <a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt; T &gt; &gt; &gt; xt::chunked_array </td>
          <td>(</td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>chunk_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td>
          <td class="paramname"><em>chunk_memory_layout</em> = <code>::<a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">xt::layout_type::row_major</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an in-memory chunked array. </p>
<p>This function returns an uninitialized <code><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt;xarray&lt;T&gt;&gt;</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements (e.g. double) </td></tr>
    <tr><td class="paramname">L</td><td>The layout_type of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the array </td></tr>
    <tr><td class="paramname">chunk_shape</td><td>The shape of a chunk </td></tr>
    <tr><td class="paramname">chunk_memory_layout</td><td>The layout of each chunk (default: XTENSOR_DEFAULT_LAYOUT)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a <code><a class="el" href="classxt_1_1xchunked__array.html">xchunked_array</a>&lt;xarray&lt;T&gt;&gt;</code> with the given shape, chunk shape and memory layout. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xchunked__array_8hpp_source.html#l00325">325</a> of file <a class="el" href="xchunked__array_8hpp_source.html">xchunked_array.hpp</a>.</p>

</div>
</div>
<a id="a5772db4fd8ebf31bc242dd1c2d2ddd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5772db4fd8ebf31bc242dd1c2d2ddd1b">&#9670;&nbsp;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::col </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and returns a column (sliced view) on the specified expression. </p>
<p>Users should not directly construct the slices but call helper functions instead. This function is only allowed on expressions with two dimensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression to adapt </td></tr>
    <tr><td class="paramname">index</td><td>0-based index of the column, negative indices will return the last columns in reverse order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the expression has more than 2 dimensions. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xview_8hpp_source.html#l01856">1856</a> of file <a class="el" href="xview_8hpp_source.html">xview.hpp</a>.</p>

</div>
</div>
<a id="a27b28c7951a0991e2e8d39422c2b46b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b28c7951a0991e2e8d39422c2b46b2">&#9670;&nbsp;</a></span>compute_layout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a> xt::compute_layout </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the following logical table: </p>
<pre class="fragment">  | d | a | r | c |
--+---+---+---+---+
d | d | d | d | d |
a | d | a | r | c |
r | d | r | r | d |
c | d | c | d | c |
d = dynamic, a = any, r = row_major, c = column_major.
</pre><p> Using bitmasks to avoid nested if-else statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the input layouts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output layout, computed with the previous logical table. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xlayout_8hpp_source.html#l00087">87</a> of file <a class="el" href="xlayout_8hpp_source.html">xlayout.hpp</a>.</p>

</div>
</div>
<a id="a28c746e1a420f706892d9aff3ad0dd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c746e1a420f706892d9aff3ad0dd30">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... CT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::concatenate </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; CT... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates xexpressions along <em>axis</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xtuple</a> of xexpressions to concatenate </td></tr>
    <tr><td class="paramname">axis</td><td>axis along which elements are concatenated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator evaluating to concatenated elements</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = {{1, 2, 3}};</div>
<div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> b = {{2, 3, 4}};</div>
<div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> c = <a class="code" href="namespacext.html#a28c746e1a420f706892d9aff3ad0dd30">xt::concatenate</a>(<a class="code" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xt::xtuple</a>(a, b)); <span class="comment">// =&gt; {{1, 2, 3},</span></div>
<div class="line">                                                          <span class="comment">//     {2, 3, 4}}</span></div>
<div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> d = <a class="code" href="namespacext.html#a28c746e1a420f706892d9aff3ad0dd30">xt::concatenate</a>(<a class="code" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xt::xtuple</a>(a, b), 1); <span class="comment">// =&gt; {{1, 2, 3, 2, 3, 4}}</span></div>
<div class="ttc" id="anamespacext_html_a28c746e1a420f706892d9aff3ad0dd30"><div class="ttname"><a href="namespacext.html#a28c746e1a420f706892d9aff3ad0dd30">xt::concatenate</a></div><div class="ttdeci">auto concatenate(std::tuple&lt; CT... &gt; &amp;&amp;t, std::size_t axis=0)</div><div class="ttdoc">Concatenates xexpressions along axis.</div><div class="ttdef"><b>Definition:</b> <a href="xbuilder_8hpp_source.html#l00766">xbuilder.hpp:766</a></div></div>
<div class="ttc" id="anamespacext_html_ae0a17e1fea8041f69a66d80928359150"><div class="ttname"><a href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xt::xtuple</a></div><div class="ttdeci">auto xtuple(Types &amp;&amp;... args)</div><div class="ttdoc">Creates tuples from arguments for concatenate and stack.</div><div class="ttdef"><b>Definition:</b> <a href="xbuilder_8hpp_source.html#l00651">xbuilder.hpp:651</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00766">766</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="af155a86146879d345b8acaa16d48c748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af155a86146879d345b8acaa16d48c748">&#9670;&nbsp;</a></span>conditional_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool condition, class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::conditional_cast </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a type cast when a condition is true. </p>
<p>If <code>condition</code> is true, return <code>static_cast&lt;T&gt;(u)</code>, otherwise return <code>u</code> unchanged. This is useful when an unconditional static_cast would force undesired type conversions in some situations where an error or warning would be desired. The condition determines when the explicit cast is ok. </p>

<p class="definition">Definition at line <a class="el" href="xutils_8hpp_source.html#l00691">691</a> of file <a class="el" href="xutils_8hpp_source.html">xutils.hpp</a>.</p>

</div>
</div>
<a id="a77874ddd5efaa90065d692ee4a6049a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77874ddd5efaa90065d692ee4a6049a2">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::conj </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classxt_1_1xfunction.html">xfunction</a> evaluating to the complex conjugate of the given expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xcomplex_8hpp_source.html#l00209">209</a> of file <a class="el" href="xcomplex_8hpp_source.html">xcomplex.hpp</a>.</p>

</div>
</div>
<a id="af462add746658517456f484f2e80f609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af462add746658517456f484f2e80f609">&#9670;&nbsp;</a></span>cov()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::cov </td>
          <td>(</td>
          <td class="paramtype">const E1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E1 &amp;&#160;</td>
          <td class="paramname"><em>y</em> = <code>E1()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the covariance matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>one or two dimensional array </td></tr>
    <tr><td class="paramname">y</td><td>optional one-dimensional array to build covariance to x </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmath_8hpp_source.html#l02971">2971</a> of file <a class="el" href="xmath_8hpp_source.html">xmath.hpp</a>.</p>

</div>
</div>
<a id="ad848dae0258c3e5755ff7ee55e7c7b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad848dae0258c3e5755ff7ee55e7c7b30">&#9670;&nbsp;</a></span>diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::diag </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>xexpression with values of arr on the diagonal, zeroes otherwise </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the 1D input array of length n </td></tr>
    <tr><td class="paramname">k</td><td>the offset of the considered diagonal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xexpression function with shape n x n and arr on the diagonal</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = {1, 5, 9};</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code" href="namespacext.html#ad848dae0258c3e5755ff7ee55e7c7b30">xt::diag</a>(a); <span class="comment">// =&gt; {{1, 0, 0},</span></div>
<div class="line">                      <span class="comment">//     {0, 5, 0},</span></div>
<div class="line">                      <span class="comment">//     {0, 0, 9}}</span></div>
<div class="ttc" id="anamespacext_html_ad848dae0258c3e5755ff7ee55e7c7b30"><div class="ttname"><a href="namespacext.html#ad848dae0258c3e5755ff7ee55e7c7b30">xt::diag</a></div><div class="ttdeci">auto diag(E &amp;&amp;arr, int k=0)</div><div class="ttdoc">xexpression with values of arr on the diagonal, zeroes otherwise</div><div class="ttdef"><b>Definition:</b> <a href="xbuilder_8hpp_source.html#l01124">xbuilder.hpp:1124</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l01124">1124</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a96ad98d837a74211cc0e5f07b85c2414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ad98d837a74211cc0e5f07b85c2414">&#9670;&nbsp;</a></span>diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::diagonal </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis_1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis_2</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the elements on the diagonal of arr If arr has more than two dimensions, then the axes specified by axis_1 and axis_2 are used to determine the 2-D sub-array whose diagonal is returned. </p>
<p>The shape of the resulting array can be determined by removing axis1 and axis2 and appending an index to the right equal to the size of the resulting diagonals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the input array </td></tr>
    <tr><td class="paramname">offset</td><td>offset of the diagonal from the main diagonal. Can be positive or negative. </td></tr>
    <tr><td class="paramname">axis_1</td><td>Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. </td></tr>
    <tr><td class="paramname">axis_2</td><td>Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xexpression with values of the diagonal</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = {{1, 2, 3},</div>
<div class="line">                        {4, 5, 6}</div>
<div class="line">                        {7, 8, 9}};</div>
<div class="line"><span class="keyword">auto</span> b = <a class="code" href="namespacext.html#a96ad98d837a74211cc0e5f07b85c2414">xt::diagonal</a>(a); <span class="comment">// =&gt; {1, 5, 9}</span></div>
<div class="ttc" id="anamespacext_html_a96ad98d837a74211cc0e5f07b85c2414"><div class="ttname"><a href="namespacext.html#a96ad98d837a74211cc0e5f07b85c2414">xt::diagonal</a></div><div class="ttdeci">auto diagonal(E &amp;&amp;arr, int offset=0, std::size_t axis_1=0, std::size_t axis_2=1)</div><div class="ttdoc">Returns the elements on the diagonal of arr If arr has more than two dimensions, then the axes specif...</div><div class="ttdef"><b>Definition:</b> <a href="xbuilder_8hpp_source.html#l01076">xbuilder.hpp:1076</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l01076">1076</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a80fb5a6e58dafe175544508ea913cff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fb5a6e58dafe175544508ea913cff0">&#9670;&nbsp;</a></span>digitize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::digitize </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>bin_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the indices of the bins to which each value in input array belongs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bin_edges</td><td>The bin-edges. It has to be 1-dimensional and monotonic. </td></tr>
    <tr><td class="paramname">right</td><td>Indicating whether the intervals include the right or the left bin edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output array of indices, of same shape as x. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00036">36</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="af7803c646dad8f762ce42c50153ec6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7803c646dad8f762ce42c50153ec6d0">&#9670;&nbsp;</a></span>drop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::disable_integral_drop&lt;T&gt; xt::drop </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a non-contigous slice from a container of indices to drop. </p>
<p>Note: this slice cannot be used in the xstrided_view!</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = <a class="code" href="namespacext.html#a156656dea2a291a2b0978a2b02d7f0f7">xt::arange</a>(9);</div>
<div class="line">a.reshape({3, 3});</div>
<div class="line"><a class="code" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa">xt::view</a>(a, <a class="code" href="namespacext.html#af7803c646dad8f762ce42c50153ec6d0">xt::drop</a>(0, 2); <span class="comment">// =&gt; {{3, 4, 5}}</span></div>
<div class="ttc" id="anamespacext_html_a156656dea2a291a2b0978a2b02d7f0f7"><div class="ttname"><a href="namespacext.html#a156656dea2a291a2b0978a2b02d7f0f7">xt::arange</a></div><div class="ttdeci">auto arange(T start, T stop, S step=1) noexcept</div><div class="ttdoc">Generates numbers evenly spaced within given half-open interval [start, stop).</div><div class="ttdef"><b>Definition:</b> <a href="xbuilder_8hpp_source.html#l00427">xbuilder.hpp:427</a></div></div>
<div class="ttc" id="anamespacext_html_aedc2027ff309134dff5b0720699c5ffa"><div class="ttname"><a href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa">xt::view</a></div><div class="ttdeci">auto view(E &amp;&amp;e, S &amp;&amp;... slices)</div><div class="ttdoc">Constructs and returns a view on the specified xexpression.</div><div class="ttdef"><b>Definition:</b> <a href="xview_8hpp_source.html#l01767">xview.hpp:1767</a></div></div>
<div class="ttc" id="anamespacext_html_af7803c646dad8f762ce42c50153ec6d0"><div class="ttname"><a href="namespacext.html#af7803c646dad8f762ce42c50153ec6d0">xt::drop</a></div><div class="ttdeci">detail::disable_integral_drop&lt; T &gt; drop(T &amp;&amp;indices)</div><div class="ttdoc">Create a non-contigous slice from a container of indices to drop.</div><div class="ttdef"><b>Definition:</b> <a href="xslice_8hpp_source.html#l00516">xslice.hpp:516</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The container of indices to drop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of <a class="el" href="classxt_1_1xdrop__slice.html">xdrop_slice</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xslice_8hpp_source.html#l00516">516</a> of file <a class="el" href="xslice_8hpp_source.html">xslice.hpp</a>.</p>

</div>
</div>
<a id="a809a1475d6c06e6209878b293ca0aa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809a1475d6c06e6209878b293ca0aa4d">&#9670;&nbsp;</a></span>dump_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void xt::dump_csv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump tensor to CSV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the output stream to write the CSV encoded values </td></tr>
    <tr><td class="paramname">e</td><td>the tensor expression to serialize </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xcsv_8hpp_source.html#l00172">172</a> of file <a class="el" href="xcsv_8hpp_source.html">xcsv.hpp</a>.</p>

</div>
</div>
<a id="abbb704b012b5b4a60523e183342660a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb704b012b5b4a60523e183342660a8">&#9670;&nbsp;</a></span>dump_npy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xt::dump_npy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save xexpression to NumPy npy format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename or path to dump the data </td></tr>
    <tr><td class="paramname">e</td><td>the xexpression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xnpy_8hpp_source.html#l00668">668</a> of file <a class="el" href="xnpy_8hpp_source.html">xnpy.hpp</a>.</p>

</div>
</div>
<a id="a6d48f3428b263994fcfb707ca476847e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d48f3428b263994fcfb707ca476847e">&#9670;&nbsp;</a></span>dump_npy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string xt::dump_npy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save xexpression to NumPy npy format in a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xnpy_8hpp_source.html#l00685">685</a> of file <a class="el" href="xnpy_8hpp_source.html">xnpy.hpp</a>.</p>

</div>
</div>
<a id="a7674e27693c74603e341cbf7beb91e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7674e27693c74603e341cbf7beb91e7b">&#9670;&nbsp;</a></span>ellipsis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::ellipsis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice representing all remaining dimensions, and selecting all in these dimensions. </p>
<p>Ellipsis will expand to a series of <code><a class="el" href="group__logical__operators.html#ga8da84f179efb13f3d860c5950b5c626e" title="Any.">all()</a></code> slices, until the number of slices is equal to the number of dimensions of the source array.</p>
<p>Note: ellipsis can only be used in strided_view!</p>
<div class="fragment"><div class="line">xarray&lt;double&gt; a = xarray&lt;double&gt;::from_shape({5, 5, 1, 1, 5});</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26">xt::strided_view</a>(a, {2, <a class="code" href="namespacext.html#a7674e27693c74603e341cbf7beb91e7b">xt::ellipsis</a>(), 2});</div>
<div class="line"><span class="comment">// equivalent to using {2, xt::all(), xt::all(), xt::all(), 2};</span></div>
<div class="ttc" id="anamespacext_html_a7674e27693c74603e341cbf7beb91e7b"><div class="ttname"><a href="namespacext.html#a7674e27693c74603e341cbf7beb91e7b">xt::ellipsis</a></div><div class="ttdeci">auto ellipsis() noexcept</div><div class="ttdoc">Returns a slice representing all remaining dimensions, and selecting all in these dimensions.</div><div class="ttdef"><b>Definition:</b> <a href="xslice_8hpp_source.html#l00244">xslice.hpp:244</a></div></div>
<div class="ttc" id="anamespacext_html_aca6714111810062b91a1c9e31bd69b26"><div class="ttname"><a href="namespacext.html#aca6714111810062b91a1c9e31bd69b26">xt::strided_view</a></div><div class="ttdeci">auto strided_view(E &amp;&amp;e, S &amp;&amp;shape, X &amp;&amp;stride, std::size_t offset=0, layout_type layout=L) noexcept</div><div class="ttdoc">Construct a strided view from an xexpression, shape, strides and offset.</div><div class="ttdef"><b>Definition:</b> <a href="xstrided__view_8hpp_source.html#l00647">xstrided_view.hpp:647</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26" title="Construct a strided view from an xexpression, shape, strides and offset.">strided_view</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xslice_8hpp_source.html#l00244">244</a> of file <a class="el" href="xslice_8hpp_source.html">xslice.hpp</a>.</p>

</div>
</div>
<a id="a7805e4eef27ae63c5509ca1f71eab5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7805e4eef27ae63c5509ca1f71eab5b4">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , layout_type L = ::xt::layout_type::row_major, class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacext.html#a26ed1046ec70cca4784f7eb14ad7c7e0">xarray</a>&lt;T, L&gt; xt::empty </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a xcontainer (xarray, xtensor or xtensor_fixed) with uninitialized values of with value_type T and shape. </p>
<p>Selects the best container match automatically from the supplied shape.</p>
<ul>
<li><code>std::vector</code>  <code>xarray&lt;T&gt;</code></li>
<li><code>std::array</code> or <code>initializer_list</code>  <code>xtensor&lt;T, N&gt;</code></li>
<li><code>xshape&lt;N...&gt;</code>  <code>xtensor_fixed&lt;T, xshape&lt;N...&gt;&gt;</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape of the new xcontainer </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00089">89</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="abda9d7634e3a60172e626271a0e50bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda9d7634e3a60172e626271a0e50bae">&#9670;&nbsp;</a></span>empty_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::empty_like </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a xcontainer (xarray, xtensor or xtensor_fixed) with uninitialized values of the same shape, value type and layout as the input xexpression <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression from which to extract shape, value type and layout. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00121">121</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="abe8cb55041a20cb995a15c599b7a2bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8cb55041a20cb995a15c599b7a2bc2">&#9670;&nbsp;</a></span>expand_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::expand_dims </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the shape of an xexpression. </p>
<p>Insert a new axis that will appear at the axis position in the expanded array shape. This will return a <code>strided_view</code> with a <code><a class="el" href="namespacext.html#a534914903c805a597a5fac60e60e7c43" title="Returns a slice representing a new axis of length one, to be used as an argument of view function.">xt::newaxis()</a></code> at the indicated axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">axis</td><td>axis to expand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a <code>strided_view</code> with expanded dimension </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00472">472</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a3702c94500428b6c0c24a493ea020606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3702c94500428b6c0c24a493ea020606">&#9670;&nbsp;</a></span>eye() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = bool&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::eye </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an array with ones on the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>shape of the resulting expression </td></tr>
    <tr><td class="paramname">k</td><td>index of the diagonal. 0 (default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value_type of xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator that generates the values on access </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00398">398</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="af1633ad856dcd79570c229d95b09cf19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1633ad856dcd79570c229d95b09cf19">&#9670;&nbsp;</a></span>eye() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = bool&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::eye </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a (n x n) array with ones on the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>length of the diagonal. </td></tr>
    <tr><td class="paramname">k</td><td>index of the diagonal. 0 (default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value_type of xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator that generates the values on access </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00413">413</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="ae36e1cf727c1a3ea6c7889f149c0737b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36e1cf727c1a3ea6c7889f149c0737b">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E , class O &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::filter </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a view into <em>e</em> filtered by <em>condition</em>. </p>
<p>Returns a 1D view with the elements selected where <em>condition</em> evaluates to <em>true</em>. This is equivalent to</p><pre class="fragment">{index_view(e, argwhere(condition));}</pre><p> The returned view is not optimal if you just want to assign a scalar to the filtered elements. In that case, you should consider using the <a class="el" href="namespacext.html#a588bc1e3b2c1f7c9b8238dddaf05a9df">filtration</a> function instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>the traversal order </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the underlying xexpression </td></tr>
    <tr><td class="paramname">condition</td><td>xexpression with shape of <em>e</em> which selects indices</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">xarray&lt;double&gt; a = {{1,5,3}, {4,5,6}};</div>
<div class="line">b = <a class="code" href="namespacext.html#ae36e1cf727c1a3ea6c7889f149c0737b">filter</a>(a, a &gt;= 5);</div>
<div class="line">std::cout &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// {5, 5, 6}</span></div>
<div class="ttc" id="anamespacext_html_ae36e1cf727c1a3ea6c7889f149c0737b"><div class="ttname"><a href="namespacext.html#ae36e1cf727c1a3ea6c7889f149c0737b">xt::filter</a></div><div class="ttdeci">auto filter(E &amp;&amp;e, O &amp;&amp;condition) noexcept</div><div class="ttdoc">creates a view into e filtered by condition.</div><div class="ttdef"><b>Definition:</b> <a href="xindex__view_8hpp_source.html#l00786">xindex_view.hpp:786</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a588bc1e3b2c1f7c9b8238dddaf05a9df" title="creates a filtration of e filtered by condition.">filtration</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xindex__view_8hpp_source.html#l00786">786</a> of file <a class="el" href="xindex__view_8hpp_source.html">xindex_view.hpp</a>.</p>

</div>
</div>
<a id="a588bc1e3b2c1f7c9b8238dddaf05a9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588bc1e3b2c1f7c9b8238dddaf05a9df">&#9670;&nbsp;</a></span>filtration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::filtration </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a filtration of <code>e</code> filtered by <em>condition</em>. </p>
<p>Returns a lazy filtration optimized for scalar assignment. Actually, scalar assignment and computed scalar assignments are the only available methods of the filtration, the filtration IS NOT an <a class="el" href="classxt_1_1xexpression.html">xexpression</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a> to filter </td></tr>
    <tr><td class="paramname">condition</td><td>the filtering <a class="el" href="classxt_1_1xexpression.html">xexpression</a></td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">xarray&lt;double&gt; a = {{1,5,3}, {4,5,6}};</div>
<div class="line"><a class="code" href="namespacext.html#a588bc1e3b2c1f7c9b8238dddaf05a9df">filtration</a>(a, a &gt;= 5) += 2;</div>
<div class="line">std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// {{1, 7, 3}, {4, 7, 8}}</span></div>
<div class="ttc" id="anamespacext_html_a588bc1e3b2c1f7c9b8238dddaf05a9df"><div class="ttname"><a href="namespacext.html#a588bc1e3b2c1f7c9b8238dddaf05a9df">xt::filtration</a></div><div class="ttdeci">auto filtration(E &amp;&amp;e, C &amp;&amp;condition) noexcept</div><div class="ttdoc">creates a filtration of e filtered by condition.</div><div class="ttdef"><b>Definition:</b> <a href="xindex__view_8hpp_source.html#l00811">xindex_view.hpp:811</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="xindex__view_8hpp_source.html#l00811">811</a> of file <a class="el" href="xindex__view_8hpp_source.html">xindex_view.hpp</a>.</p>

</div>
</div>
<a id="afe8bacc1aed492dc936c80bc58730463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8bacc1aed492dc936c80bc58730463">&#9670;&nbsp;</a></span>flatnonzero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::flatnonzero </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return indices that are non-zero in the flattened version of arr, equivalent to nonzero(ravel&lt;layout_type&gt;(arr))[0]; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>input array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indices that are non-zero in the flattened version of arr </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00320">320</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a10a975d3b718bfaf8ecf1db8072a0a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a975d3b718bfaf8ecf1db8072a0a0c">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::flatten </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a flatten view of the given expression. </p>
<p>No copy is made. This method is equivalent to ravel and is provided for API sameness with Numpy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>the layout used to read the elements of e. If no parameter is specified, XTENSOR_DEFAULT_TRAVERSAL is used. </td></tr>
    <tr><td class="paramname">E</td><td>the type of the expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a52d3b08fa67fe8c498e4271fca338e28" title="Returns a flatten view of the given expression.">ravel</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00307">307</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a5c1acf7068270be8ab0ef904dd0f5a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1acf7068270be8ab0ef904dd0f5a54">&#9670;&nbsp;</a></span>flatten_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::flatten_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>std::vector&lt;index_type&gt;</code> (returned e.g. </p>
<p>from <code><a class="el" href="group__logical__operators.html#ga8e8213a0ec55abe31dc046b6a03379d7" title="return vector of indices where arr is not zero">xt::argwhere</a></code>) to a flattened <code>xtensor</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>a vector of indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d" title="Alias template on xtensor_container with default parameters for data container type.">xt::xtensor</a>&lt;typename index_type::value_type, 1&gt;</code> (e.g. <code><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d" title="Alias template on xtensor_container with default parameters for data container type.">xt::xtensor</a>&lt;size_t, 1&gt;</code>) </dd></dl>

<p class="definition">Definition at line <a class="el" href="xtensor_8hpp_source.html#l00844">844</a> of file <a class="el" href="xtensor_8hpp_source.html">xtensor.hpp</a>.</p>

</div>
</div>
<a id="a4bf31ad3a5950024a3825118f9f6a4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf31ad3a5950024a3825118f9f6a4e7">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::flip </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the order of elements in an xexpression along the given axis. </p>
<p>Note: A NumPy/Matlab style <code>flipud(arr)</code> is equivalent to <code>xt::flip(arr, 0)</code>, <code>fliplr(arr)</code> to <code>xt::flip(arr, 1)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input xexpression </td></tr>
    <tr><td class="paramname">axis</td><td>the axis along which elements should be reversed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a view with the result of the flip </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00632">632</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="ade2d67c70b0ec6af8294f4b7f201a722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2d67c70b0ec6af8294f4b7f201a722">&#9670;&nbsp;</a></span>from_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::from_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <code>std::vector&lt;index_type&gt;</code> (returned e.g. </p>
<p>from <code><a class="el" href="group__logical__operators.html#ga8e8213a0ec55abe31dc046b6a03379d7" title="return vector of indices where arr is not zero">xt::argwhere</a></code>) to <code>xtensor</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>vector of indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d" title="Alias template on xtensor_container with default parameters for data container type.">xt::xtensor</a>&lt;typename index_type::value_type, 2&gt;</code> (e.g. <code><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d" title="Alias template on xtensor_container with default parameters for data container type.">xt::xtensor</a>&lt;size_t, 2&gt;</code>) </dd></dl>

<p class="definition">Definition at line <a class="el" href="xtensor_8hpp_source.html#l00812">812</a> of file <a class="el" href="xtensor_8hpp_source.html">xtensor.hpp</a>.</p>

</div>
</div>
<a id="a3d553d1a9a0e27ad8c9054389c1e2c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d553d1a9a0e27ad8c9054389c1e2c59">&#9670;&nbsp;</a></span>from_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class M, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enable_xcontainer_semantics&lt; E &gt; xt::from_json </td>
          <td>(</td>
          <td class="paramtype">const nlohmann::basic_json&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>JSON deserialization of a xtensor expression with a container or a view semantics. </p>
<p>The from_json method is used by the nlohmann_json library for automatic serialization of user-defined types. The method is picked up by argument-dependent lookup.</p>
<p>Note: for converting a JSON object to a value, nlohmann_json requires the value type to be default constructible, which is typically not the case for expressions with a view semantics. In this case, from_json can be called directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>a const JSON object </td></tr>
    <tr><td class="paramname">e</td><td>an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xjson_8hpp_source.html#l00156">156</a> of file <a class="el" href="xjson_8hpp_source.html">xjson.hpp</a>.</p>

</div>
</div>
<a id="a682f65e5eb55b03cbef5fbd25bbdc349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682f65e5eb55b03cbef5fbd25bbdc349">&#9670;&nbsp;</a></span>full_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::full_like </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename E::value_type&#160;</td>
          <td class="paramname"><em>fill_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a xcontainer (xarray, xtensor or xtensor_fixed), filled with <em>fill_value</em> and of the same shape, value type and layout as the input xexpression <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression from which to extract shape, value type and layout. </td></tr>
    <tr><td class="paramname">fill_value</td><td>the value used to set each element of the returned xcontainer. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00136">136</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a4453a49484a5833cbf48e51eff2ed3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4453a49484a5833cbf48e51eff2ed3df">&#9670;&nbsp;</a></span>has_shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S , class  = typename std::enable_if_t&lt;has_iterator_interface&lt;S&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xt::has_shape </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>has_shape </p>
<p>Check if an object has a certain shape. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an array </td></tr>
    <tr><td class="paramname">shape</td><td>the shape to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="xshape_8hpp_source.html#l00143">143</a> of file <a class="el" href="xshape_8hpp_source.html">xshape.hpp</a>.</p>

</div>
</div>
<a id="a56d28aa1be818adaecee7803249dad7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d28aa1be818adaecee7803249dad7d">&#9670;&nbsp;</a></span>has_shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xt::has_shape </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; S &gt;&#160;</td>
          <td class="paramname"><em>shape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>has_shape </p>
<p>Check if an object has a certain shape. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an array </td></tr>
    <tr><td class="paramname">shape</td><td>the shape to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="xshape_8hpp_source.html#l00128">128</a> of file <a class="el" href="xshape_8hpp_source.html">xshape.hpp</a>.</p>

</div>
</div>
<a id="a0a5ba67f2a11ee24ccf629105d12e407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5ba67f2a11ee24ccf629105d12e407">&#9670;&nbsp;</a></span>histogram() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>bin_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>density</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the histogram of a set of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bin_edges</td><td>The bin-edges. </td></tr>
    <tr><td class="paramname">density</td><td>If true the resulting integral is normalized to 1. [default: false] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bin_edges.size()-1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00161">161</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="a95e9ea74b2e3f62bb682798bd5d7414d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e9ea74b2e3f62bb682798bd5d7414d">&#9670;&nbsp;</a></span>histogram() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class E1 , class E2 , class E3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>bin_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E3 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>density</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the histogram of a set of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bin_edges</td><td>The bin-edges. It has to be 1-dimensional and monotonic. </td></tr>
    <tr><td class="paramname">weights</td><td>Weight factors corresponding to each data-point. </td></tr>
    <tr><td class="paramname">density</td><td>If true the resulting integral is normalized to 1. [default: false] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bin_edges.size()-1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00142">142</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="a8545490885a4a8466344d954bd5326c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8545490885a4a8466344d954bd5326c1">&#9670;&nbsp;</a></span>histogram() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>density</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the histogram of a set of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. </td></tr>
    <tr><td class="paramname">weights</td><td>Weight factors corresponding to each data-point. </td></tr>
    <tr><td class="paramname">density</td><td>If true the resulting integral is normalized to 1. [default: false] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bin_edges.size()-1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00233">233</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="aaadf08c80728a3d2ace5739f3350f908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadf08c80728a3d2ace5739f3350f908">&#9670;&nbsp;</a></span>histogram() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class E1 , class E2 , class E3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E3&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E3&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>density</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the histogram of a set of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. </td></tr>
    <tr><td class="paramname">left</td><td>The lower-most edge. </td></tr>
    <tr><td class="paramname">right</td><td>The upper-most edge. </td></tr>
    <tr><td class="paramname">weights</td><td>Weight factors corresponding to each data-point. </td></tr>
    <tr><td class="paramname">density</td><td>If true the resulting integral is normalized to 1. [default: false] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bin_edges.size()-1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00255">255</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="a60449f18cbf62c0a104cf72e53f7948d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60449f18cbf62c0a104cf72e53f7948d">&#9670;&nbsp;</a></span>histogram() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>density</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the histogram of a set of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. </td></tr>
    <tr><td class="paramname">left</td><td>The lower-most edge. </td></tr>
    <tr><td class="paramname">right</td><td>The upper-most edge. </td></tr>
    <tr><td class="paramname">density</td><td>If true the resulting integral is normalized to 1. [default: false] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bin_edges.size()-1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00209">209</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="ad8379adac71c1af9b9bc50f835d9536f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8379adac71c1af9b9bc50f835d9536f">&#9670;&nbsp;</a></span>histogram() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R  = double, class E1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>density</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the histogram of a set of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. [default: 10] </td></tr>
    <tr><td class="paramname">density</td><td>If true the resulting integral is normalized to 1. [default: false] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bin_edges.size()-1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00184">184</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="a53ca89b6c48fc35c9a293c2d81f66288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ca89b6c48fc35c9a293c2d81f66288">&#9670;&nbsp;</a></span>histogram_bin_edges() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 , class E2 , class E3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram_bin_edges </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E3&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E3&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>histogram_algorithm::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the bin-edges of a histogram of a set of data using different algorithms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">weights</td><td>Weight factors corresponding to each data-point. </td></tr>
    <tr><td class="paramname">left</td><td>The lower-most edge. </td></tr>
    <tr><td class="paramname">right</td><td>The upper-most edge. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. [default: 10] </td></tr>
    <tr><td class="paramname">mode</td><td>The type of algorithm to use. [default: "auto"] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bins+1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00289">289</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="aa3d16282168b4675fdc93c5563eb5324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d16282168b4675fdc93c5563eb5324">&#9670;&nbsp;</a></span>histogram_bin_edges() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram_bin_edges </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>histogram_algorithm::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the bin-edges of a histogram of a set of data using different algorithms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">weights</td><td>Weight factors corresponding to each data-point. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. [default: 10] </td></tr>
    <tr><td class="paramname">mode</td><td>The type of algorithm to use. [default: "auto"] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bins+1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00408">408</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="a5abbd094554988573b2c3cce9e521aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abbd094554988573b2c3cce9e521aab">&#9670;&nbsp;</a></span>histogram_bin_edges() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram_bin_edges </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>histogram_algorithm::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the bin-edges of a histogram of a set of data using different algorithms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">left</td><td>The lower-most edge. </td></tr>
    <tr><td class="paramname">right</td><td>The upper-most edge. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. [default: 10] </td></tr>
    <tr><td class="paramname">mode</td><td>The type of algorithm to use. [default: "auto"] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bins+1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00465">465</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="a49105a6754699f6ab1073e9868782ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49105a6754699f6ab1073e9868782ec8">&#9670;&nbsp;</a></span>histogram_bin_edges() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::histogram_bin_edges </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bins</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#aaa63c71a8935d44bbec1aa9af4cb61b8">histogram_algorithm</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>histogram_algorithm::automatic</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the bin-edges of a histogram of a set of data using different algorithms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data. </td></tr>
    <tr><td class="paramname">bins</td><td>The number of bins. [default: 10] </td></tr>
    <tr><td class="paramname">mode</td><td>The type of algorithm to use. [default: "auto"] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An one-dimensional xarray&lt;double&gt;, length: bins+1. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xhistogram_8hpp_source.html#l00435">435</a> of file <a class="el" href="xhistogram_8hpp_source.html">xhistogram.hpp</a>.</p>

</div>
</div>
<a id="af342a194380b6c7bbc7f2c89f4e88317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af342a194380b6c7bbc7f2c89f4e88317">&#9670;&nbsp;</a></span>hsplit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::hsplit </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split an xexpression into subexpressions horizontally (column-wise) </p>
<p>This method is equivalent to <code>split(e, n, 1)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">n</td><td>number of elements to return </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00598">598</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="aacc647d8af519da1d2126ec96a97849f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacc647d8af519da1d2126ec96a97849f">&#9670;&nbsp;</a></span>hstack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... CT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::hstack </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; CT... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stack xexpressions in sequence horizontally (column wise). </p>
<p>This is equivalent to concatenation along the second axis, except for 1-D xexpressions where it concatenate along the firts axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xtuple</a> of xexpressions to stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator evaluating to stacked elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00836">836</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a155e369dcf03bd465609d279b82f6da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155e369dcf03bd465609d279b82f6da8">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) xt::imag </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> representing the imaginary part of the given expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a></td></tr>
  </table>
  </dd>
</dl>
<p>The returned expression either hold a const reference to <code>e</code> or a copy depending on whether <code>e</code> is an lvalue or an rvalue. </p>

<p class="definition">Definition at line <a class="el" href="xcomplex_8hpp_source.html#l00130">130</a> of file <a class="el" href="xcomplex_8hpp_source.html">xcomplex.hpp</a>.</p>

</div>
</div>
<a id="abb28cb642ab427195ca6120d59f34f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb28cb642ab427195ca6120d59f34f76">&#9670;&nbsp;</a></span>index_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::index_view </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates an indexview from a container of indices. </p>
<p>Returns a 1D view with the elements at <em>indices</em> selected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the underlying xexpression </td></tr>
    <tr><td class="paramname">indices</td><td>the indices to select</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">xarray&lt;double&gt; a = {{1,5,3}, {4,5,6}};</div>
<div class="line">b = <a class="code" href="namespacext.html#abb28cb642ab427195ca6120d59f34f76">index_view</a>(a, {{0, 0}, {1, 0}, {1, 1}});</div>
<div class="line">std::cout &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// {1, 4, 5}</span></div>
<div class="line">b += 100;</div>
<div class="line">std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// {{101, 5, 3}, {104, 105, 6}}</span></div>
<div class="ttc" id="anamespacext_html_abb28cb642ab427195ca6120d59f34f76"><div class="ttname"><a href="namespacext.html#abb28cb642ab427195ca6120d59f34f76">xt::index_view</a></div><div class="ttdeci">auto index_view(E &amp;&amp;e, I &amp;&amp;indices) noexcept</div><div class="ttdoc">creates an indexview from a container of indices.</div><div class="ttdef"><b>Definition:</b> <a href="xindex__view_8hpp_source.html#l00751">xindex_view.hpp:751</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="xindex__view_8hpp_source.html#l00751">751</a> of file <a class="el" href="xindex__view_8hpp_source.html">xindex_view.hpp</a>.</p>

</div>
</div>
<a id="acf2d8b5c3e1c55828c6cc62cb712f15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2d8b5c3e1c55828c6cc62cb712f15f">&#9670;&nbsp;</a></span>keep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::disable_integral_keep&lt;T&gt; xt::keep </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a non-contigous slice from a container of indices to keep. </p>
<p>Note: this slice cannot be used in the xstrided_view!</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = <a class="code" href="namespacext.html#a156656dea2a291a2b0978a2b02d7f0f7">xt::arange</a>(9);</div>
<div class="line">a.reshape({3, 3});</div>
<div class="line"><a class="code" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa">xt::view</a>(a, <a class="code" href="namespacext.html#acf2d8b5c3e1c55828c6cc62cb712f15f">xt::keep</a>(0, 2); <span class="comment">// =&gt; {{0, 1, 2}, {6, 7, 8}}</span></div>
<div class="line"><a class="code" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa">xt::view</a>(a, <a class="code" href="namespacext.html#acf2d8b5c3e1c55828c6cc62cb712f15f">xt::keep</a>(1, 1, 1); <span class="comment">// =&gt; {{3, 4, 5}, {3, 4, 5}, {3, 4, 5}}</span></div>
<div class="ttc" id="anamespacext_html_acf2d8b5c3e1c55828c6cc62cb712f15f"><div class="ttname"><a href="namespacext.html#acf2d8b5c3e1c55828c6cc62cb712f15f">xt::keep</a></div><div class="ttdeci">detail::disable_integral_keep&lt; T &gt; keep(T &amp;&amp;indices)</div><div class="ttdoc">Create a non-contigous slice from a container of indices to keep.</div><div class="ttdef"><b>Definition:</b> <a href="xslice_8hpp_source.html#l00393">xslice.hpp:393</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices container </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>instance of <a class="el" href="classxt_1_1xkeep__slice.html">xkeep_slice</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xslice_8hpp_source.html#l00393">393</a> of file <a class="el" href="xslice_8hpp_source.html">xslice.hpp</a>.</p>

</div>
</div>
<a id="a84b4f2192981c30e7ee35fba2b164cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b4f2192981c30e7ee35fba2b164cb2">&#9670;&nbsp;</a></span>linspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::linspace </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_samples</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endpoint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates <em>num_samples</em> evenly spaced numbers over given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>start of interval </td></tr>
    <tr><td class="paramname">stop</td><td>stop of interval </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples (defaults to 50) </td></tr>
    <tr><td class="paramname">endpoint</td><td>if true, include endpoint (defaults to true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value_type of xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator that generates the values on access </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00455">455</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a1a7ff9a44466a0de5525ac507db04e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7ff9a44466a0de5525ac507db04e6a">&#9670;&nbsp;</a></span>load_csv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A  = std::allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxt_1_1xtensor__container.html">xcsv_tensor</a>&lt; T, A &gt; xt::load_csv </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>skip_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>max_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>comments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load tensor from CSV. </p>
<p>Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> for the parsed CSV </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>the input stream containing the CSV encoded values </td></tr>
    <tr><td class="paramname">delimiter</td><td>the character used to separate values. [default: ','] </td></tr>
    <tr><td class="paramname">skip_rows</td><td>the number of lines to skip from the beginning. [default: 0] </td></tr>
    <tr><td class="paramname">max_rows</td><td>the number of lines to read after skip_rows lines; the default is to read all the lines. [default: -1] </td></tr>
    <tr><td class="paramname">comments</td><td>the string used to indicate the start of a comment. [default: "#"] </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xcsv_8hpp_source.html#l00116">116</a> of file <a class="el" href="xcsv_8hpp_source.html">xcsv.hpp</a>.</p>

</div>
</div>
<a id="a2466a03b0fed69ae73a2e01490af1fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2466a03b0fed69ae73a2e01490af1fec">&#9670;&nbsp;</a></span>load_npy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , layout_type L = layout_type::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::load_npy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a npy file (the numpy storage format) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename or path to the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>select the type of the npy file (note: currently there is no dynamic casting if types do not match) </td></tr>
    <tr><td class="paramname">L</td><td>select <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a8c23f260f0ec1479d3bfaf3a1305a347">layout_type::column_major</a> if you stored data in Fortran format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xarray with contents from npy file </dd></dl>

<p class="definition">Definition at line <a class="el" href="xnpy_8hpp_source.html#l00720">720</a> of file <a class="el" href="xnpy_8hpp_source.html">xnpy.hpp</a>.</p>

</div>
</div>
<a id="a09f40ac64487910bfee944c044c9739c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f40ac64487910bfee944c044c9739c">&#9670;&nbsp;</a></span>load_npy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , layout_type L = layout_type::dynamic&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::load_npy </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a npy file (the numpy storage format) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>An input stream from which to load the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>select the type of the npy file (note: currently there is no dynamic casting if types do not match) </td></tr>
    <tr><td class="paramname">L</td><td>select <a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a8c23f260f0ec1479d3bfaf3a1305a347">layout_type::column_major</a> if you stored data in Fortran format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xarray with contents from npy file </dd></dl>

<p class="definition">Definition at line <a class="el" href="xnpy_8hpp_source.html#l00703">703</a> of file <a class="el" href="xnpy_8hpp_source.html">xnpy.hpp</a>.</p>

</div>
</div>
<a id="ae448d7eb5de30ef12ca38ca7d6d15356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae448d7eb5de30ef12ca38ca7d6d15356">&#9670;&nbsp;</a></span>logspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::logspace </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>stop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endpoint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates <em>num_samples</em> numbers evenly spaced on a log scale over given interval. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>start of interval (pow(base, start) is the first value). </td></tr>
    <tr><td class="paramname">stop</td><td>stop of interval (pow(base, stop) is the final value, except if endpoint = false) </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples (defaults to 50) </td></tr>
    <tr><td class="paramname">base</td><td>the base of the log space. </td></tr>
    <tr><td class="paramname">endpoint</td><td>if true, include endpoint (defaults to true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value_type of xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator that generates the values on access </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00473">473</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a259a5c38335a33c4a6f8aff517494efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259a5c38335a33c4a6f8aff517494efb">&#9670;&nbsp;</a></span>make_lambda_xfunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::make_lambda_xfunction </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a xfunction from a lambda. </p>
<p>This function can be used to easily create performant xfunctions from lambdas:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> E1&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> <a class="code" href="group__pow__functions.html#ga6e5fca6d456f46a946b4a9707e1d442f">square</a>(E1&amp;&amp; e1) noexcept</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> fnct = [](<span class="keyword">auto</span> x) -&gt; decltype(x * x) {</div>
<div class="line">        <span class="keywordflow">return</span> x * x;</div>
<div class="line">    };</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacext.html#a259a5c38335a33c4a6f8aff517494efb">make_lambda_xfunction</a>(std::move(fnct), std::forward&lt;E1&gt;(e1));</div>
<div class="line">}</div>
<div class="ttc" id="agroup__pow__functions_html_ga6e5fca6d456f46a946b4a9707e1d442f"><div class="ttname"><a href="group__pow__functions.html#ga6e5fca6d456f46a946b4a9707e1d442f">xt::square</a></div><div class="ttdeci">auto square(E1 &amp;&amp;e1) noexcept</div><div class="ttdoc">Square power function, equivalent to e1 * e1.</div><div class="ttdef"><b>Definition:</b> <a href="xmath_8hpp_source.html#l01113">xmath.hpp:1113</a></div></div>
<div class="ttc" id="anamespacext_html_a259a5c38335a33c4a6f8aff517494efb"><div class="ttname"><a href="namespacext.html#a259a5c38335a33c4a6f8aff517494efb">xt::make_lambda_xfunction</a></div><div class="ttdeci">auto make_lambda_xfunction(F &amp;&amp;lambda, E &amp;&amp;... args)</div><div class="ttdoc">Create a xfunction from a lambda.</div><div class="ttdef"><b>Definition:</b> <a href="xmath_8hpp_source.html#l01067">xmath.hpp:1067</a></div></div>
</div><!-- fragment --><p>Lambda function allow the reusal of a single arguments in multiple places (otherwise only correctly possible when using xshared_expressions). <code>auto</code> lambda functions are automatically vectorized with <code>xsimd</code> if possible (note that the trailing <code>-&gt; decltype(...)</code> is mandatory for the feature detection to work).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>the lambda to be vectorized </td></tr>
    <tr><td class="paramname">args</td><td>forwarded arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lazy xfunction </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmath_8hpp_source.html#l01067">1067</a> of file <a class="el" href="xmath_8hpp_source.html">xmath.hpp</a>.</p>

</div>
</div>
<a id="a560c81d3d88fa9b3200b72e70b44c288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560c81d3d88fa9b3200b72e70b44c288">&#9670;&nbsp;</a></span>make_xshared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxt_1_1xshared__expression.html">xshared_expression</a>&lt;E&gt; xt::make_xshared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to create shared expression from any xexpression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>rvalue expression that will be shared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xshared expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="xexpression_8hpp_source.html#l00735">735</a> of file <a class="el" href="xexpression_8hpp_source.html">xexpression.hpp</a>.</p>

</div>
</div>
<a id="ae6a650f8da9d0066e26ecda36ee293e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a650f8da9d0066e26ecda36ee293e4">&#9670;&nbsp;</a></span>median()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::median </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the median along the specified axis. </p>
<p>Given a vector V of length N, the median of V is the middle value of a sorted copy of V, V_sorted - i e., V_sorted[(N-1)/2], when N is odd, and the average of the two middle values of V_sorted when N is even.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axis</td><td>axis along which the medians are computed. If not set, computes the median along a flattened version of the input. </td></tr>
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>median value </dd></dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00733">733</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="a513e9f91fb23575e3e35eff04c628e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513e9f91fb23575e3e35eff04c628e19">&#9670;&nbsp;</a></span>meshgrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::meshgrid </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;...&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return coordinate tensors from coordinate vectors. </p>
<p>Make N-D coordinate tensor expressions for vectorized evaluations of N-D scalar/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,..., xn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>xexpressions to concatenate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of xgenerator expressions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00914">914</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a534914903c805a597a5fac60e60e7c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534914903c805a597a5fac60e60e7c43">&#9670;&nbsp;</a></span>newaxis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::newaxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice representing a new axis of length one, to be used as an argument of view function. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa" title="Constructs and returns a view on the specified xexpression.">view</a>, <a class="el" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26" title="Construct a strided view from an xexpression, shape, strides and offset.">strided_view</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xslice_8hpp_source.html#l00289">289</a> of file <a class="el" href="xslice_8hpp_source.html">xslice.hpp</a>.</p>

</div>
</div>
<a id="ad3afef5ff535998e5dd0d95a979c54bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3afef5ff535998e5dd0d95a979c54bf">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::norm </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the squared magnitude elementwise for the complex numbers in e. </p>
<p>Equivalent to pow(real(e), 2) + pow(imag(e), 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xcomplex_8hpp_source.html#l00252">252</a> of file <a class="el" href="xcomplex_8hpp_source.html">xcomplex.hpp</a>.</p>

</div>
</div>
<a id="a498ae15885758184e0ee9def889b6bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498ae15885758184e0ee9def889b6bfb">&#9670;&nbsp;</a></span>ones()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::ones </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> containing ones of the specified shape. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">shape</td><td>the shape of the returned expression. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00046">46</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a40664e859ef008b427ea6d8a013ebb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40664e859ef008b427ea6d8a013ebb96">&#9670;&nbsp;</a></span>ones_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::ones_like </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a xcontainer (xarray, xtensor or xtensor_fixed), filled with ones and of the same shape, value type and layout as the input xexpression <em>e</em>. </p>
<p>Note: contrary to ones(shape), this function returns a non-lazy, evaluated container! Use <code><a class="el" href="namespacext.html#a498ae15885758184e0ee9def889b6bfb" title="Returns an xexpression containing ones of the specified shape.">xt::ones</a>&lt;double&gt;(e.shape());</code> for a lazy version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression from which to extract shape, value type and layout. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00169">169</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="aafb4918c6aea49e7968e4ed024a70a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb4918c6aea49e7968e4ed024a70a99">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__logical__operators.html#ga669c5968e594e618cd199674074c32e4">xt::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks inequality of the iterators. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the iterators are different, true otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__iterator_8hpp_source.html#l00264">264</a> of file <a class="el" href="xaxis__iterator_8hpp_source.html">xaxis_iterator.hpp</a>.</p>

</div>
</div>
<a id="a1e99b6c54f3a5fca29006d1b114e356d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e99b6c54f3a5fca29006d1b114e356d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__logical__operators.html#ga669c5968e594e618cd199674074c32e4">xt::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks inequality of the iterators. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the iterators are different, true otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__slice__iterator_8hpp_source.html#l00260">260</a> of file <a class="el" href="xaxis__slice__iterator_8hpp_source.html">xaxis_slice_iterator.hpp</a>.</p>

</div>
</div>
<a id="a49dd71cabe349f77ec771f01fc46aeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dd71cabe349f77ec771f01fc46aeb3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__iterator.html">xaxis_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks equality of the iterators. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the iterators are equivalent, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__iterator_8hpp_source.html#l00254">254</a> of file <a class="el" href="xaxis__iterator_8hpp_source.html">xaxis_iterator.hpp</a>.</p>

</div>
</div>
<a id="aa8afbf971ca9887515e974de1775cf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8afbf971ca9887515e974de1775cf03">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xaxis__slice__iterator.html">xaxis_slice_iterator</a>&lt; CT &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks equality of the iterators. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the iterators are equivalent, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="xaxis__slice__iterator_8hpp_source.html#l00250">250</a> of file <a class="el" href="xaxis__slice__iterator_8hpp_source.html">xaxis_slice_iterator.hpp</a>.</p>

</div>
</div>
<a id="abd5658ce24f2035e2175546c9ca6ec59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5658ce24f2035e2175546c9ca6ec59">&#9670;&nbsp;</a></span>pad() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, class V  = typename std::decay_t&lt;E&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::pad </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; S &gt; &amp;&#160;</td>
          <td class="paramname"><em>pad_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">pad_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>pad_mode::constant</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>constant_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pad an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The array. </td></tr>
    <tr><td class="paramname">pad_width</td><td>Number of values padded to the edges of each axis: <code>{before, after}</code>. </td></tr>
    <tr><td class="paramname">mode</td><td>The type of algorithm to use. [default: <code>xt::pad_mode::constant</code>]. </td></tr>
    <tr><td class="paramname">constant_value</td><td>The value to set the padded values for each axis (used in <code>xt::pad_mode::constant</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The padded array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xpad_8hpp_source.html#l00200">200</a> of file <a class="el" href="xpad_8hpp_source.html">xpad.hpp</a>.</p>

</div>
</div>
<a id="a0006ff814bef7534b9fa5187b1863feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0006ff814bef7534b9fa5187b1863feb">&#9670;&nbsp;</a></span>pad() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, class V  = typename std::decay_t&lt;E&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::pad </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; S &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pad_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">pad_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>pad_mode::constant</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>constant_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pad an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The array. </td></tr>
    <tr><td class="paramname">pad_width</td><td>Number of values padded to the edges of each axis: <code>{{before_1, after_1}, ..., {before_N, after_N}}</code>. </td></tr>
    <tr><td class="paramname">mode</td><td>The type of algorithm to use. [default: <code>xt::pad_mode::constant</code>]. </td></tr>
    <tr><td class="paramname">constant_value</td><td>The value to set the padded values for each axis (used in <code>xt::pad_mode::constant</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The padded array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xpad_8hpp_source.html#l00075">75</a> of file <a class="el" href="xpad_8hpp_source.html">xpad.hpp</a>.</p>

</div>
</div>
<a id="ad10c047180a5ce9129d25c180369ad00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10c047180a5ce9129d25c180369ad00">&#9670;&nbsp;</a></span>pad() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, class V  = typename std::decay_t&lt;E&gt;::value_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::pad </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>pad_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#aa9d095239ac8c959a5d0a5b7086b5ae7">pad_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>pad_mode::constant</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>constant_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pad an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The array. </td></tr>
    <tr><td class="paramname">pad_width</td><td>Number of values padded to the edges of each axis. </td></tr>
    <tr><td class="paramname">mode</td><td>The type of algorithm to use. [default: <code>xt::pad_mode::constant</code>]. </td></tr>
    <tr><td class="paramname">constant_value</td><td>The value to set the padded values for each axis (used in <code>xt::pad_mode::constant</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The padded array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xpad_8hpp_source.html#l00223">223</a> of file <a class="el" href="xpad_8hpp_source.html">xpad.hpp</a>.</p>

</div>
</div>
<a id="a08ff136e0f1b09d37952f7828c65316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ff136e0f1b09d37952f7828c65316e">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class C , class R  = detail::flatten_sort_result_type_t&lt;E&gt;, class  = std::enable_if_t&lt;!xtl::is_integral&lt;C&gt;::value, int&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R xt::partition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>kth_container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structxt_1_1placeholders_1_1xtuph.html">placeholders::xtuph</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partially sort xexpression. </p>
<p>Partition shuffles the xexpression in a way so that the kth element in the returned xexpression is in the place it would appear in a sorted array and all elements smaller than this entry are placed (unsorted) before.</p>
<p>The optional third parameter can either be an axis or <code>xnone()</code> in which case the xexpression will be flattened.</p>
<p>This function uses <code>std::nth_element</code> internally.</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;float&gt;</a> a = {1, 10, -10, 123};</div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacext.html#a08ff136e0f1b09d37952f7828c65316e">xt::partition</a>(a, 0) &lt;&lt; std::endl; <span class="comment">// {-10, 1, 123, 10} the correct entry at index 0</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacext.html#a08ff136e0f1b09d37952f7828c65316e">xt::partition</a>(a, 3) &lt;&lt; std::endl; <span class="comment">// {1, 10, -10, 123} the correct entry at index 3</span></div>
<div class="line">std::cout &lt;&lt; <a class="code" href="namespacext.html#a08ff136e0f1b09d37952f7828c65316e">xt::partition</a>(a, {0, 3}) &lt;&lt; std::endl; <span class="comment">// {-10, 1, 10, 123} the correct entries at index 0 and 3</span></div>
<div class="ttc" id="anamespacext_html_a08ff136e0f1b09d37952f7828c65316e"><div class="ttname"><a href="namespacext.html#a08ff136e0f1b09d37952f7828c65316e">xt::partition</a></div><div class="ttdeci">R partition(const xexpression&lt; E &gt; &amp;e, const C &amp;kth_container, placeholders::xtuph)</div><div class="ttdoc">Partially sort xexpression.</div><div class="ttdef"><b>Definition:</b> <a href="xsort_8hpp_source.html#l00410">xsort.hpp:410</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">kth_container</td><td>a container of <code>indices</code> that should contain the correctly sorted value </td></tr>
    <tr><td class="paramname">axis</td><td>either integer (default = -1) to sort along last axis or <code>xnone()</code> to flatten before sorting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>partially sorted xcontainer </dd></dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00410">410</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="a12df38a6d4e688b6df1a4641930c6181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12df38a6d4e688b6df1a4641930c6181">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::range </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>start_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>stop_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a range from start_val to stop_val (excluded). </p>
<p>You can use the shorthand <code>_</code> syntax to select from the start or until the end.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>xt::placeholders;  <span class="comment">// to enable _ syntax</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">range</a>(3, _)  <span class="comment">// select from index 3 to the end</span></div>
<div class="line"><a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">range</a>(_, 5)  <span class="comment">// select from index 0 to 5 (excluded)</span></div>
<div class="line"><a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">range</a>(_, _)  <span class="comment">// equivalent to `all()`</span></div>
<div class="ttc" id="anamespacext_html_a12df38a6d4e688b6df1a4641930c6181"><div class="ttname"><a href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">xt::range</a></div><div class="ttdeci">auto range(A start_val, B stop_val)</div><div class="ttdoc">Select a range from start_val to stop_val (excluded).</div><div class="ttdef"><b>Definition:</b> <a href="xslice_8hpp_source.html#l00798">xslice.hpp:798</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa" title="Constructs and returns a view on the specified xexpression.">view</a>, <a class="el" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26" title="Construct a strided view from an xexpression, shape, strides and offset.">strided_view</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xslice_8hpp_source.html#l00798">798</a> of file <a class="el" href="xslice_8hpp_source.html">xslice.hpp</a>.</p>

</div>
</div>
<a id="ad1605028ad21316d7118d9c2c56b93a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1605028ad21316d7118d9c2c56b93a4">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A , class B , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::range </td>
          <td>(</td>
          <td class="paramtype">A&#160;</td>
          <td class="paramname"><em>start_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>stop_val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select a range from start_val to stop_val (excluded) with step You can use the shorthand <code>_</code> syntax to select from the start or until the end. </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>xt::placeholders;  <span class="comment">// to enable _ syntax</span></div>
<div class="line"><a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">range</a>(3, _, 5)  <span class="comment">// select from index 3 to the end with stepsize 5</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#aedc2027ff309134dff5b0720699c5ffa" title="Constructs and returns a view on the specified xexpression.">view</a>, <a class="el" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26" title="Construct a strided view from an xexpression, shape, strides and offset.">strided_view</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xslice_8hpp_source.html#l00816">816</a> of file <a class="el" href="xslice_8hpp_source.html">xslice.hpp</a>.</p>

</div>
</div>
<a id="a52d3b08fa67fe8c498e4271fca338e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d3b08fa67fe8c498e4271fca338e28">&#9670;&nbsp;</a></span>ravel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::ravel </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a flatten view of the given expression. </p>
<p>No copy is made. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>the layout used to read the elements of e. If no parameter is specified, XTENSOR_DEFAULT_TRAVERSAL is used. </td></tr>
    <tr><td class="paramname">E</td><td>the type of the expression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00285">285</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="ad2c2456464d4176eb6b659067f8887bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c2456464d4176eb6b659067f8887bc">&#9670;&nbsp;</a></span>ravel_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tag  = ravel_tensor_tag, class C , class S &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ravel_return_type_t&lt;C, Tag&gt; xt::ravel_indices </td>
          <td>(</td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td>
          <td class="paramname"><em>l</em> = <code><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6a641fabb8e5e7d1d0333e2c9c384f959c">layout_type::row_major</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <code>std::vector&lt;index_type&gt;</code> (returned e.g. </p>
<p>from <code><a class="el" href="group__logical__operators.html#ga8e8213a0ec55abe31dc046b6a03379d7" title="return vector of indices where arr is not zero">xt::argwhere</a></code>) to <code>xtensor</code> whereby the indices are ravelled. For 1-d input there is no conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>vector of indices </td></tr>
    <tr><td class="paramname">shape</td><td>the shape of the original array </td></tr>
    <tr><td class="paramname">l</td><td>the layout type (row-major or column-major)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d" title="Alias template on xtensor_container with default parameters for data container type.">xt::xtensor</a>&lt;typename index_type::value_type, 1&gt;</code> (e.g. <code><a class="el" href="namespacext.html#a29d0a2d76c0f69cf43aa3b4f55a7a26d" title="Alias template on xtensor_container with default parameters for data container type.">xt::xtensor</a>&lt;size_t, 1&gt;</code>) </dd></dl>

<p class="definition">Definition at line <a class="el" href="xtensor_8hpp_source.html#l00911">911</a> of file <a class="el" href="xtensor_8hpp_source.html">xtensor.hpp</a>.</p>

</div>
</div>
<a id="a40dd460909cc5b81f23947646eebd543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dd460909cc5b81f23947646eebd543">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) xt::real </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> representing the real part of the given expression. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a></td></tr>
  </table>
  </dd>
</dl>
<p>The returned expression either hold a const reference to <code>e</code> or a copy depending on whether <code>e</code> is an lvalue or an rvalue. </p>

<p class="definition">Definition at line <a class="el" href="xcomplex_8hpp_source.html#l00116">116</a> of file <a class="el" href="xcomplex_8hpp_source.html">xcomplex.hpp</a>.</p>

</div>
</div>
<a id="a2bf61f96fdc4316d3eefa8dff6174ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf61f96fdc4316d3eefa8dff6174ece">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class E , class X , class EVS  = std::tuple&lt;evaluation_strategy::lazy_type&gt;, xtl::check_concept&lt; xtl::negation&lt; is_reducer_options&lt; X &gt;&gt;, detail::is_xreducer_functors&lt; F &gt; &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::reduce </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EVS &amp;&amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>EVS()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> applying the specified reducing function to an expression over the given axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the reducing function to apply. </td></tr>
    <tr><td class="paramname">e</td><td>the <a class="el" href="classxt_1_1xexpression.html">xexpression</a> to reduce. </td></tr>
    <tr><td class="paramname">axes</td><td>the list of axes. </td></tr>
    <tr><td class="paramname">options</td><td>evaluation strategy to use (lazy (default), or immediate)</td></tr>
  </table>
  </dd>
</dl>
<p>The returned expression either hold a const reference to <code>e</code> or a copy depending on whether <code>e</code> is an lvalue or an rvalue. </p>

<p class="definition">Definition at line <a class="el" href="xreducer_8hpp_source.html#l00911">911</a> of file <a class="el" href="xreducer_8hpp_source.html">xreducer.hpp</a>.</p>

</div>
</div>
<a id="a0061839371ca8e1f29c37e812dee9ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0061839371ca8e1f29c37e812dee9ad1">&#9670;&nbsp;</a></span>repeat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::repeat </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>repeats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats elements of an expression along a given axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input xexpression </td></tr>
    <tr><td class="paramname">repeats</td><td>The number of repetition of each elements. The size of repeats must match the shape of the given axis. </td></tr>
    <tr><td class="paramname">axis</td><td>the axis along which to repeat the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expression which as the same shape as e, except along the given axis </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00912">912</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a86b343ba5d1f6150c418475a00e3d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b343ba5d1f6150c418475a00e3d3c3">&#9670;&nbsp;</a></span>repeat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::repeat </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>repeats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats elements of an expression along a given axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input xexpression </td></tr>
    <tr><td class="paramname">repeats</td><td>The number of repetition of each elements. repeats is broadcasted to fit the shape of the given axis. </td></tr>
    <tr><td class="paramname">axis</td><td>the axis along which to repeat the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expression which as the same shape as e, except along the given axis </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00893">893</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a7aba37875778e4c7a786cbe6ec909ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aba37875778e4c7a786cbe6ec909ef2">&#9670;&nbsp;</a></span>repeat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::repeat </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>repeats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Repeats elements of an expression along a given axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input xexpression </td></tr>
    <tr><td class="paramname">repeats</td><td>The number of repetition of each elements. The size of repeats must match the shape of the given axis. </td></tr>
    <tr><td class="paramname">axis</td><td>the axis along which to repeat the value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an expression which as the same shape as e, except along the given axis </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00928">928</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a7bda1677287d8bee76befd8c427e3898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bda1677287d8bee76befd8c427e3898">&#9670;&nbsp;</a></span>reshape_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = ::xt::layout_type::row_major, class E , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::reshape_view </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a view on a container with a new shape. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>
<p>Note: if you resize the underlying container, this view becomes invalidated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>xexpression to reshape </td></tr>
    <tr><td class="paramname">shape</td><td>new shape </td></tr>
    <tr><td class="paramname">order</td><td>traversal order (optional)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view on xexpression with new shape </dd></dl>

<p class="definition">Definition at line <a class="el" href="xstrided__view_8hpp_source.html#l00736">736</a> of file <a class="el" href="xstrided__view_8hpp_source.html">xstrided_view.hpp</a>.</p>

</div>
</div>
<a id="a2211d25aea0f9a27855fb602419a365b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2211d25aea0f9a27855fb602419a365b">&#9670;&nbsp;</a></span>roll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::roll </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roll an expression. </p>
<p>The expression is flatten before shifting, after which the original shape is restore. Elements that roll beyond the last position are re-introduced at the first. This function does not change the input expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input xexpression </td></tr>
    <tr><td class="paramname">shift</td><td>the number of places by which elements are shifted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a roll of the input expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00753">753</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a957635620a4f4c19c4ee0546c69fcb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957635620a4f4c19c4ee0546c69fcb1d">&#9670;&nbsp;</a></span>roll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::roll </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Roll an expression along a given axis. </p>
<p>Elements that roll beyond the last position are re-introduced at the first. This function does not change the input expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input xexpression </td></tr>
    <tr><td class="paramname">shift</td><td>the number of places by which elements are shifted </td></tr>
    <tr><td class="paramname">axis</td><td>the axis along which elements are shifted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a roll of the input expression </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00840">840</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="ab5a947902290cc80a26e8d091428497e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a947902290cc80a26e8d091428497e">&#9670;&nbsp;</a></span>rot90()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ptrdiff_t N = 1, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::rot90 </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::ptrdiff_t, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate an array by 90 degrees in the plane specified by axes. </p>
<p>Rotation direction is from the first towards the second axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input xexpression </td></tr>
    <tr><td class="paramname">axes</td><td>the array is rotated in the plane defined by the axes. Axes must be different. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>number of times the array is rotated by 90 degrees. Default is 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a view with the result of the rotation </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00721">721</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a445fa98828eab51048b87fc29d8e88ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445fa98828eab51048b87fc29d8e88ad">&#9670;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::row </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and returns a row (sliced view) on the specified expression. </p>
<p>Users should not directly construct the slices but call helper functions instead. This function is only allowed on expressions with two dimensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression to adapt </td></tr>
    <tr><td class="paramname">index</td><td>0-based index of the row, negative indices will return the last rows in reverse order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the expression has more than 2 dimensions. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xview_8hpp_source.html#l01841">1841</a> of file <a class="el" href="xview_8hpp_source.html">xview.hpp</a>.</p>

</div>
</div>
<a id="a3c10cfb8271fbf79932a98edc5491ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c10cfb8271fbf79932a98edc5491ac7">&#9670;&nbsp;</a></span>same_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S1 , class S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xt::same_shape </td>
          <td>(</td>
          <td class="paramtype">const S1 &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S2 &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same_shape </p>
<p>Check if two objects have the same shape. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>an array </td></tr>
    <tr><td class="paramname">s2</td><td>an array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

<p class="definition">Definition at line <a class="el" href="xshape_8hpp_source.html#l00109">109</a> of file <a class="el" href="xshape_8hpp_source.html">xshape.hpp</a>.</p>

</div>
</div>
<a id="a7f2dbcb81b8a765fe3972a7490d62618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2dbcb81b8a765fe3972a7490d62618">&#9670;&nbsp;</a></span>searchsorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::searchsorted </td>
          <td>(</td>
          <td class="paramtype">E1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find indices where elements should be inserted to maintain order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input array: sorted (array_like). </td></tr>
    <tr><td class="paramname">v</td><td>Values to insert into a (array_like). </td></tr>
    <tr><td class="paramname">right</td><td>If <code>false</code>, the index of the first suitable location found is given. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of insertion points with the same shape as v. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xset__operation_8hpp_source.html#l00171">171</a> of file <a class="el" href="xset__operation_8hpp_source.html">xset_operation.hpp</a>.</p>

</div>
</div>
<a id="ab6eedcadc051be2d6e3ad7890a5c2d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6eedcadc051be2d6e3ad7890a5c2d90">&#9670;&nbsp;</a></span>setdiff1d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E1 , class E2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::setdiff1d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the set difference of two xexpressions. </p>
<p>This returns a flattened xtensor with the sorted, unique values in ar1 that are not in ar2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar1</td><td>input xexpression (will be flattened) </td></tr>
    <tr><td class="paramname">ar2</td><td>input xexpression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00932">932</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="ad90d6213ecfc3ae99eba87429935a38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90d6213ecfc3ae99eba87429935a38a">&#9670;&nbsp;</a></span>share() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to create shared expression from any xexpression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>rvalue expression that will be shared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xshared expression </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a560c81d3d88fa9b3200b72e70b44c288" title="Helper function to create shared expression from any xexpression.">make_xshared</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xexpression_8hpp_source.html#l00762">762</a> of file <a class="el" href="xexpression_8hpp_source.html">xexpression.hpp</a>.</p>

</div>
</div>
<a id="a39563f02e935d00d2df74796f2e19fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39563f02e935d00d2df74796f2e19fb0">&#9670;&nbsp;</a></span>share() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::share </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to create shared expression from any xexpression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>rvalue expression that will be shared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xshared expression </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a560c81d3d88fa9b3200b72e70b44c288" title="Helper function to create shared expression from any xexpression.">make_xshared</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xexpression_8hpp_source.html#l00749">749</a> of file <a class="el" href="xexpression_8hpp_source.html">xexpression.hpp</a>.</p>

</div>
</div>
<a id="ae455f4aaacbc04bebc76451907003ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae455f4aaacbc04bebc76451907003ee3">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::sort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort xexpression (optionally along axis) The sort is performed using the <code>std::sort</code> functions. </p>
<p>A copy of the xexpression is created and returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>xexpression to sort </td></tr>
    <tr><td class="paramname">axis</td><td>axis along which sort is performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sorted array (copy) </dd></dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00196">196</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="aad5c56f6a09fb0a6ebaa2ec6cf22cf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5c56f6a09fb0a6ebaa2ec6cf22cf5c">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::split </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split xexpression along axis into subexpressions. </p>
<p>This splits an xexpression along the axis in <code>n</code> equal parts and returns a vector of <code>strided_view</code>. Calling split with axis &gt; dimension of e or a <code>n</code> that does not result in an equal division of the xexpression will throw a runtime_error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">n</td><td>number of elements to return </td></tr>
    <tr><td class="paramname">axis</td><td>axis along which to split the expression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00563">563</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a2734defabe45fcb86ed9545c1b033134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2734defabe45fcb86ed9545c1b033134">&#9670;&nbsp;</a></span>squeeze() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::squeeze </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a squeeze view of the given expression. </p>
<p>No copy is made. Squeezing an expression removes dimensions of extent 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">E</td><td>the type of the expression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00373">373</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="adcffbf0452884112fd3bcf7e7077fd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcffbf0452884112fd3bcf7e7077fd6f">&#9670;&nbsp;</a></span>squeeze() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S , class Tag  = check_policy::none, std::enable_if_t&lt;!xtl::is_integral&lt; S &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::squeeze </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tag&#160;</td>
          <td class="paramname"><em>check_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove single-dimensional entries from the shape of an xexpression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">axis</td><td>integer or container of integers, select a subset of single-dimensional entries of the shape. </td></tr>
    <tr><td class="paramname">check_policy</td><td>select check_policy. With check_policy::full(), selecting an axis which is greater than one will throw a runtime_error. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00437">437</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a120ce2e841c6d13c8688cd12128fe942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120ce2e841c6d13c8688cd12128fe942">&#9670;&nbsp;</a></span>stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... CT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::stack </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; CT... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stack xexpressions along <em>axis</em>. </p>
<p>Stacking always creates a new dimension along which elements are stacked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xtuple</a> of xexpressions to concatenate </td></tr>
    <tr><td class="paramname">axis</td><td>axis along which elements are stacked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator evaluating to stacked elements</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = {1, 2, 3};</div>
<div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> b = {5, 6, 7};</div>
<div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> s = <a class="code" href="namespacext.html#a120ce2e841c6d13c8688cd12128fe942">xt::stack</a>(<a class="code" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xt::xtuple</a>(a, b)); <span class="comment">// =&gt; {{1, 2, 3},</span></div>
<div class="line">                                                    <span class="comment">//     {5, 6, 7}}</span></div>
<div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> t = <a class="code" href="namespacext.html#a120ce2e841c6d13c8688cd12128fe942">xt::stack</a>(<a class="code" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xt::xtuple</a>(a, b), 1); <span class="comment">// =&gt; {{1, 5},</span></div>
<div class="line">                                                       <span class="comment">//     {2, 6},</span></div>
<div class="line">                                                       <span class="comment">//     {3, 7}}</span></div>
<div class="ttc" id="anamespacext_html_a120ce2e841c6d13c8688cd12128fe942"><div class="ttname"><a href="namespacext.html#a120ce2e841c6d13c8688cd12128fe942">xt::stack</a></div><div class="ttdeci">auto stack(std::tuple&lt; CT... &gt; &amp;&amp;t, std::size_t axis=0)</div><div class="ttdoc">Stack xexpressions along axis.</div><div class="ttdef"><b>Definition:</b> <a href="xbuilder_8hpp_source.html#l00819">xbuilder.hpp:819</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00819">819</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="ae5c7088d2beee486998238fbc29ee7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c7088d2beee486998238fbc29ee7b9">&#9670;&nbsp;</a></span>strided_view() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::strided_view </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacext.html#a6e111c2e160e2edb6a2139d16c66d65a">xstrided_slice_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to create a dynamic view from an xexpression and an xstrided_slice_vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>xexpression </td></tr>
    <tr><td class="paramname">slices</td><td>the slice vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>initialized strided_view according to slices</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = {{1, 2, 3}, {4, 5, 6}};</div>
<div class="line"><a class="code" href="namespacext.html#a6e111c2e160e2edb6a2139d16c66d65a">xt::xstrided_slice_vector</a> sv({<a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">xt::range</a>(0, 1)});</div>
<div class="line">sv.push_back(<a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">xt::range</a>(0, 3, 2));</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26">xt::strided_view</a>(a, sv);</div>
<div class="line"><span class="comment">// ==&gt; {{1, 3}}</span></div>
<div class="ttc" id="anamespacext_html_a6e111c2e160e2edb6a2139d16c66d65a"><div class="ttname"><a href="namespacext.html#a6e111c2e160e2edb6a2139d16c66d65a">xt::xstrided_slice_vector</a></div><div class="ttdeci">std::vector&lt; xstrided_slice&lt; std::ptrdiff_t &gt; &gt; xstrided_slice_vector</div><div class="ttdoc">vector of slices used to build a xstrided_view</div><div class="ttdef"><b>Definition:</b> <a href="xstrided__view_8hpp_source.html#l00339">xstrided_view.hpp:339</a></div></div>
</div><!-- fragment --><p>You can also achieve the same with the following short-hand syntax:</p>
<div class="fragment"><div class="line"><a class="code" href="classxt_1_1xarray__container.html">xt::xarray&lt;double&gt;</a> a = {{1, 2, 3}, {4, 5, 6}};</div>
<div class="line"><span class="keyword">auto</span> v = <a class="code" href="namespacext.html#aca6714111810062b91a1c9e31bd69b26">xt::strided_view</a>(a, {<a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">xt::range</a>(0, 1), <a class="code" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181">xt::range</a>(0, 3, 2)});</div>
<div class="line"><span class="comment">// ==&gt; {{1, 3}}</span></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="xstrided__view_8hpp_source.html#l00699">699</a> of file <a class="el" href="xstrided__view_8hpp_source.html">xstrided_view.hpp</a>.</p>

</div>
</div>
<a id="aca6714111810062b91a1c9e31bd69b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6714111810062b91a1c9e31bd69b26">&#9670;&nbsp;</a></span>strided_view() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;layout_type L = layout_type::dynamic, class E , class S , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::strided_view </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacext.html#a54ee24a1069c6e670d687af9e6aa4ba6">layout_type</a>&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a strided view from an xexpression, shape, strides and offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>xexpression </td></tr>
    <tr><td class="paramname">shape</td><td>the shape of the view </td></tr>
    <tr><td class="paramname">strides</td><td>the new strides of the view </td></tr>
    <tr><td class="paramname">offset</td><td>the offset of the first element in the underlying container </td></tr>
    <tr><td class="paramname">layout</td><td>the new layout of the expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>the static layout type of the view (default: dynamic) </td></tr>
    <tr><td class="paramname">E</td><td>type of xexpression </td></tr>
    <tr><td class="paramname">S</td><td>strides type </td></tr>
    <tr><td class="paramname">X</td><td>strides type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the view </dd></dl>

<p class="definition">Definition at line <a class="el" href="xstrided__view_8hpp_source.html#l00647">647</a> of file <a class="el" href="xstrided__view_8hpp_source.html">xstrided_view.hpp</a>.</p>

</div>
</div>
<a id="ad5270a2924bb17bc641c5846355149bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5270a2924bb17bc641c5846355149bc">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type, xtl::check_concept&lt; xtl::is_integral&lt; S &gt; &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::tile </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>reps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tile an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The array. </td></tr>
    <tr><td class="paramname">reps</td><td>The number of repetitions of A along the first axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tiled array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xpad_8hpp_source.html#l00305">305</a> of file <a class="el" href="xpad_8hpp_source.html">xpad.hpp</a>.</p>

</div>
</div>
<a id="a65ddcadd66cb7d479944b1da073f2ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ddcadd66cb7d479944b1da073f2ce9">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S  = typename std::decay_t&lt;E&gt;::size_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::tile </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; S &gt;&#160;</td>
          <td class="paramname"><em>reps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tile an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The array. </td></tr>
    <tr><td class="paramname">reps</td><td>The number of repetitions of A along each axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tiled array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xpad_8hpp_source.html#l00286">286</a> of file <a class="el" href="xpad_8hpp_source.html">xpad.hpp</a>.</p>

</div>
</div>
<a id="aafd7842df1c7034546b2a84bff7fd97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd7842df1c7034546b2a84bff7fd97b">&#9670;&nbsp;</a></span>to_json()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename U, typename V, typename... Args &gt; class M, class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enable_xexpression&lt; E &gt; xt::to_json </td>
          <td>(</td>
          <td class="paramtype">nlohmann::basic_json&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>JSON serialization of an xtensor expression. </p>
<p>The to_json method is used by the nlohmann_json package for automatic serialization of user-defined types. The method is picked up by argument-dependent lookup.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>a JSON object </td></tr>
    <tr><td class="paramname">e</td><td>a const <a class="el" href="classxt_1_1xexpression.html">xexpression</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xjson_8hpp_source.html#l00133">133</a> of file <a class="el" href="xjson_8hpp_source.html">xjson.hpp</a>.</p>

</div>
</div>
<a id="a620b1159b15601a1fd9b2ddaa746225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620b1159b15601a1fd9b2ddaa746225e">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::transpose </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transpose view by reversing the dimensions of xexpression e. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input expression </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00211">211</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="ae8b37193755be9f7e4c0161a6d9f9b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b37193755be9f7e4c0161a6d9f9b6b">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class S , class Tag  = check_policy::none&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::transpose </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tag&#160;</td>
          <td class="paramname"><em>check_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transpose view by permuting the xexpression e with <code>permutation</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the input expression </td></tr>
    <tr><td class="paramname">permutation</td><td>the sequence containing permutation </td></tr>
    <tr><td class="paramname">check_policy</td><td>the check level (check_policy::full() or check_policy::none()) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>selects the level of error checking on permutation vector defaults to <a class="el" href="structxt_1_1check__policy_1_1none.html">check_policy::none</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00235">235</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="ab524d3db6722f5d0e09347aedcf63837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab524d3db6722f5d0e09347aedcf63837">&#9670;&nbsp;</a></span>tril()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::tril </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract lower triangular matrix from xexpression. </p>
<p>The parameter k selects the offset of the diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the input array </td></tr>
    <tr><td class="paramname">k</td><td>the diagonal above which to zero elements. 0 (default) selects the main diagonal, k &lt; 0 is below the main diagonal, k &gt; 0 above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xexpression containing lower triangle from arr, 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l01143">1143</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a938cc86961805cf29a1f68394922d9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938cc86961805cf29a1f68394922d9f7">&#9670;&nbsp;</a></span>trim_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::trim_zeros </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim zeros at beginning, end or both of 1D sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">direction</td><td>string of either 'f' for trim from beginning, 'b' for trim from end or 'fb' (default) for both. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns a view without zeros at the beginning and end </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00338">338</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a5ca4a423657a4a9c4ec4852dd344164b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca4a423657a4a9c4ec4852dd344164b">&#9670;&nbsp;</a></span>triu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::triu </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract upper triangular matrix from xexpression. </p>
<p>The parameter k selects the offset of the diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the input array </td></tr>
    <tr><td class="paramname">k</td><td>the diagonal below which to zero elements. 0 (default) selects the main diagonal, k &lt; 0 is below the main diagonal, k &gt; 0 above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xexpression containing lower triangle from arr, 0 otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l01162">1162</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a2b46eaf022e2fcd9e82ae5223fdd3ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b46eaf022e2fcd9e82ae5223fdd3ed5">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::unique </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find unique elements of a xexpression. </p>
<p>This returns a flattened xtensor with sorted, unique elements from the original expression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression (will be flattened) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xsort_8hpp_source.html#l00912">912</a> of file <a class="el" href="xsort_8hpp_source.html">xsort.hpp</a>.</p>

</div>
</div>
<a id="aedc2027ff309134dff5b0720699c5ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc2027ff309134dff5b0720699c5ffa">&#9670;&nbsp;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E , class... S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::view </td>
          <td>(</td>
          <td class="paramtype">E &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;...&#160;</td>
          <td class="paramname"><em>slices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs and returns a view on the specified xexpression. </p>
<p>Users should not directly construct the slices but call helper functions instead. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression to adapt </td></tr>
    <tr><td class="paramname">slices</td><td>the slices list describing the view. <code>view</code> accepts negative indices, in that case indexing is done in reverse order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacext.html#a12df38a6d4e688b6df1a4641930c6181" title="Select a range from start_val to stop_val (excluded).">range</a>, <a class="el" href="group__logical__operators.html#ga8da84f179efb13f3d860c5950b5c626e" title="Any.">all</a>, <a class="el" href="namespacext.html#a534914903c805a597a5fac60e60e7c43" title="Returns a slice representing a new axis of length one, to be used as an argument of view function.">newaxis</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="xview_8hpp_source.html#l01767">1767</a> of file <a class="el" href="xview_8hpp_source.html">xview.hpp</a>.</p>

</div>
</div>
<a id="ad25f3a38510304cf1e3489748a43812c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25f3a38510304cf1e3489748a43812c">&#9670;&nbsp;</a></span>vsplit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::vsplit </td>
          <td>(</td>
          <td class="paramtype">E &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split an xexpression into subexpressions vertically (row-wise) </p>
<p>This method is equivalent to <code>split(e, n, 0)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>input xexpression </td></tr>
    <tr><td class="paramname">n</td><td>number of elements to return </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xmanipulation_8hpp_source.html#l00612">612</a> of file <a class="el" href="xmanipulation_8hpp_source.html">xmanipulation.hpp</a>.</p>

</div>
</div>
<a id="a87a9e875318fc87aba41154dddee7c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a9e875318fc87aba41154dddee7c60">&#9670;&nbsp;</a></span>vstack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... CT&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::vstack </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; CT... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stack xexpressions in sequence vertically (row wise). </p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays of shape (N) have been reshape to (1, N).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td><a class="el" href="namespacext.html#ae0a17e1fea8041f69a66d80928359150">xtuple</a> of xexpressions to stack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xgenerator evaluating to stacked elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00872">872</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="ae0a17e1fea8041f69a66d80928359150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a17e1fea8041f69a66d80928359150">&#9670;&nbsp;</a></span>xtuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::xtuple </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates tuples from arguments for <a class="el" href="namespacext.html#a28c746e1a420f706892d9aff3ad0dd30">concatenate</a> and <a class="el" href="namespacext.html#a120ce2e841c6d13c8688cd12128fe942">stack</a>. </p>
<p>Very similar to std::make_tuple. </p>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00651">651</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a700dc20edb5a81d66d5f89d350dca46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700dc20edb5a81d66d5f89d350dca46f">&#9670;&nbsp;</a></span>zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::zeros </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classxt_1_1xexpression.html">xexpression</a> containing zeros of the specified shape. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">shape</td><td>the shape of the returned expression. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00066">66</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
<a id="a68f9dd4af039df60663af606046a3b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f9dd4af039df60663af606046a3b73">&#9670;&nbsp;</a></span>zeros_like()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xt::zeros_like </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxt_1_1xexpression.html">xexpression</a>&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a xcontainer (xarray, xtensor or xtensor_fixed), filled with zeros and of the same shape, value type and layout as the input xexpression <em>e</em>. </p>
<p>Note: contrary to zeros(shape), this function returns a non-lazy, allocated container! Use `<code><a class="el" href="namespacext.html#a700dc20edb5a81d66d5f89d350dca46f" title="Returns an xexpression containing zeros of the specified shape.">xt::zeros</a>&lt;double&gt;(e.shape());</code> for a lazy version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the xexpression from which to extract shape, value type and layout. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="xbuilder_8hpp_source.html#l00154">154</a> of file <a class="el" href="xbuilder_8hpp_source.html">xbuilder.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacext.html">xt</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
